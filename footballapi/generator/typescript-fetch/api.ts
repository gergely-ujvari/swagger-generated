/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Football API
 * API for accessing various kinds of football data, updated in real time.
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://false/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BasicPlayerStats
 */
export interface BasicPlayerStats extends PlayerStatsExtended {
    /**
     * 
     * @type {Player}
     * @memberof BasicPlayerStats
     */
    player?: Player;
    /**
     * Player's shirt number during the season
     * @type {number}
     * @memberof BasicPlayerStats
     */
    shirtNumber?: number;
}
/**
 * 
 * @export
 * @interface BlacklistDto
 */
export interface BlacklistDto {
    /**
     * 
     * @type {string}
     * @memberof BlacklistDto
     */
    id?: string;
    /**
     * 
     * @type {BlacklistKeyDto}
     * @memberof BlacklistDto
     */
    key?: BlacklistKeyDto;
}
/**
 * 
 * @export
 * @interface BlacklistKeyDto
 */
export interface BlacklistKeyDto {
    /**
     * 
     * @type {string}
     * @memberof BlacklistKeyDto
     */
    type?: BlacklistKeyDto.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BlacklistKeyDto
     */
    entity?: BlacklistKeyDto.EntityEnum;
    /**
     * 
     * @type {string}
     * @memberof BlacklistKeyDto
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof BlacklistKeyDto
     */
    context?: string;
}

/**
 * @export
 * @namespace BlacklistKeyDto
 */
export namespace BlacklistKeyDto {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        TRANSLATION = <any> 'TRANSLATION',
        ASSET = <any> 'ASSET',
        RELATION = <any> 'RELATION',
        ENTITY = <any> 'ENTITY'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EntityEnum {
        TEAM = <any> 'TEAM',
        TOURNAMENT = <any> 'TOURNAMENT',
        SEASON = <any> 'SEASON',
        GROUP = <any> 'GROUP',
        STAGE = <any> 'STAGE',
        COUNTRY = <any> 'COUNTRY',
        PLAYER = <any> 'PLAYER',
        COACH = <any> 'COACH',
        LINEUPPLAYERTYPE = <any> 'LINEUP_PLAYER_TYPE',
        MATCHSTATUS = <any> 'MATCH_STATUS',
        VENUE = <any> 'VENUE',
        REFEREE = <any> 'REFEREE',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        LINEUP = <any> 'LINEUP',
        MATCH = <any> 'MATCH',
        ASSET = <any> 'ASSET',
        STANDINGRULE = <any> 'STANDING_RULE',
        ROUNDTYPE = <any> 'ROUND_TYPE'
    }
}
/**
 * 
 * @export
 * @interface CardlistStandingData
 */
export interface CardlistStandingData extends StandingData {
    /**
     * 
     * @type {PartialPerson}
     * @memberof CardlistStandingData
     */
    player: PartialPerson;
    /**
     * Number of red cards
     * @type {number}
     * @memberof CardlistStandingData
     */
    redCards: number;
    /**
     * Total number of cards received
     * @type {number}
     * @memberof CardlistStandingData
     */
    totalCards: number;
    /**
     * Total number of yellow cards
     * @type {number}
     * @memberof CardlistStandingData
     */
    yellowCards: number;
    /**
     * Number of times the Player has been booked, with a first yellow card
     * @type {number}
     * @memberof CardlistStandingData
     */
    firstYellowCards: number;
}
/**
 * 
 * @export
 * @interface CityDto
 */
export interface CityDto {
    /**
     * 
     * @type {string}
     * @memberof CityDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CityDto
     */
    name?: string;
    /**
     * 
     * @type {CountryDto}
     * @memberof CityDto
     */
    country?: CountryDto;
}
/**
 * 
 * @export
 * @interface CityEditDto
 */
export interface CityEditDto {
    /**
     * 
     * @type {string}
     * @memberof CityEditDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CityEditDto
     */
    countryId?: string;
}
/**
 * 
 * @export
 * @interface Coach
 */
export interface Coach {
    /**
     * 277x338 full body image of Person
     * @type {string}
     * @memberof Coach
     */
    urlImage?: string;
    /**
     * 
     * @type {Country}
     * @memberof Coach
     */
    country?: Country;
    /**
     * Date when the person was born
     * @type {string}
     * @memberof Coach
     */
    birthdate?: string;
    /**
     * Human readable first(given) name
     * @type {string}
     * @memberof Coach
     */
    firstName?: string;
    /**
     * Human readable last(family) name
     * @type {string}
     * @memberof Coach
     */
    lastName?: string;
    /**
     * True if currently active, false if retired
     * @type {boolean}
     * @memberof Coach
     */
    active?: boolean;
    /**
     * Person's gender
     * @type {string}
     * @memberof Coach
     */
    gender?: Coach.GenderEnum;
    /**
     * Unique identifier within the system
     * @type {number}
     * @memberof Coach
     */
    id?: number;
    /**
     * Human readable name of the Person
     * @type {string}
     * @memberof Coach
     */
    name: string;
    /**
     * 150x150 face image of Person
     * @type {string}
     * @memberof Coach
     */
    urlThumb?: string;
}

/**
 * @export
 * @namespace Coach
 */
export namespace Coach {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface CoachDto
 */
export interface CoachDto {
    /**
     * 
     * @type {number}
     * @memberof CoachDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CoachDto
     */
    name?: string;
    /**
     * 
     * @type {CountryDto}
     * @memberof CoachDto
     */
    country?: CountryDto;
    /**
     * 
     * @type {string}
     * @memberof CoachDto
     */
    birthdate?: string;
    /**
     * 
     * @type {string}
     * @memberof CoachDto
     */
    gender?: CoachDto.GenderEnum;
}

/**
 * @export
 * @namespace CoachDto
 */
export namespace CoachDto {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface CoachEditDto
 */
export interface CoachEditDto {
    /**
     * 
     * @type {string}
     * @memberof CoachEditDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CoachEditDto
     */
    countryId?: string;
    /**
     * 
     * @type {string}
     * @memberof CoachEditDto
     */
    birthdate?: string;
}
/**
 * 
 * @export
 * @interface CoachPageDto
 */
export interface CoachPageDto {
    /**
     * 
     * @type {Array<CoachDto>}
     * @memberof CoachPageDto
     */
    coaches?: Array<CoachDto>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof CoachPageDto
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * Unique identifier of the object within the system
     * @type {number}
     * @memberof Country
     */
    id: number;
    /**
     * Human known name of the Country
     * @type {string}
     * @memberof Country
     */
    name: string;
    /**
     * 2 letter country code if available
     * @type {string}
     * @memberof Country
     */
    code?: string;
    /**
     * Image of the flag for the Country
     * @type {string}
     * @memberof Country
     */
    urlFlag?: string;
}
/**
 * 
 * @export
 * @interface CountryDto
 */
export interface CountryDto {
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface Dto
 */
export interface Dto {
    /**
     * 
     * @type {string}
     * @memberof Dto
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Dto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Dto
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Number of spectators at the event
     * @type {number}
     * @memberof Event
     */
    spectators?: number;
    /**
     * 
     * @type {PartialTournamentSeasonStage}
     * @memberof Event
     */
    tournamentSeasonStage: PartialTournamentSeasonStage;
    /**
     * Live minute ticker. Only available if the event_status.type is 'inprogress'
     * @type {number}
     * @memberof Event
     */
    minute?: number;
    /**
     * 
     * @type {StageGroup}
     * @memberof Event
     */
    stageGroup?: StageGroup;
    /**
     * 
     * @type {PartialPerson}
     * @memberof Event
     */
    referee?: PartialPerson;
    /**
     * 
     * @type {Venue}
     * @memberof Event
     */
    venue?: Venue;
    /**
     * Number of incidents which have occured in the Event (goals, red cards, yellow cards, etc).
     * @type {number}
     * @memberof Event
     */
    incidents?: number;
    /**
     * Indicates whether player lineup information is available or not
     * @type {boolean}
     * @memberof Event
     */
    lineupAvailable?: boolean;
    /**
     * Indicates whether the event has livescore updates. If false the event will be updated after FT.
     * @type {boolean}
     * @memberof Event
     */
    liveUpdates?: boolean;
    /**
     * Indicates whether teamstats are available for this event
     * @type {boolean}
     * @memberof Event
     */
    teamstatsAvailable?: boolean;
    /**
     * 
     * @type {TeamScore}
     * @memberof Event
     */
    homeScore?: TeamScore;
    /**
     * 
     * @type {TeamScore}
     * @memberof Event
     */
    awayScore?: TeamScore;
    /**
     * timestamp when the current phase (1st_half, 2nd_half, et, etc) has started. Can be used for calculating the minute ticker
     * @type {Date}
     * @memberof Event
     */
    startedAt?: Date;
    /**
     * Unique identifier
     * @type {number}
     * @memberof Event
     */
    id: number;
    /**
     * 
     * @type {EventStatus}
     * @memberof Event
     */
    eventStatus: EventStatus;
    /**
     * Timestamp when the event is scheduled to start
     * @type {Date}
     * @memberof Event
     */
    startTime: Date;
    /**
     * Goals scored by the home team
     * @type {number}
     * @memberof Event
     */
    goalHome?: number;
    /**
     * Goals scored by the away team
     * @type {number}
     * @memberof Event
     */
    goalAway?: number;
    /**
     * Penalties scored by the home team. Available only if the game goes to penalty shootouts
     * @type {number}
     * @memberof Event
     */
    penaltyHome?: number;
    /**
     * Penalties scored by the away team. Available only if the game goes to penalty shootouts
     * @type {number}
     * @memberof Event
     */
    penaltyAway?: number;
    /**
     * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
     * @type {number}
     * @memberof Event
     */
    aggHome?: number;
    /**
     * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
     * @type {number}
     * @memberof Event
     */
    aggAway?: number;
    /**
     * 
     * @type {PartialTeam}
     * @memberof Event
     */
    homeTeam: PartialTeam;
    /**
     * 
     * @type {PartialTeam}
     * @memberof Event
     */
    awayTeam: PartialTeam;
}
/**
 * 
 * @export
 * @interface EventIncident
 */
export interface EventIncident {
    /**
     * Unique identifier
     * @type {number}
     * @memberof EventIncident
     */
    id: number;
    /**
     * Identifier of the event during which the incident occurred
     * @type {number}
     * @memberof EventIncident
     */
    eventId: number;
    /**
     * The type of incident
     * @type {string}
     * @memberof EventIncident
     */
    type: EventIncident.TypeEnum;
    /**
     * Whether the incident is related to the home or away team. true if home team
     * @type {boolean}
     * @memberof EventIncident
     */
    homeTeam: boolean;
    /**
     * The minute when the incident occured
     * @type {number}
     * @memberof EventIncident
     */
    minute: number;
    /**
     * Id of the team for which the incident is related
     * @type {number}
     * @memberof EventIncident
     */
    teamId?: number;
    /**
     * Updated home team score if the incident changes the scoreline (penalty, goal, own_goal, etc)
     * @type {number}
     * @memberof EventIncident
     */
    goalHome?: number;
    /**
     * Updated away team score  if the incident changes the scoreline (penalty, goal, own_goal, etc)
     * @type {number}
     * @memberof EventIncident
     */
    goalAway?: number;
    /**
     * 
     * @type {PartialPerson}
     * @memberof EventIncident
     */
    player?: PartialPerson;
    /**
     * 
     * @type {PartialPerson}
     * @memberof EventIncident
     */
    relPlayer?: PartialPerson;
    /**
     * Whether the incident has been deleted or not - a disallowed goal for example
     * @type {boolean}
     * @memberof EventIncident
     */
    deleted?: boolean;
    /**
     * If there are multiple incidents with the same minute, this indicates how they are sorted
     * @type {number}
     * @memberof EventIncident
     */
    sortorder?: number;
}

/**
 * @export
 * @namespace EventIncident
 */
export namespace EventIncident {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PenaltyShootoutScored = <any> 'penalty_shootout_scored',
        YellowCardRed = <any> 'yellow_card_red',
        PenaltyShootoutMissed = <any> 'penalty_shootout_missed',
        Substitution = <any> 'substitution',
        Goal = <any> 'goal',
        RedCard = <any> 'red_card',
        PenaltyMiss = <any> 'penalty_miss',
        YellowCard = <any> 'yellow_card',
        PenaltyGoal = <any> 'penalty_goal',
        OwnGoal = <any> 'own_goal'
    }
}
/**
 * 
 * @export
 * @interface EventPlayer
 */
export interface EventPlayer {
    /**
     * Unique identifier
     * @type {number}
     * @memberof EventPlayer
     */
    id: number;
    /**
     * 
     * @type {PartialPerson}
     * @memberof EventPlayer
     */
    player: PartialPerson;
    /**
     * 
     * @type {EventPlayerType}
     * @memberof EventPlayer
     */
    eventPlayerType: EventPlayerType;
    /**
     * Whether the player is from the home or the away team
     * @type {boolean}
     * @memberof EventPlayer
     */
    homeTeam: boolean;
    /**
     * Number indicating the player's vertical position on the field. 1 = Goalkeeper, 2-5 = Defender, 6-9 = Midfielder, 10-11 = Forward, where 5 is an offensive defender, 9 is an offensive midfielder, etc.
     * @type {number}
     * @memberof EventPlayer
     */
    positionX?: number;
    /**
     * Number indicating the player's horizontal position on the field. Ranges from 1-9, where 1 = furthest right, 9 = furthest left.
     * @type {number}
     * @memberof EventPlayer
     */
    positionY?: number;
    /**
     * Number 1-11 indicating the player's position in the lineup. 1 = goalkeeper, 2 = defender furthest right.
     * @type {number}
     * @memberof EventPlayer
     */
    positionNumber?: number;
    /**
     * The shirt number the player is wearing
     * @type {number}
     * @memberof EventPlayer
     */
    shirtNumber?: number;
}
/**
 * 
 * @export
 * @interface EventPlayerSubOn
 */
export interface EventPlayerSubOn {
    /**
     * Id of the player that comes on
     * @type {number}
     * @memberof EventPlayerSubOn
     */
    playerId?: number;
    /**
     * Name of the player that comes on
     * @type {string}
     * @memberof EventPlayerSubOn
     */
    playerName: string;
    /**
     * The minute when the substitued occured
     * @type {number}
     * @memberof EventPlayerSubOn
     */
    elapsed: number;
}
/**
 * 
 * @export
 * @interface EventPlayerType
 */
export interface EventPlayerType {
    /**
     * Indicates what part of the lineup the player belongs to
     * @type {string}
     * @memberof EventPlayerType
     */
    category: EventPlayerType.CategoryEnum;
    /**
     * Human readable name of the type
     * @type {string}
     * @memberof EventPlayerType
     */
    name: string;
    /**
     * Internal unique code to identify the type
     * @type {string}
     * @memberof EventPlayerType
     */
    code: string;
}

/**
 * @export
 * @namespace EventPlayerType
 */
export namespace EventPlayerType {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        Miss = <any> 'miss',
        Sub = <any> 'sub',
        Start = <any> 'start',
        Unknown = <any> 'unknown'
    }
}
/**
 * 
 * @export
 * @interface EventStatus
 */
export interface EventStatus {
    /**
     * Status classification
     * @type {string}
     * @memberof EventStatus
     */
    type: EventStatus.TypeEnum;
    /**
     * Human readable name describing the status, can be translated
     * @type {string}
     * @memberof EventStatus
     */
    name: string;
    /**
     * Human readable short name describing the status, can be translated
     * @type {string}
     * @memberof EventStatus
     */
    shortName?: string;
    /**
     * Unique string used to identify the status
     * @type {string}
     * @memberof EventStatus
     */
    code: EventStatus.CodeEnum;
}

/**
 * @export
 * @namespace EventStatus
 */
export namespace EventStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Notstarted = <any> 'notstarted',
        Interrupted = <any> 'interrupted',
        Inprogress = <any> 'inprogress'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        Finished = <any> 'finished',
        NotStarted = <any> 'not_started',
        _1stHalf = <any> '1st_half',
        _2ndHalf = <any> '2nd_half'
    }
}
/**
 * 
 * @export
 * @interface EventTeamStats
 */
export interface EventTeamStats {
    /**
     * 
     * @type {PartialTeam}
     * @memberof EventTeamStats
     */
    team: PartialTeam;
    /**
     * Whether the stats are for the home or the away team
     * @type {boolean}
     * @memberof EventTeamStats
     */
    homeTeam: boolean;
    /**
     * 
     * @type {TeamStatistics}
     * @memberof EventTeamStats
     */
    statistics: TeamStatistics;
    /**
     * Identifier of the event the stat is related to
     * @type {number}
     * @memberof EventTeamStats
     */
    eventId?: number;
}
/**
 * 
 * @export
 * @interface EventsByDate
 */
export interface EventsByDate {
    /**
     * 
     * @type {string}
     * @memberof EventsByDate
     */
    date: string;
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventsByDate
     */
    items: Array<Event>;
}
/**
 * 
 * @export
 * @interface LanguageDto
 */
export interface LanguageDto {
    /**
     * 
     * @type {string}
     * @memberof LanguageDto
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface LeagueStandingData
 */
export interface LeagueStandingData extends StandingData {
    /**
     * 
     * @type {PartialTeamWithForm}
     * @memberof LeagueStandingData
     */
    team?: PartialTeamWithForm;
    /**
     * Games won
     * @type {number}
     * @memberof LeagueStandingData
     */
    wins: number;
    /**
     * Games drawn
     * @type {number}
     * @memberof LeagueStandingData
     */
    draws: number;
    /**
     * Total games played
     * @type {number}
     * @memberof LeagueStandingData
     */
    played: number;
    /**
     * Number of points
     * @type {number}
     * @memberof LeagueStandingData
     */
    points: number;
    /**
     * Games lost
     * @type {number}
     * @memberof LeagueStandingData
     */
    defeits: number;
    /**
     * Total number of goals scored
     * @type {number}
     * @memberof LeagueStandingData
     */
    goalsFor: number;
    /**
     * Total number of goals conceded
     * @type {number}
     * @memberof LeagueStandingData
     */
    goalsAgainst: number;
}
/**
 * 
 * @export
 * @interface Lineup
 */
export interface Lineup {
    /**
     * Id of the event for which the lineup is for
     * @type {number}
     * @memberof Lineup
     */
    eventId: number;
    /**
     * Whether the lineup is officially confirmed. Should be considered probable if != true
     * @type {boolean}
     * @memberof Lineup
     */
    confirmed?: boolean;
    /**
     * 
     * @type {TeamLineup}
     * @memberof Lineup
     */
    homeTeam: TeamLineup;
    /**
     * 
     * @type {TeamLineup}
     * @memberof Lineup
     */
    awayTeam: TeamLineup;
}
/**
 * 
 * @export
 * @interface ListVenueDto
 */
export interface ListVenueDto {
    /**
     * 
     * @type {string}
     * @memberof ListVenueDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ListVenueDto
     */
    name?: string;
    /**
     * 
     * @type {CountryDto}
     * @memberof ListVenueDto
     */
    country?: CountryDto;
    /**
     * 
     * @type {CityDto}
     * @memberof ListVenueDto
     */
    city?: CityDto;
    /**
     * 
     * @type {any}
     * @memberof ListVenueDto
     */
    profile?: any;
}
/**
 * 
 * @export
 * @interface LiveCommentaryOutputDto
 */
export interface LiveCommentaryOutputDto {
    /**
     * 
     * @type {string}
     * @memberof LiveCommentaryOutputDto
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof LiveCommentaryOutputDto
     */
    templateText?: string;
    /**
     * 
     * @type {string}
     * @memberof LiveCommentaryOutputDto
     */
    autoText?: string;
    /**
     * 
     * @type {number}
     * @memberof LiveCommentaryOutputDto
     */
    elapsed?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof LiveCommentaryOutputDto
     */
    details?: Array<any>;
    /**
     * 
     * @type {Date}
     * @memberof LiveCommentaryOutputDto
     */
    incidentTimestamp?: Date;
}
/**
 * 
 * @export
 * @interface MappingsSearchBody
 */
export interface MappingsSearchBody {
    /**
     * Data entity provider name
     * @type {string}
     * @memberof MappingsSearchBody
     */
    provider: string;
    /**
     * Mapping requests
     * @type {Array<V2MappingRequestDto>}
     * @memberof MappingsSearchBody
     */
    mappingRequests: Array<V2MappingRequestDto>;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Odd
 */
export interface Odd {
    /**
     * 
     * @type {OddProvider}
     * @memberof Odd
     */
    oddProvider?: OddProvider;
    /**
     * Id of the event for which odds are provided
     * @type {number}
     * @memberof Odd
     */
    eventId?: number;
}
/**
 * 
 * @export
 * @interface OddProvider
 */
export interface OddProvider {
    /**
     * Resource identifier
     * @type {number}
     * @memberof OddProvider
     */
    id: number;
    /**
     * Human readable name of the OddProvider
     * @type {string}
     * @memberof OddProvider
     */
    name: string;
    /**
     * Homepage of the OddProvider
     * @type {string}
     * @memberof OddProvider
     */
    url?: string;
    /**
     * 
     * @type {Country}
     * @memberof OddProvider
     */
    country?: Country;
    /**
     * 
     * @type {string}
     * @memberof OddProvider
     */
    urlLogo?: string;
}
/**
 * 
 * @export
 * @interface OutputDto
 */
export interface OutputDto {
    /**
     * 
     * @type {PartialPerson}
     * @memberof OutputDto
     */
    player: PartialPerson;
    /**
     * 
     * @type {PartialTeam}
     * @memberof OutputDto
     */
    team: PartialTeam;
    /**
     * 
     * @type {TournamentSeason}
     * @memberof OutputDto
     */
    season: TournamentSeason;
    /**
     * 
     * @type {Tournament}
     * @memberof OutputDto
     */
    tournament: Tournament;
}
/**
 * 
 * @export
 * @interface PageMetaDto
 */
export interface PageMetaDto {
    /**
     * 
     * @type {number}
     * @memberof PageMetaDto
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetaDto
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetaDto
     */
    limit?: number;
}
/**
 * 
 * @export
 * @interface PartialEvent
 */
export interface PartialEvent {
    /**
     * Unique identifier
     * @type {number}
     * @memberof PartialEvent
     */
    id: number;
    /**
     * 
     * @type {EventStatus}
     * @memberof PartialEvent
     */
    eventStatus: EventStatus;
    /**
     * Timestamp when the event is scheduled to start
     * @type {Date}
     * @memberof PartialEvent
     */
    startTime: Date;
    /**
     * Goals scored by the home team
     * @type {number}
     * @memberof PartialEvent
     */
    goalHome: number;
    /**
     * Goals scored by the away team
     * @type {number}
     * @memberof PartialEvent
     */
    goalAway: number;
    /**
     * Penalties scored by the home team. Available only if the game goes to penalty shootouts
     * @type {number}
     * @memberof PartialEvent
     */
    penaltyHome?: number;
    /**
     * Penalties scored by the away team. Available only if the game goes to penalty shootouts
     * @type {number}
     * @memberof PartialEvent
     */
    penaltyAway?: number;
    /**
     * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
     * @type {number}
     * @memberof PartialEvent
     */
    aggHome?: number;
    /**
     * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
     * @type {number}
     * @memberof PartialEvent
     */
    aggAway?: number;
    /**
     * 
     * @type {PartialTeam}
     * @memberof PartialEvent
     */
    homeTeam: PartialTeam;
    /**
     * 
     * @type {PartialTeam}
     * @memberof PartialEvent
     */
    awayTeam: PartialTeam;
}
/**
 * 
 * @export
 * @interface PartialPerson
 */
export interface PartialPerson {
    /**
     * Unique identifier within the system
     * @type {number}
     * @memberof PartialPerson
     */
    id: number;
    /**
     * Human readable name of the Person
     * @type {string}
     * @memberof PartialPerson
     */
    name: string;
    /**
     * 150x150 face image of Person
     * @type {string}
     * @memberof PartialPerson
     */
    urlThumb?: string;
    /**
     * 277x338 full body image of Person
     * @type {string}
     * @memberof PartialPerson
     */
    urlImage?: string;
}
/**
 * 
 * @export
 * @interface PartialTeam
 */
export interface PartialTeam {
    /**
     * Whether the team is a football club(Barcelona) or national team(Spain)
     * @type {boolean}
     * @memberof PartialTeam
     */
    national?: boolean;
    /**
     * Unique identifier of the Team within the system
     * @type {number}
     * @memberof PartialTeam
     */
    id: number;
    /**
     * Human readable name of the team
     * @type {string}
     * @memberof PartialTeam
     */
    name: string;
    /**
     * 3 character name of team
     * @type {string}
     * @memberof PartialTeam
     */
    threeLetterCode?: string;
    /**
     * Manually inserted short name of team
     * @type {string}
     * @memberof PartialTeam
     */
    shortName?: string;
    /**
     * If present and = true, the team can be one of two teams. This occurs in cup competitions when some games are still not played
     * @type {boolean}
     * @memberof PartialTeam
     */
    undecided?: boolean;
    /**
     * Team gender, MALE, FEMALE or null
     * @type {string}
     * @memberof PartialTeam
     */
    gender?: PartialTeam.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PartialTeam
     */
    urlLogo?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialTeam
     */
    type?: PartialTeam.TypeEnum;
}

/**
 * @export
 * @namespace PartialTeam
 */
export namespace PartialTeam {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Placeholder = <any> 'placeholder',
        Club = <any> 'club',
        National = <any> 'national'
    }
}
/**
 * 
 * @export
 * @interface PartialTeamWithForm
 */
export interface PartialTeamWithForm extends PartialTeam {
    /**
     * Form guide for the Team if available and requested as an option
     * @type {Array<TeamForm>}
     * @memberof PartialTeamWithForm
     */
    form?: Array<TeamForm>;
}

/**
 * @export
 * @namespace PartialTeamWithForm
 */
export namespace PartialTeamWithForm {
}
/**
 * 
 * @export
 * @interface PartialTournamentSeasonStage
 */
export interface PartialTournamentSeasonStage {
    /**
     * Unique identifier
     * @type {number}
     * @memberof PartialTournamentSeasonStage
     */
    id: number;
    /**
     * Human readable name of the TournamentSeasonStage
     * @type {string}
     * @memberof PartialTournamentSeasonStage
     */
    name: string;
    /**
     * Whether the stage is a cup such as Champions League Knockout stage, World Cup Final stages, etc
     * @type {boolean}
     * @memberof PartialTournamentSeasonStage
     */
    cup: boolean;
    /**
     * Id of the TournamentSeason in which the stage is part of
     * @type {number}
     * @memberof PartialTournamentSeasonStage
     */
    tournamentSeasonId: number;
    /**
     * Id of the Tournament in whicth the stage is part of
     * @type {number}
     * @memberof PartialTournamentSeasonStage
     */
    tournamentId: number;
    /**
     * 
     * @type {Country}
     * @memberof PartialTournamentSeasonStage
     */
    country: Country;
    /**
     * Indicates which confederation the stage is part of (for World Cup qualif.)
     * @type {string}
     * @memberof PartialTournamentSeasonStage
     */
    confederation?: string;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * Playing position of the player
     * @type {string}
     * @memberof Player
     */
    position?: Player.PositionEnum;
    /**
     * 
     * @type {Country}
     * @memberof Player
     */
    country: Country;
    /**
     * Date when the person was born
     * @type {string}
     * @memberof Player
     */
    birthdate?: string;
    /**
     * Human readable first(given) name
     * @type {string}
     * @memberof Player
     */
    firstName?: string;
    /**
     * Human readable last(family) name
     * @type {string}
     * @memberof Player
     */
    lastName?: string;
    /**
     * True if currently active, false if retired
     * @type {boolean}
     * @memberof Player
     */
    active?: boolean;
    /**
     * Person's gender
     * @type {string}
     * @memberof Player
     */
    gender?: Player.GenderEnum;
    /**
     * Unique identifier within the system
     * @type {number}
     * @memberof Player
     */
    id: number;
    /**
     * Human readable name of the Person
     * @type {string}
     * @memberof Player
     */
    name: string;
    /**
     * 150x150 face image of Person
     * @type {string}
     * @memberof Player
     */
    urlThumb?: string;
    /**
     * 277x338 full body image of Person
     * @type {string}
     * @memberof Player
     */
    urlImage?: string;
}

/**
 * @export
 * @namespace Player
 */
export namespace Player {
    /**
     * @export
     * @enum {string}
     */
    export enum PositionEnum {
        Keeper = <any> 'keeper',
        Defender = <any> 'defender',
        Midfielder = <any> 'midfielder',
        Forward = <any> 'forward'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface PlayerDto
 */
export interface PlayerDto {
    /**
     * 
     * @type {string}
     * @memberof PlayerDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerDto
     */
    name?: string;
    /**
     * 
     * @type {CountryDto}
     * @memberof PlayerDto
     */
    country?: CountryDto;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerDto
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlayerDto
     */
    birthdate?: string;
    /**
     * 
     * @type {CityDto}
     * @memberof PlayerDto
     */
    birthCity?: CityDto;
    /**
     * 
     * @type {PlayerProfileDto}
     * @memberof PlayerDto
     */
    profile?: PlayerProfileDto;
    /**
     * 
     * @type {PlayerEditSocialDto}
     * @memberof PlayerDto
     */
    social?: PlayerEditSocialDto;
    /**
     * 
     * @type {string}
     * @memberof PlayerDto
     */
    position?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerDto
     */
    gender?: PlayerDto.GenderEnum;
}

/**
 * @export
 * @namespace PlayerDto
 */
export namespace PlayerDto {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface PlayerEditDto
 */
export interface PlayerEditDto {
    /**
     * 
     * @type {string}
     * @memberof PlayerEditDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditDto
     */
    countryId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerEditDto
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditDto
     */
    birthdate?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditDto
     */
    birthCityId?: string;
    /**
     * 
     * @type {PlayerProfileDto}
     * @memberof PlayerEditDto
     */
    profile?: PlayerProfileDto;
    /**
     * 
     * @type {PlayerEditSocialDto}
     * @memberof PlayerEditDto
     */
    social?: PlayerEditSocialDto;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditDto
     */
    position?: string;
}
/**
 * 
 * @export
 * @interface PlayerEditSocialDto
 */
export interface PlayerEditSocialDto {
    /**
     * 
     * @type {string}
     * @memberof PlayerEditSocialDto
     */
    web?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditSocialDto
     */
    twitterId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditSocialDto
     */
    facebookId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditSocialDto
     */
    instagramId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditSocialDto
     */
    wikipediaId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerEditSocialDto
     */
    youtubeChannelId?: string;
}
/**
 * 
 * @export
 * @interface PlayerPageDto
 */
export interface PlayerPageDto {
    /**
     * 
     * @type {Array<PlayerDto>}
     * @memberof PlayerPageDto
     */
    players?: Array<PlayerDto>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof PlayerPageDto
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface PlayerProfile
 */
export interface PlayerProfile extends Player {
    /**
     * 
     * @type {TournamentSeasonWithTournament}
     * @memberof PlayerProfile
     */
    currentLeague?: TournamentSeasonWithTournament;
    /**
     * 
     * @type {PlayerTeam}
     * @memberof PlayerProfile
     */
    club?: PlayerTeam;
    /**
     * 
     * @type {PlayerTeam}
     * @memberof PlayerProfile
     */
    nationalTeam?: PlayerTeam;
    /**
     * Display name of the player position
     * @type {string}
     * @memberof PlayerProfile
     */
    positionDisplay?: string;
}

/**
 * @export
 * @namespace PlayerProfile
 */
export namespace PlayerProfile {
}
/**
 * 
 * @export
 * @interface PlayerProfileDto
 */
export interface PlayerProfileDto {
    /**
     * 
     * @type {string}
     * @memberof PlayerProfileDto
     */
    height?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerProfileDto
     */
    weight?: string;
}
/**
 * 
 * @export
 * @interface PlayerStatisticItem
 */
export interface PlayerStatisticItem {
    /**
     * 
     * @type {string}
     * @memberof PlayerStatisticItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerStatisticItem
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface PlayerStatistics
 */
export interface PlayerStatistics extends PlayerStatsExtended {
    /**
     * 
     * @type {TournamentSeasonWithTournament}
     * @memberof PlayerStatistics
     */
    tournamentSeason?: TournamentSeasonWithTournament;
    /**
     * 
     * @type {PartialPerson}
     * @memberof PlayerStatistics
     */
    player?: PartialPerson;
    /**
     * 
     * @type {PartialTeam}
     * @memberof PlayerStatistics
     */
    team?: PartialTeam;
    /**
     * Shirt number of the player during the TournamentSeason
     * @type {number}
     * @memberof PlayerStatistics
     */
    shirtNumber?: number;
    /**
     * Position of the player during the TournamentSeason
     * @type {string}
     * @memberof PlayerStatistics
     */
    position?: string;
}
/**
 * 
 * @export
 * @interface PlayerStatsBasic
 */
export interface PlayerStatsBasic {
    /**
     * Total goals scored
     * @type {number}
     * @memberof PlayerStatsBasic
     */
    goals: number;
    /**
     * Total games played
     * @type {number}
     * @memberof PlayerStatsBasic
     */
    played: number;
    /**
     * Total minutes played
     * @type {number}
     * @memberof PlayerStatsBasic
     */
    minutes: number;
    /**
     * Number of red cards
     * @type {number}
     * @memberof PlayerStatsBasic
     */
    redCards: number;
    /**
     * Number of yellow cards
     * @type {number}
     * @memberof PlayerStatsBasic
     */
    yellowCards: number;
    /**
     * Number of assists
     * @type {number}
     * @memberof PlayerStatsBasic
     */
    assists?: number;
}
/**
 * 
 * @export
 * @interface PlayerStatsExtended
 */
export interface PlayerStatsExtended extends PlayerStatsBasic {
    /**
     * Goals conceded (Goalkeeper)
     * @type {number}
     * @memberof PlayerStatsExtended
     */
    conceded?: number;
    /**
     * Games started as a substitute
     * @type {number}
     * @memberof PlayerStatsExtended
     */
    substitute?: number;
    /**
     * Games without allowing a goal (Goalkeeper)
     * @type {number}
     * @memberof PlayerStatsExtended
     */
    cleansheets?: number;
    /**
     * Games where the player has come on
     * @type {number}
     * @memberof PlayerStatsExtended
     */
    substituteIn?: number;
    /**
     * Games where the player has come off
     * @type {number}
     * @memberof PlayerStatsExtended
     */
    substituteOut?: number;
    /**
     * Minutes played after coming on as a substitute
     * @type {number}
     * @memberof PlayerStatsExtended
     */
    minutesSubstitute?: number;
}
/**
 * 
 * @export
 * @interface PlayerTeam
 */
export interface PlayerTeam extends TeamPlayerData {
    /**
     * 
     * @type {PartialTeam}
     * @memberof PlayerTeam
     */
    team: PartialTeam;
    /**
     * Whether the person is currently part of the Team
     * @type {boolean}
     * @memberof PlayerTeam
     */
    active?: boolean;
    /**
     * Date when the Person joined the team
     * @type {string}
     * @memberof PlayerTeam
     */
    startDate?: string;
    /**
     * Date when the Person left the team (if any)
     * @type {string}
     * @memberof PlayerTeam
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface RefereeDto
 */
export interface RefereeDto {
    /**
     * 
     * @type {string}
     * @memberof RefereeDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RefereeDto
     */
    name?: string;
    /**
     * 
     * @type {CountryDto}
     * @memberof RefereeDto
     */
    country?: CountryDto;
    /**
     * 
     * @type {string}
     * @memberof RefereeDto
     */
    birthdate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RefereeDto
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RefereeDto
     */
    gender?: RefereeDto.GenderEnum;
}

/**
 * @export
 * @namespace RefereeDto
 */
export namespace RefereeDto {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface RefereeEditDto
 */
export interface RefereeEditDto {
    /**
     * 
     * @type {string}
     * @memberof RefereeEditDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RefereeEditDto
     */
    countryId?: string;
    /**
     * 
     * @type {Date}
     * @memberof RefereeEditDto
     */
    birthdate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof RefereeEditDto
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface RefereePageDto
 */
export interface RefereePageDto {
    /**
     * 
     * @type {Array<RefereeDto>}
     * @memberof RefereePageDto
     */
    referees?: Array<RefereeDto>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof RefereePageDto
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface Round
 */
export interface Round {
    /**
     * 
     * @type {string}
     * @memberof Round
     */
    round: string;
    /**
     * 
     * @type {Date}
     * @memberof Round
     */
    startTime: Date;
    /**
     * 
     * @type {Date}
     * @memberof Round
     */
    endTime: Date;
    /**
     * 
     * @type {Array<PartialEvent>}
     * @memberof Round
     */
    events?: Array<PartialEvent>;
}
/**
 * 
 * @export
 * @interface SeasonDto
 */
export interface SeasonDto {
    /**
     * 
     * @type {number}
     * @memberof SeasonDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SeasonDto
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof SeasonDto
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface StageDto
 */
export interface StageDto {
    /**
     * 
     * @type {number}
     * @memberof StageDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof StageDto
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof StageDto
     */
    cup: boolean;
    /**
     * 
     * @type {SeasonDto}
     * @memberof StageDto
     */
    season: SeasonDto;
    /**
     * 
     * @type {TournamentDto}
     * @memberof StageDto
     */
    tournament: TournamentDto;
    /**
     * 
     * @type {string}
     * @memberof StageDto
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof StageDto
     */
    endDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StageDto
     */
    live?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StageDto
     */
    stageGroups?: number;
}
/**
 * 
 * @export
 * @interface StageGroup
 */
export interface StageGroup {
    /**
     * Unique resource identifier
     * @type {number}
     * @memberof StageGroup
     */
    id: number;
    /**
     * Human readable name of the Group
     * @type {string}
     * @memberof StageGroup
     */
    name: string;
    /**
     * The order in the stage of the group
     * @type {number}
     * @memberof StageGroup
     */
    orderInStage?: number;
}
/**
 * 
 * @export
 * @interface StageGroupWithStanding
 */
export interface StageGroupWithStanding extends StageGroup {
    /**
     * League Standing for the StageGroup if available and requested
     * @type {Array<LeagueStandingData>}
     * @memberof StageGroupWithStanding
     */
    standing?: Array<LeagueStandingData>;
}
/**
 * 
 * @export
 * @interface StageGroupWithStandingTournamentSeasonStage
 */
export interface StageGroupWithStandingTournamentSeasonStage extends StageGroupWithStanding {
    /**
     * 
     * @type {TournamentSeasonStage}
     * @memberof StageGroupWithStandingTournamentSeasonStage
     */
    tournamentSeasonStage: TournamentSeasonStage;
}
/**
 * 
 * @export
 * @interface StandingData
 */
export interface StandingData {
    /**
     * Position of the team/player in the standing
     * @type {number}
     * @memberof StandingData
     */
    rank: number;
    /**
     * 
     * @type {PartialTeam}
     * @memberof StandingData
     */
    team: PartialTeam;
    /**
     * List of applicable rules to the current standing rank
     * @type {Array<StandingRule>}
     * @memberof StandingData
     */
    rules?: Array<StandingRule>;
}
/**
 * 
 * @export
 * @interface StandingRule
 */
export interface StandingRule {
    /**
     * Human readable name describing the standing rule
     * @type {string}
     * @memberof StandingRule
     */
    name: string;
    /**
     * Unique code identifying the standing rule
     * @type {string}
     * @memberof StandingRule
     */
    code: string;
    /**
     * Type classification of the standing rule
     * @type {string}
     * @memberof StandingRule
     */
    type: StandingRule.TypeEnum;
    /**
     * Detailed description of the standing rule
     * @type {string}
     * @memberof StandingRule
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof StandingRule
     */
    id?: number;
}

/**
 * @export
 * @namespace StandingRule
 */
export namespace StandingRule {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Promotion = <any> 'promotion',
        PromotionPlayoff = <any> 'promotion_playoff',
        Relegation = <any> 'relegation',
        RelegationPlayoff = <any> 'relegation_playoff',
        Tiertwo = <any> 'tiertwo',
        TiertwoPlayoff = <any> 'tiertwo_playoff'
    }
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {Country}
     * @memberof Team
     */
    country: Country;
    /**
     * Name of the president of the club
     * @type {string}
     * @memberof Team
     */
    president?: string;
    /**
     * Year the club was founded
     * @type {number}
     * @memberof Team
     */
    founded?: number;
    /**
     * 
     * @type {Venue}
     * @memberof Team
     */
    venue?: Venue;
    /**
     * 
     * @type {Coach}
     * @memberof Team
     */
    coach?: Coach;
    /**
     * 
     * @type {TournamentSeasonWithTournament}
     * @memberof Team
     */
    currentLeague?: TournamentSeasonWithTournament;
    /**
     * 
     * @type {Event}
     * @memberof Team
     */
    nextEvent?: Event;
    /**
     * Various social links for the team
     * @type {any}
     * @memberof Team
     */
    social?: any;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    urlHomeKit?: string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    urlAwayKit?: string;
    /**
     * Image of the team squad
     * @type {string}
     * @memberof Team
     */
    urlSquadImage?: string;
    /**
     * Whether the team is a football club(Barcelona) or national team(Spain)
     * @type {boolean}
     * @memberof Team
     */
    national: boolean;
    /**
     * Unique identifier of the Team within the system
     * @type {number}
     * @memberof Team
     */
    id: number;
    /**
     * Human readable name of the team
     * @type {string}
     * @memberof Team
     */
    name: string;
    /**
     * 3 character name of team
     * @type {string}
     * @memberof Team
     */
    threeLetterCode?: string;
    /**
     * Manually inserted short name of team
     * @type {string}
     * @memberof Team
     */
    shortName?: string;
    /**
     * If present and = true, the team can be one of two teams. This occurs in cup competitions when some games are still not played
     * @type {boolean}
     * @memberof Team
     */
    undecided?: boolean;
    /**
     * Team gender, MALE, FEMALE or null
     * @type {string}
     * @memberof Team
     */
    gender?: Team.GenderEnum;
    /**
     * Form guide for the Team if available and requested as an option
     * @type {Array<TeamForm>}
     * @memberof Team
     */
    form?: Array<TeamForm>;
}

/**
 * @export
 * @namespace Team
 */
export namespace Team {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface TeamEditDto
 */
export interface TeamEditDto {
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    threeLetterCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    countryId: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    venueId?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    presidentId?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    coachId?: string;
    /**
     * 
     * @type {TeamSocialDto}
     * @memberof TeamEditDto
     */
    social?: TeamSocialDto;
    /**
     * 
     * @type {number}
     * @memberof TeamEditDto
     */
    founded?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamEditDto
     */
    gender?: string;
}
/**
 * 
 * @export
 * @interface TeamForm
 */
export interface TeamForm {
    /**
     * 
     * @type {PartialEvent}
     * @memberof TeamForm
     */
    event?: PartialEvent;
    /**
     * Indicates outcome of the event for the given team
     * @type {string}
     * @memberof TeamForm
     */
    outcome: TeamForm.OutcomeEnum;
}

/**
 * @export
 * @namespace TeamForm
 */
export namespace TeamForm {
    /**
     * @export
     * @enum {string}
     */
    export enum OutcomeEnum {
        W = <any> 'W',
        D = <any> 'D',
        L = <any> 'L'
    }
}
/**
 * 
 * @export
 * @interface TeamLineup
 */
export interface TeamLineup {
    /**
     * resource id of the team
     * @type {number}
     * @memberof TeamLineup
     */
    teamId?: number;
    /**
     * List of players involved for the team
     * @type {Array<EventPlayer>}
     * @memberof TeamLineup
     */
    players?: Array<EventPlayer>;
    /**
     * 
     * @type {PartialPerson}
     * @memberof TeamLineup
     */
    coach?: PartialPerson;
    /**
     * Lineup formation
     * @type {string}
     * @memberof TeamLineup
     */
    formation?: string;
}
/**
 * 
 * @export
 * @interface TeamPageDto
 */
export interface TeamPageDto {
    /**
     * 
     * @type {Array<V2Team>}
     * @memberof TeamPageDto
     */
    teams?: Array<V2Team>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof TeamPageDto
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface TeamPlayer
 */
export interface TeamPlayer extends TeamPlayerData {
    /**
     * 
     * @type {Player}
     * @memberof TeamPlayer
     */
    player: Player;
    /**
     * Whether the person is currently part of the Team
     * @type {boolean}
     * @memberof TeamPlayer
     */
    active?: boolean;
    /**
     * Date when the Person joined the team
     * @type {string}
     * @memberof TeamPlayer
     */
    startDate?: string;
    /**
     * Date when the Person left the team (if any)
     * @type {string}
     * @memberof TeamPlayer
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface TeamPlayerData
 */
export interface TeamPlayerData {
    /**
     * Shirt number which the player wears for the team
     * @type {number}
     * @memberof TeamPlayerData
     */
    shirtNumber?: number;
    /**
     * Whether the player is on loan with the team
     * @type {boolean}
     * @memberof TeamPlayerData
     */
    loan?: boolean;
    /**
     * Whether the person is currently part of the Team
     * @type {boolean}
     * @memberof TeamPlayerData
     */
    active: boolean;
    /**
     * Date when the Person joined the team
     * @type {string}
     * @memberof TeamPlayerData
     */
    startDate?: string;
    /**
     * Date when the Person left the team (if any)
     * @type {string}
     * @memberof TeamPlayerData
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface TeamPlayerSeasonStatistics
 */
export interface TeamPlayerSeasonStatistics extends TournamentSeasonWithTournament {
    /**
     * 
     * @type {Array<TeamPlayerStatistics>}
     * @memberof TeamPlayerSeasonStatistics
     */
    items?: Array<TeamPlayerStatistics>;
}
/**
 * 
 * @export
 * @interface TeamPlayerStatistics
 */
export interface TeamPlayerStatistics extends PlayerStatsExtended {
    /**
     * 
     * @type {Player}
     * @memberof TeamPlayerStatistics
     */
    player: Player;
    /**
     * 
     * @type {Team}
     * @memberof TeamPlayerStatistics
     */
    team?: Team;
    /**
     * 
     * @type {number}
     * @memberof TeamPlayerStatistics
     */
    shirtNumber?: number;
}
/**
 * 
 * @export
 * @interface TeamScore
 */
export interface TeamScore {
    /**
     * Score at the halftime break
     * @type {number}
     * @memberof TeamScore
     */
    halfTime?: number;
    /**
     * Score in regular time + injury time
     * @type {number}
     * @memberof TeamScore
     */
    ordinaryTime?: number;
    /**
     * Score in extra time, does not include the score for ordinary time
     * @type {number}
     * @memberof TeamScore
     */
    extraTime?: number;
    /**
     * Score in penalty shootout, does not include ordinarytime or extratime
     * @type {number}
     * @memberof TeamScore
     */
    penaltyShootout?: number;
}
/**
 * 
 * @export
 * @interface TeamSeasonStatistics
 */
export interface TeamSeasonStatistics {
    /**
     * 
     * @type {number}
     * @memberof TeamSeasonStatistics
     */
    teamId?: number;
    /**
     * 
     * @type {TournamentSeasonStage}
     * @memberof TeamSeasonStatistics
     */
    latestLeagueStage?: TournamentSeasonStage;
    /**
     * Player statistics for the TournamentSeason
     * @type {Array<BasicPlayerStats>}
     * @memberof TeamSeasonStatistics
     */
    playerStatistics?: Array<BasicPlayerStats>;
}
/**
 * 
 * @export
 * @interface TeamSocialDto
 */
export interface TeamSocialDto {
    /**
     * 
     * @type {string}
     * @memberof TeamSocialDto
     */
    web?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamSocialDto
     */
    twitterId?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamSocialDto
     */
    facebookId?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamSocialDto
     */
    instagramId?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamSocialDto
     */
    wikipediaId?: string;
}
/**
 * 
 * @export
 * @interface TeamStatistics
 */
export interface TeamStatistics {
    /**
     * Number of keys passes completed
     * @type {number}
     * @memberof TeamStatistics
     */
    pass?: number;
    /**
     * Percentage of time the team possess the ball
     * @type {number}
     * @memberof TeamStatistics
     */
    possession: number;
    /**
     * Number of goals scored
     * @type {number}
     * @memberof TeamStatistics
     */
    goals: number;
    /**
     * Number of corners
     * @type {number}
     * @memberof TeamStatistics
     */
    corners: number;
    /**
     * Number of crosses
     * @type {number}
     * @memberof TeamStatistics
     */
    crosses?: number;
    /**
     * Number of offsides
     * @type {number}
     * @memberof TeamStatistics
     */
    offside: number;
    /**
     * Shots on that have hit target
     * @type {number}
     * @memberof TeamStatistics
     */
    shotsOn: number;
    /**
     * Number of shots that have been blocked by an opposition player
     * @type {number}
     * @memberof TeamStatistics
     */
    shotsBlocked: number;
    /**
     * Shots outside the target
     * @type {number}
     * @memberof TeamStatistics
     */
    shotsOff: number;
    /**
     * Number of throw ins taken
     * @type {number}
     * @memberof TeamStatistics
     */
    throwIn?: number;
    /**
     * Number of goal kicks taken
     * @type {number}
     * @memberof TeamStatistics
     */
    goalKicks?: number;
    /**
     * Number of treatments to injuries
     * @type {number}
     * @memberof TeamStatistics
     */
    treatments?: number;
    /**
     * Total numer of yellow cards
     * @type {number}
     * @memberof TeamStatistics
     */
    yellowCards?: number;
    /**
     * Number of substitutions
     * @type {number}
     * @memberof TeamStatistics
     */
    substitutions?: number;
    /**
     * Number of counter attacks
     * @type {number}
     * @memberof TeamStatistics
     */
    counterAttacks?: number;
    /**
     * Total number of fouls committed by the Team
     * @type {number}
     * @memberof TeamStatistics
     */
    foulsCommitted: number;
}
/**
 * 
 * @export
 * @interface TopscorerStandingData
 */
export interface TopscorerStandingData extends StandingData {
    /**
     * 
     * @type {PartialPerson}
     * @memberof TopscorerStandingData
     */
    player: PartialPerson;
    /**
     * Number of goals scored
     * @type {number}
     * @memberof TopscorerStandingData
     */
    goals: number;
    /**
     * Total games played
     * @type {number}
     * @memberof TopscorerStandingData
     */
    played?: number;
    /**
     * Number of assists
     * @type {number}
     * @memberof TopscorerStandingData
     */
    assists?: number;
    /**
     * Total number of minutes played
     * @type {number}
     * @memberof TopscorerStandingData
     */
    minutes?: number;
    /**
     * Number of goals scored from the penalty spot
     * @type {number}
     * @memberof TopscorerStandingData
     */
    penalties?: number;
    /**
     * Number of red cards
     * @type {number}
     * @memberof TopscorerStandingData
     */
    redCards?: number;
    /**
     * Number of times the player scored first for the team
     * @type {number}
     * @memberof TopscorerStandingData
     */
    scoredFirst?: number;
    /**
     * Number of yellow cards
     * @type {number}
     * @memberof TopscorerStandingData
     */
    yellowCards?: number;
}
/**
 * Resource representing a Football Tournament such as A Grupa, Premier League, Champions League, World Cup, etc. Does not represent a specific season such as Premier League 2015/2016.
 * @export
 * @interface Tournament
 */
export interface Tournament {
    /**
     * Unique Resource identifier of the Tournament
     * @type {number}
     * @memberof Tournament
     */
    id: number;
    /**
     * Human readable name of the Tournament
     * @type {string}
     * @memberof Tournament
     */
    name: string;
    /**
     * 
     * @type {Country}
     * @memberof Tournament
     */
    country: Country;
    /**
     * Whether or not the Tournament is a regional league such as the La Liga, A PFG, EPL.
     * @type {boolean}
     * @memberof Tournament
     */
    regionalLeague?: boolean;
    /**
     * Represents the order position in a custom client based sorted list
     * @type {number}
     * @memberof Tournament
     */
    clientSortorder?: number;
    /**
     * 
     * @type {string}
     * @memberof Tournament
     */
    urlLogo?: string;
    /**
     * Shows if the tournament is Cup or a League
     * @type {string}
     * @memberof Tournament
     */
    type?: Tournament.TypeEnum;
    /**
     * Shows if the the teams in the tournament are Male or Female
     * @type {string}
     * @memberof Tournament
     */
    gender?: Tournament.GenderEnum;
    /**
     * Shows if the tournament is Regional or International
     * @type {string}
     * @memberof Tournament
     */
    region?: Tournament.RegionEnum;
}

/**
 * @export
 * @namespace Tournament
 */
export namespace Tournament {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CUP = <any> 'CUP',
        LEAGUE = <any> 'LEAGUE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        DOMESTIC = <any> 'DOMESTIC',
        INTERNATIONAL = <any> 'INTERNATIONAL'
    }
}
/**
 * Resource representing a Football Tournament such as A Grupa, Premier League, Champions League, World Cup, etc. Does not represent a specific season such as Premier League 2015/2016.
 * @export
 * @interface TournamentDto
 */
export interface TournamentDto {
    /**
     * 
     * @type {number}
     * @memberof TournamentDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof TournamentDto
     */
    name: string;
    /**
     * 
     * @type {V1CountryDto}
     * @memberof TournamentDto
     */
    country: V1CountryDto;
    /**
     * 
     * @type {boolean}
     * @memberof TournamentDto
     */
    regionalLeague?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TournamentDto
     */
    urlLogo?: string;
}
/**
 * 
 * @export
 * @interface TournamentItemDto
 */
export interface TournamentItemDto {
    /**
     * 
     * @type {string}
     * @memberof TournamentItemDto
     */
    tournamentId?: string;
    /**
     * 
     * @type {number}
     * @memberof TournamentItemDto
     */
    sortOrder?: number;
}
/**
 * 
 * @export
 * @interface TournamentSeason
 */
export interface TournamentSeason {
    /**
     * Unique identifier of the object
     * @type {number}
     * @memberof TournamentSeason
     */
    id: number;
    /**
     * Human readable name of the TournamentSeason
     * @type {string}
     * @memberof TournamentSeason
     */
    name: string;
    /**
     * Whether the season is currently running or whether it is finished
     * @type {boolean}
     * @memberof TournamentSeason
     */
    active: boolean;
}
/**
 * 
 * @export
 * @interface TournamentSeasonStage
 */
export interface TournamentSeasonStage {
    /**
     * Date when the first game of the stage is held
     * @type {string}
     * @memberof TournamentSeasonStage
     */
    startDate?: string;
    /**
     * Date when the final game of the stage is held
     * @type {string}
     * @memberof TournamentSeasonStage
     */
    endDate?: string;
    /**
     * Whether the stage is a qualification stage to a main Tournrament (Champions League Qualification)
     * @type {boolean}
     * @memberof TournamentSeasonStage
     */
    qualification?: boolean;
    /**
     * Whether the API has live scores for the stage
     * @type {boolean}
     * @memberof TournamentSeasonStage
     */
    live?: boolean;
    /**
     * Number of groups in the stage. Only available if the stage has groups (Champions League Group Stage)
     * @type {number}
     * @memberof TournamentSeasonStage
     */
    stageGroups?: number;
    /**
     * League standing data if available and if cup = false
     * @type {Array<LeagueStandingData>}
     * @memberof TournamentSeasonStage
     */
    standing?: Array<LeagueStandingData>;
    /**
     * List of rounds in the Stage if cup = true
     * @type {Array<Round>}
     * @memberof TournamentSeasonStage
     */
    rounds?: Array<Round>;
    /**
     * Unique identifier
     * @type {number}
     * @memberof TournamentSeasonStage
     */
    id: number;
    /**
     * Human readable name of the TournamentSeasonStage
     * @type {string}
     * @memberof TournamentSeasonStage
     */
    name: string;
    /**
     * Whether the stage is a cup such as Champions League Knockout stage, World Cup Final stages, etc
     * @type {boolean}
     * @memberof TournamentSeasonStage
     */
    cup: boolean;
    /**
     * Id of the TournamentSeason in which the stage is part of
     * @type {number}
     * @memberof TournamentSeasonStage
     */
    tournamentSeasonId: number;
    /**
     * Id of the Tournament in whicth the stage is part of
     * @type {number}
     * @memberof TournamentSeasonStage
     */
    tournamentId: number;
    /**
     * 
     * @type {Country}
     * @memberof TournamentSeasonStage
     */
    country: Country;
    /**
     * Indicates which confederation the stage is part of (for World Cup qualif.)
     * @type {string}
     * @memberof TournamentSeasonStage
     */
    confederation?: string;
}
/**
 * 
 * @export
 * @interface TournamentSeasonStageWithStandingGroups
 */
export interface TournamentSeasonStageWithStandingGroups extends TournamentSeasonStage {
    /**
     * List of StageGroup objects in the TournamentSeasonStage. Available if the property stage_groups exists
     * @type {Array<StageGroupWithStanding>}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    groups?: Array<StageGroupWithStanding>;
    /**
     * Unique identifier
     * @type {number}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    id?: number;
    /**
     * Human readable name of the TournamentSeasonStage
     * @type {string}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    name?: string;
    /**
     * Whether the stage is a cup such as Champions League Knockout stage, World Cup Final stages, etc
     * @type {boolean}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    cup?: boolean;
    /**
     * Id of the TournamentSeason in which the stage is part of
     * @type {number}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    tournamentSeasonId?: number;
    /**
     * Id of the Tournament in whicth the stage is part of
     * @type {number}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    tournamentId?: number;
    /**
     * 
     * @type {Country}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    country?: Country;
    /**
     * Indicates which confederation the stage is part of (for World Cup qualif.)
     * @type {string}
     * @memberof TournamentSeasonStageWithStandingGroups
     */
    confederation?: string;
}
/**
 * 
 * @export
 * @interface TournamentSeasonWithStages
 */
export interface TournamentSeasonWithStages extends TournamentSeasonWithTournament {
    /**
     * List of stages which take place during the TournamentSeason. If the parent Tournament has regional_league = true, this will usually be one stage with cup = false.
     * @type {Array<TournamentSeasonStage>}
     * @memberof TournamentSeasonWithStages
     */
    stages: Array<TournamentSeasonStage>;
}
/**
 * 
 * @export
 * @interface TournamentSeasonWithTournament
 */
export interface TournamentSeasonWithTournament extends TournamentSeason {
    /**
     * 
     * @type {Tournament}
     * @memberof TournamentSeasonWithTournament
     */
    tournament: Tournament;
}
/**
 * 
 * @export
 * @interface TournamentWithSeasons
 */
export interface TournamentWithSeasons extends Tournament {
    /**
     * List of seasons available for the Tournament
     * @type {Array<TournamentSeason>}
     * @memberof TournamentWithSeasons
     */
    seasons: Array<TournamentSeason>;
}

/**
 * @export
 * @namespace TournamentWithSeasons
 */
export namespace TournamentWithSeasons {
}
/**
 * 
 * @export
 * @interface TranslationContentDto
 */
export interface TranslationContentDto {
    /**
     * 
     * @type {string}
     * @memberof TranslationContentDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TranslationContentDto
     */
    threeLetterCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TranslationContentDto
     */
    shortName?: string;
}
/**
 * 
 * @export
 * @interface TranslationDto
 */
export interface TranslationDto {
    /**
     * 
     * @type {TranslationKeyDto}
     * @memberof TranslationDto
     */
    key?: TranslationKeyDto;
    /**
     * 
     * @type {TranslationContentDto}
     * @memberof TranslationDto
     */
    content?: TranslationContentDto;
}
/**
 * 
 * @export
 * @interface TranslationEntityDto
 */
export interface TranslationEntityDto {
    /**
     * 
     * @type {string}
     * @memberof TranslationEntityDto
     */
    entity?: TranslationEntityDto.EntityEnum;
}

/**
 * @export
 * @namespace TranslationEntityDto
 */
export namespace TranslationEntityDto {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityEnum {
        LINEUPPLAYERTYPE = <any> 'LINEUP_PLAYER_TYPE',
        COACH = <any> 'COACH',
        VENUE = <any> 'VENUE',
        TOURNAMENT = <any> 'TOURNAMENT',
        TEAM = <any> 'TEAM',
        COUNTRY = <any> 'COUNTRY',
        MATCHSTATUS = <any> 'MATCH_STATUS',
        STAGE = <any> 'STAGE',
        PLAYER = <any> 'PLAYER',
        REFEREE = <any> 'REFEREE',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STANDINGRULE = <any> 'STANDING_RULE',
        GROUP = <any> 'GROUP',
        SEASON = <any> 'SEASON',
        ROUNDTYPE = <any> 'ROUND_TYPE'
    }
}
/**
 * 
 * @export
 * @interface TranslationKeyDto
 */
export interface TranslationKeyDto {
    /**
     * 
     * @type {string}
     * @memberof TranslationKeyDto
     */
    entity?: TranslationKeyDto.EntityEnum;
    /**
     * 
     * @type {string}
     * @memberof TranslationKeyDto
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof TranslationKeyDto
     */
    language?: string;
}

/**
 * @export
 * @namespace TranslationKeyDto
 */
export namespace TranslationKeyDto {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityEnum {
        LINEUPPLAYERTYPE = <any> 'LINEUP_PLAYER_TYPE',
        COACH = <any> 'COACH',
        VENUE = <any> 'VENUE',
        TOURNAMENT = <any> 'TOURNAMENT',
        TEAM = <any> 'TEAM',
        COUNTRY = <any> 'COUNTRY',
        MATCHSTATUS = <any> 'MATCH_STATUS',
        STAGE = <any> 'STAGE',
        PLAYER = <any> 'PLAYER',
        REFEREE = <any> 'REFEREE',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STANDINGRULE = <any> 'STANDING_RULE',
        GROUP = <any> 'GROUP',
        SEASON = <any> 'SEASON',
        ROUNDTYPE = <any> 'ROUND_TYPE'
    }
}
/**
 * 
 * @export
 * @interface V1CountryDto
 */
export interface V1CountryDto {
    /**
     * 
     * @type {number}
     * @memberof V1CountryDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof V1CountryDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V1CountryDto
     */
    urlFlag?: string;
}
/**
 * 
 * @export
 * @interface V2ActiveClubsInput
 */
export interface V2ActiveClubsInput {
    /**
     * 
     * @type {Array<V2ActiveTeamInput>}
     * @memberof V2ActiveClubsInput
     */
    clubs?: Array<V2ActiveTeamInput>;
}
/**
 * 
 * @export
 * @interface V2ActiveTeamInput
 */
export interface V2ActiveTeamInput {
    /**
     * 
     * @type {string}
     * @memberof V2ActiveTeamInput
     */
    teamId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2ActiveTeamInput
     */
    contractType?: string;
    /**
     * 
     * @type {string}
     * @memberof V2ActiveTeamInput
     */
    startDate?: string;
    /**
     * 
     * @type {number}
     * @memberof V2ActiveTeamInput
     */
    shirtNumber?: number;
}
/**
 * 
 * @export
 * @interface V2Asset
 */
export interface V2Asset {
    /**
     * 
     * @type {string}
     * @memberof V2Asset
     */
    entity?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Asset
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Asset
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Asset
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Asset
     */
    contextType?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Asset
     */
    contextId?: string;
}
/**
 * 
 * @export
 * @interface V2AssetCollection
 */
export interface V2AssetCollection {
}
/**
 * 
 * @export
 * @interface V2AssetDeleteInput
 */
export interface V2AssetDeleteInput {
    /**
     * 
     * @type {string}
     * @memberof V2AssetDeleteInput
     */
    entity?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetDeleteInput
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetDeleteInput
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetDeleteInput
     */
    contextType?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetDeleteInput
     */
    contextId?: string;
}
/**
 * 
 * @export
 * @interface V2AssetInput
 */
export interface V2AssetInput {
    /**
     * 
     * @type {string}
     * @memberof V2AssetInput
     */
    entity?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetInput
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetInput
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetInput
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetInput
     */
    contextType?: string;
    /**
     * 
     * @type {string}
     * @memberof V2AssetInput
     */
    contextId?: string;
}
/**
 * 
 * @export
 * @interface V2City
 */
export interface V2City {
    /**
     * 
     * @type {string}
     * @memberof V2City
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2City
     */
    name?: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2City
     */
    country?: V2Country;
}
/**
 * 
 * @export
 * @interface V2Coach
 */
export interface V2Coach {
    /**
     * 
     * @type {string}
     * @memberof V2Coach
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Coach
     */
    name?: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2Coach
     */
    country?: V2Country;
    /**
     * 
     * @type {string}
     * @memberof V2Coach
     */
    birthdate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Coach
     */
    gender?: V2Coach.GenderEnum;
}

/**
 * @export
 * @namespace V2Coach
 */
export namespace V2Coach {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface V2Country
 */
export interface V2Country {
    /**
     * 
     * @type {string}
     * @memberof V2Country
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Country
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Country
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface V2Group
 */
export interface V2Group {
    /**
     * 
     * @type {string}
     * @memberof V2Group
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Group
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof V2Group
     */
    orderInStage?: number;
}
/**
 * 
 * @export
 * @interface V2KnockoutEdgeRound
 */
export interface V2KnockoutEdgeRound {
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutEdgeRound
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2KnockoutGroup
 */
export interface V2KnockoutGroup {
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutGroup
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof V2KnockoutGroup
     */
    order?: number;
    /**
     * 
     * @type {Array<V2KnockoutTeam>}
     * @memberof V2KnockoutGroup
     */
    teams?: Array<V2KnockoutTeam>;
    /**
     * 
     * @type {Array<V2KnockoutMatch>}
     * @memberof V2KnockoutGroup
     */
    matches?: Array<V2KnockoutMatch>;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutGroup
     */
    childObjectId?: string;
}
/**
 * 
 * @export
 * @interface V2KnockoutMatch
 */
export interface V2KnockoutMatch {
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutMatch
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof V2KnockoutMatch
     */
    kickoffTime?: Date;
    /**
     * 
     * @type {V2MatchScore}
     * @memberof V2KnockoutMatch
     */
    score?: V2MatchScore;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutMatch
     */
    homeTeamId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutMatch
     */
    awayTeamId?: string;
}
/**
 * 
 * @export
 * @interface V2KnockoutRound
 */
export interface V2KnockoutRound {
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutRound
     */
    name?: string;
    /**
     * 
     * @type {Array<V2KnockoutGroup>}
     * @memberof V2KnockoutRound
     */
    groups?: Array<V2KnockoutGroup>;
}
/**
 * 
 * @export
 * @interface V2KnockoutScheme
 */
export interface V2KnockoutScheme {
    /**
     * 
     * @type {V2KnockoutEdgeRound}
     * @memberof V2KnockoutScheme
     */
    startRound?: V2KnockoutEdgeRound;
    /**
     * 
     * @type {V2KnockoutEdgeRound}
     * @memberof V2KnockoutScheme
     */
    endRound?: V2KnockoutEdgeRound;
    /**
     * 
     * @type {boolean}
     * @memberof V2KnockoutScheme
     */
    smallFinal?: boolean;
    /**
     * 
     * @type {V2MatchStage}
     * @memberof V2KnockoutScheme
     */
    stage?: V2MatchStage;
    /**
     * 
     * @type {Array<V2KnockoutRound>}
     * @memberof V2KnockoutScheme
     */
    rounds?: Array<V2KnockoutRound>;
}
/**
 * 
 * @export
 * @interface V2KnockoutTeam
 */
export interface V2KnockoutTeam {
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutTeam
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutTeam
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutTeam
     */
    threeLetterCode?: string;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutTeam
     */
    gender?: string;
    /**
     * 
     * @type {string}
     * @memberof V2KnockoutTeam
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface V2LeagueEntryInput
 */
export interface V2LeagueEntryInput {
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof V2LeagueEntryInput
     */
    teamId?: string;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    played?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    wins?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    draws?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    losses?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    points?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    goalsFor?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LeagueEntryInput
     */
    goalsAgainst?: number;
}
/**
 * 
 * @export
 * @interface V2LeagueStandingInput
 */
export interface V2LeagueStandingInput {
    /**
     * 
     * @type {Array<V2LeagueEntryInput>}
     * @memberof V2LeagueStandingInput
     */
    entries?: Array<V2LeagueEntryInput>;
}
/**
 * 
 * @export
 * @interface V2Lineup
 */
export interface V2Lineup {
    /**
     * 
     * @type {string}
     * @memberof V2Lineup
     */
    matchId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Lineup
     */
    status?: V2Lineup.StatusEnum;
    /**
     * 
     * @type {V2LineupTeamDto}
     * @memberof V2Lineup
     */
    homeTeam?: V2LineupTeamDto;
    /**
     * 
     * @type {V2LineupTeamDto}
     * @memberof V2Lineup
     */
    awayTeam?: V2LineupTeamDto;
}

/**
 * @export
 * @namespace V2Lineup
 */
export namespace V2Lineup {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        CONFIRMED = <any> 'CONFIRMED',
        UNCONFIRMED = <any> 'UNCONFIRMED',
        NOTAVAILABLE = <any> 'NOT_AVAILABLE'
    }
}
/**
 * 
 * @export
 * @interface V2LineupInput
 */
export interface V2LineupInput {
    /**
     * 
     * @type {string}
     * @memberof V2LineupInput
     */
    status?: V2LineupInput.StatusEnum;
    /**
     * 
     * @type {V2LineupTeamInput}
     * @memberof V2LineupInput
     */
    homeTeam?: V2LineupTeamInput;
    /**
     * 
     * @type {V2LineupTeamInput}
     * @memberof V2LineupInput
     */
    awayTeam?: V2LineupTeamInput;
}

/**
 * @export
 * @namespace V2LineupInput
 */
export namespace V2LineupInput {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        CONFIRMED = <any> 'CONFIRMED',
        UNCONFIRMED = <any> 'UNCONFIRMED'
    }
}
/**
 * 
 * @export
 * @interface V2LineupPlayerDto
 */
export interface V2LineupPlayerDto {
    /**
     * 
     * @type {any}
     * @memberof V2LineupPlayerDto
     */
    type?: any;
    /**
     * 
     * @type {V2Player}
     * @memberof V2LineupPlayerDto
     */
    player?: V2Player;
    /**
     * 
     * @type {number}
     * @memberof V2LineupPlayerDto
     */
    positionX?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LineupPlayerDto
     */
    positionY?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LineupPlayerDto
     */
    shirtNumber?: number;
}
/**
 * 
 * @export
 * @interface V2LineupPlayerInput
 */
export interface V2LineupPlayerInput {
    /**
     * 
     * @type {string}
     * @memberof V2LineupPlayerInput
     */
    typeId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2LineupPlayerInput
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof V2LineupPlayerInput
     */
    positionX?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LineupPlayerInput
     */
    positionY?: number;
    /**
     * 
     * @type {number}
     * @memberof V2LineupPlayerInput
     */
    shirtNumber?: number;
}
/**
 * 
 * @export
 * @interface V2LineupTeamDto
 */
export interface V2LineupTeamDto {
    /**
     * 
     * @type {string}
     * @memberof V2LineupTeamDto
     */
    formation?: string;
    /**
     * 
     * @type {V2Coach}
     * @memberof V2LineupTeamDto
     */
    coach?: V2Coach;
    /**
     * 
     * @type {string}
     * @memberof V2LineupTeamDto
     */
    teamId?: string;
    /**
     * 
     * @type {Array<V2LineupPlayerDto>}
     * @memberof V2LineupTeamDto
     */
    players?: Array<V2LineupPlayerDto>;
}
/**
 * 
 * @export
 * @interface V2LineupTeamInput
 */
export interface V2LineupTeamInput {
    /**
     * 
     * @type {string}
     * @memberof V2LineupTeamInput
     */
    formation?: string;
    /**
     * 
     * @type {string}
     * @memberof V2LineupTeamInput
     */
    coachId?: string;
    /**
     * 
     * @type {Array<V2LineupPlayerInput>}
     * @memberof V2LineupTeamInput
     */
    players?: Array<V2LineupPlayerInput>;
}
/**
 * 
 * @export
 * @interface V2MappingDto
 */
export interface V2MappingDto {
    /**
     * 
     * @type {string}
     * @memberof V2MappingDto
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MappingDto
     */
    entityType?: V2MappingDto.EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MappingDto
     */
    domainId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MappingDto
     */
    providerId?: string;
}

/**
 * @export
 * @namespace V2MappingDto
 */
export namespace V2MappingDto {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        PLAYER = <any> 'PLAYER',
        TEAM = <any> 'TEAM',
        COACH = <any> 'COACH',
        MATCH = <any> 'MATCH',
        SEASON = <any> 'SEASON',
        VENUE = <any> 'VENUE',
        REFEREE = <any> 'REFEREE',
        TOURNAMENT = <any> 'TOURNAMENT',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STAGE = <any> 'STAGE',
        GROUP = <any> 'GROUP',
        COUNTRY = <any> 'COUNTRY',
        ODDPROVIDER = <any> 'ODD_PROVIDER'
    }
}
/**
 * 
 * @export
 * @interface V2MappingRequestDto
 */
export interface V2MappingRequestDto {
    /**
     * 
     * @type {string}
     * @memberof V2MappingRequestDto
     */
    entityType: V2MappingRequestDto.EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MappingRequestDto
     */
    providerId: string;
}

/**
 * @export
 * @namespace V2MappingRequestDto
 */
export namespace V2MappingRequestDto {
    /**
     * @export
     * @enum {string}
     */
    export enum EntityTypeEnum {
        PLAYER = <any> 'PLAYER',
        TEAM = <any> 'TEAM',
        COACH = <any> 'COACH',
        MATCH = <any> 'MATCH',
        SEASON = <any> 'SEASON',
        VENUE = <any> 'VENUE',
        REFEREE = <any> 'REFEREE',
        TOURNAMENT = <any> 'TOURNAMENT',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STAGE = <any> 'STAGE',
        GROUP = <any> 'GROUP',
        COUNTRY = <any> 'COUNTRY',
        ODDPROVIDER = <any> 'ODD_PROVIDER'
    }
}
/**
 * 
 * @export
 * @interface V2MappingRequestsDto
 */
export interface V2MappingRequestsDto {
    /**
     * 
     * @type {string}
     * @memberof V2MappingRequestsDto
     */
    provider?: string;
    /**
     * 
     * @type {Array<V2MappingRequestDto>}
     * @memberof V2MappingRequestsDto
     */
    mappingRequests: Array<V2MappingRequestDto>;
}
/**
 * 
 * @export
 * @interface V2MappingsDto
 */
export interface V2MappingsDto {
    /**
     * 
     * @type {Array<V2MappingDto>}
     * @memberof V2MappingsDto
     */
    mappings?: Array<V2MappingDto>;
}
/**
 * 
 * @export
 * @interface V2Match
 */
export interface V2Match {
    /**
     * 
     * @type {string}
     * @memberof V2Match
     */
    id?: string;
    /**
     * 
     * @type {V2MatchStatus}
     * @memberof V2Match
     */
    status?: V2MatchStatus;
    /**
     * 
     * @type {Date}
     * @memberof V2Match
     */
    kickoffTime?: Date;
    /**
     * 
     * @type {V2MatchStage}
     * @memberof V2Match
     */
    stage?: V2MatchStage;
    /**
     * 
     * @type {V2Season}
     * @memberof V2Match
     */
    season?: V2Season;
    /**
     * 
     * @type {V2Group}
     * @memberof V2Match
     */
    group?: V2Group;
    /**
     * 
     * @type {V2MatchRound}
     * @memberof V2Match
     */
    round?: V2MatchRound;
    /**
     * 
     * @type {V2MatchTeamDto}
     * @memberof V2Match
     */
    homeTeam?: V2MatchTeamDto;
    /**
     * 
     * @type {V2MatchTeamDto}
     * @memberof V2Match
     */
    awayTeam?: V2MatchTeamDto;
    /**
     * 
     * @type {Array<V2MatchReferee>}
     * @memberof V2Match
     */
    referees?: Array<V2MatchReferee>;
    /**
     * 
     * @type {V2MatchVenue}
     * @memberof V2Match
     */
    venue?: V2MatchVenue;
    /**
     * 
     * @type {number}
     * @memberof V2Match
     */
    spectators?: number;
    /**
     * 
     * @type {string}
     * @memberof V2Match
     */
    coverage?: V2Match.CoverageEnum;
    /**
     * 
     * @type {V2MatchMinute}
     * @memberof V2Match
     */
    minute?: V2MatchMinute;
    /**
     * 
     * @type {Date}
     * @memberof V2Match
     */
    phaseStartedAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V2Match
     */
    finishedAt?: Date;
    /**
     * 
     * @type {V2MatchScore}
     * @memberof V2Match
     */
    score?: V2MatchScore;
}

/**
 * @export
 * @namespace V2Match
 */
export namespace V2Match {
    /**
     * @export
     * @enum {string}
     */
    export enum CoverageEnum {
        LIVE = <any> 'LIVE',
        NOTLIVE = <any> 'NOT_LIVE',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface V2MatchEvent
 */
export interface V2MatchEvent {
    /**
     * 
     * @type {string}
     * @memberof V2MatchEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEvent
     */
    matchId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEvent
     */
    typeCode?: V2MatchEvent.TypeCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEvent
     */
    teamPosition?: V2MatchEvent.TeamPositionEnum;
    /**
     * 
     * @type {number}
     * @memberof V2MatchEvent
     */
    minute?: number;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEvent
     */
    teamId?: string;
    /**
     * 
     * @type {V2Player}
     * @memberof V2MatchEvent
     */
    primaryPlayer?: V2Player;
    /**
     * 
     * @type {V2Player}
     * @memberof V2MatchEvent
     */
    secondaryPlayer?: V2Player;
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchEvent
     */
    score?: V2TeamScore;
}

/**
 * @export
 * @namespace V2MatchEvent
 */
export namespace V2MatchEvent {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeCodeEnum {
        YELLOWREDCARD = <any> 'YELLOW_RED_CARD',
        PENALTYSHOOTOUTMISSED = <any> 'PENALTY_SHOOTOUT_MISSED',
        PENALTYSHOOTOUTSCORED = <any> 'PENALTY_SHOOTOUT_SCORED',
        SUBSTITUTION = <any> 'SUBSTITUTION',
        GOAL = <any> 'GOAL',
        REDCARD = <any> 'RED_CARD',
        PENALTYMISS = <any> 'PENALTY_MISS',
        YELLOWCARD = <any> 'YELLOW_CARD',
        ASSIST = <any> 'ASSIST',
        PENALTYGOAL = <any> 'PENALTY_GOAL',
        OWNGOAL = <any> 'OWN_GOAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TeamPositionEnum {
        HOME = <any> 'HOME',
        AWAY = <any> 'AWAY'
    }
}
/**
 * 
 * @export
 * @interface V2MatchEventInput
 */
export interface V2MatchEventInput {
    /**
     * 
     * @type {string}
     * @memberof V2MatchEventInput
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEventInput
     */
    typeCode?: V2MatchEventInput.TypeCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEventInput
     */
    teamPosition?: V2MatchEventInput.TeamPositionEnum;
    /**
     * 
     * @type {number}
     * @memberof V2MatchEventInput
     */
    minute?: number;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEventInput
     */
    primaryPlayerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchEventInput
     */
    secondaryPlayerId?: string;
    /**
     * Property is used to determine the order of events, if two or more events have the same minute
     * @type {number}
     * @memberof V2MatchEventInput
     */
    sortOrder?: number;
}

/**
 * @export
 * @namespace V2MatchEventInput
 */
export namespace V2MatchEventInput {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeCodeEnum {
        YELLOWREDCARD = <any> 'YELLOW_RED_CARD',
        PENALTYSHOOTOUTMISSED = <any> 'PENALTY_SHOOTOUT_MISSED',
        PENALTYSHOOTOUTSCORED = <any> 'PENALTY_SHOOTOUT_SCORED',
        SUBSTITUTION = <any> 'SUBSTITUTION',
        GOAL = <any> 'GOAL',
        REDCARD = <any> 'RED_CARD',
        PENALTYMISS = <any> 'PENALTY_MISS',
        YELLOWCARD = <any> 'YELLOW_CARD',
        ASSIST = <any> 'ASSIST',
        PENALTYGOAL = <any> 'PENALTY_GOAL',
        OWNGOAL = <any> 'OWN_GOAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TeamPositionEnum {
        HOME = <any> 'HOME',
        AWAY = <any> 'AWAY'
    }
}
/**
 * 
 * @export
 * @interface V2MatchEventInputWrapper
 */
export interface V2MatchEventInputWrapper {
    /**
     * 
     * @type {Array<V2MatchEventInput>}
     * @memberof V2MatchEventInputWrapper
     */
    events?: Array<V2MatchEventInput>;
}
/**
 * 
 * @export
 * @interface V2MatchEventProfile
 */
export interface V2MatchEventProfile {
    /**
     * 
     * @type {Array<V2MatchEvent>}
     * @memberof V2MatchEventProfile
     */
    events?: Array<V2MatchEvent>;
}
/**
 * 
 * @export
 * @interface V2MatchInput
 */
export interface V2MatchInput {
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    statusId?: string;
    /**
     * 
     * @type {Date}
     * @memberof V2MatchInput
     */
    kickoffTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    stageId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    homeTeamId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    awayTeamId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    roundKey?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    groupId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    venueId?: string;
    /**
     * 
     * @type {Array<V2MatchRefereeInput>}
     * @memberof V2MatchInput
     */
    referees?: Array<V2MatchRefereeInput>;
    /**
     * 
     * @type {V2MatchScoreInput}
     * @memberof V2MatchInput
     */
    score?: V2MatchScoreInput;
    /**
     * 
     * @type {number}
     * @memberof V2MatchInput
     */
    spectators?: number;
    /**
     * 
     * @type {string}
     * @memberof V2MatchInput
     */
    coverage?: V2MatchInput.CoverageEnum;
    /**
     * 
     * @type {Date}
     * @memberof V2MatchInput
     */
    finishedAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V2MatchInput
     */
    phaseStartedAt?: Date;
}

/**
 * @export
 * @namespace V2MatchInput
 */
export namespace V2MatchInput {
    /**
     * @export
     * @enum {string}
     */
    export enum CoverageEnum {
        LIVE = <any> 'LIVE',
        NOTLIVE = <any> 'NOT_LIVE',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface V2MatchMinute
 */
export interface V2MatchMinute {
    /**
     * 
     * @type {number}
     * @memberof V2MatchMinute
     */
    regularTime?: number;
    /**
     * 
     * @type {number}
     * @memberof V2MatchMinute
     */
    injuryTime?: number;
}
/**
 * 
 * @export
 * @interface V2MatchReferee
 */
export interface V2MatchReferee {
    /**
     * 
     * @type {string}
     * @memberof V2MatchReferee
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchReferee
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchReferee
     */
    role?: V2MatchReferee.RoleEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MatchReferee
     */
    gender?: V2MatchReferee.GenderEnum;
}

/**
 * @export
 * @namespace V2MatchReferee
 */
export namespace V2MatchReferee {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        REFEREE = <any> 'REFEREE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface V2MatchRefereeInput
 */
export interface V2MatchRefereeInput {
    /**
     * 
     * @type {string}
     * @memberof V2MatchRefereeInput
     */
    refereeId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchRefereeInput
     */
    role?: V2MatchRefereeInput.RoleEnum;
}

/**
 * @export
 * @namespace V2MatchRefereeInput
 */
export namespace V2MatchRefereeInput {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        REFEREE = <any> 'REFEREE'
    }
}
/**
 * 
 * @export
 * @interface V2MatchRound
 */
export interface V2MatchRound {
    /**
     * 
     * @type {string}
     * @memberof V2MatchRound
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchRound
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchRound
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface V2MatchScore
 */
export interface V2MatchScore {
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchScore
     */
    total?: V2TeamScore;
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchScore
     */
    halfTime?: V2TeamScore;
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchScore
     */
    regularTime?: V2TeamScore;
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchScore
     */
    extraTime?: V2TeamScore;
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchScore
     */
    penaltyShootout?: V2TeamScore;
    /**
     * 
     * @type {V2TeamScore}
     * @memberof V2MatchScore
     */
    aggregate?: V2TeamScore;
}
/**
 * 
 * @export
 * @interface V2MatchScoreInput
 */
export interface V2MatchScoreInput {
    /**
     * 
     * @type {V2TeamScoreInput}
     * @memberof V2MatchScoreInput
     */
    total?: V2TeamScoreInput;
    /**
     * 
     * @type {V2TeamScoreInput}
     * @memberof V2MatchScoreInput
     */
    halfTime?: V2TeamScoreInput;
    /**
     * 
     * @type {V2TeamScoreInput}
     * @memberof V2MatchScoreInput
     */
    regularTime?: V2TeamScoreInput;
    /**
     * 
     * @type {V2TeamScoreInput}
     * @memberof V2MatchScoreInput
     */
    extraTime?: V2TeamScoreInput;
    /**
     * 
     * @type {V2TeamScoreInput}
     * @memberof V2MatchScoreInput
     */
    penaltyShootout?: V2TeamScoreInput;
    /**
     * 
     * @type {V2TeamScoreInput}
     * @memberof V2MatchScoreInput
     */
    aggregate?: V2TeamScoreInput;
}
/**
 * 
 * @export
 * @interface V2MatchStage
 */
export interface V2MatchStage {
    /**
     * 
     * @type {string}
     * @memberof V2MatchStage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStage
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStage
     */
    type?: V2MatchStage.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStage
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStage
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof V2MatchStage
     */
    orderInSeason?: number;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStage
     */
    coverage?: string;
    /**
     * Available only for /v2/seasons/{id}/stages
     * @type {string}
     * @memberof V2MatchStage
     */
    status?: V2MatchStage.StatusEnum;
}

/**
 * @export
 * @namespace V2MatchStage
 */
export namespace V2MatchStage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GROUP = <any> 'GROUP',
        LEAGUE = <any> 'LEAGUE',
        KNOCKOUT = <any> 'KNOCK_OUT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
/**
 * 
 * @export
 * @interface V2MatchStatus
 */
export interface V2MatchStatus {
    /**
     * 
     * @type {string}
     * @memberof V2MatchStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStatus
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStatus
     */
    type?: V2MatchStatus.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MatchStatus
     */
    code?: string;
}

/**
 * @export
 * @namespace V2MatchStatus
 */
export namespace V2MatchStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        FINISHED = <any> 'FINISHED',
        NOTSTARTED = <any> 'NOT_STARTED',
        LIVE = <any> 'LIVE',
        INTERRUPTED = <any> 'INTERRUPTED',
        CANCELLED = <any> 'CANCELLED',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface V2MatchTeamDto
 */
export interface V2MatchTeamDto {
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    threeLetterCode?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    gender?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    type?: V2MatchTeamDto.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2MatchTeamDto
     */
    shirtColor?: string;
}

/**
 * @export
 * @namespace V2MatchTeamDto
 */
export namespace V2MatchTeamDto {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PLACEHOLDER = <any> 'PLACEHOLDER',
        NATIONAL = <any> 'NATIONAL',
        CLUB = <any> 'CLUB'
    }
}
/**
 * 
 * @export
 * @interface V2MatchVenue
 */
export interface V2MatchVenue {
    /**
     * 
     * @type {string}
     * @memberof V2MatchVenue
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2MatchVenue
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2Matches
 */
export interface V2Matches {
    /**
     * 
     * @type {Array<V2Match>}
     * @memberof V2Matches
     */
    matches?: Array<V2Match>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof V2Matches
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface V2MatchesLivescore
 */
export interface V2MatchesLivescore {
    /**
     * 
     * @type {Array<V2Match>}
     * @memberof V2MatchesLivescore
     */
    matches?: Array<V2Match>;
}
/**
 * 
 * @export
 * @interface V2Player
 */
export interface V2Player {
    /**
     * 
     * @type {string}
     * @memberof V2Player
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof V2Player
     */
    name: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2Player
     */
    country: V2Country;
    /**
     * 
     * @type {boolean}
     * @memberof V2Player
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V2Player
     */
    birthdate?: string;
    /**
     * 
     * @type {V2City}
     * @memberof V2Player
     */
    birthCity?: V2City;
    /**
     * 
     * @type {PlayerProfileDto}
     * @memberof V2Player
     */
    profile?: PlayerProfileDto;
    /**
     * 
     * @type {PlayerEditSocialDto}
     * @memberof V2Player
     */
    social?: PlayerEditSocialDto;
    /**
     * 
     * @type {string}
     * @memberof V2Player
     */
    position?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Player
     */
    gender?: V2Player.GenderEnum;
}

/**
 * @export
 * @namespace V2Player
 */
export namespace V2Player {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface V2PlayerActiveClub
 */
export interface V2PlayerActiveClub {
    /**
     * 
     * @type {V2Team}
     * @memberof V2PlayerActiveClub
     */
    team?: V2Team;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerActiveClub
     */
    contractType?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerActiveClub
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerActiveClub
     */
    shirtNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerActiveClub
     */
    status?: V2PlayerActiveClub.StatusEnum;
}

/**
 * @export
 * @namespace V2PlayerActiveClub
 */
export namespace V2PlayerActiveClub {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
/**
 * 
 * @export
 * @interface V2PlayerProfile
 */
export interface V2PlayerProfile {
    /**
     * 
     * @type {string}
     * @memberof V2PlayerProfile
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerProfile
     */
    name?: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2PlayerProfile
     */
    country?: V2Country;
    /**
     * 
     * @type {boolean}
     * @memberof V2PlayerProfile
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerProfile
     */
    birthdate?: string;
    /**
     * 
     * @type {V2City}
     * @memberof V2PlayerProfile
     */
    birthCity?: V2City;
    /**
     * 
     * @type {PlayerProfileDto}
     * @memberof V2PlayerProfile
     */
    profile?: PlayerProfileDto;
    /**
     * 
     * @type {PlayerEditSocialDto}
     * @memberof V2PlayerProfile
     */
    social?: PlayerEditSocialDto;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerProfile
     */
    position?: string;
    /**
     * 
     * @type {Array<V2PlayerActiveClub>}
     * @memberof V2PlayerProfile
     */
    teams?: Array<V2PlayerActiveClub>;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerProfile
     */
    gender?: V2PlayerProfile.GenderEnum;
}

/**
 * @export
 * @namespace V2PlayerProfile
 */
export namespace V2PlayerProfile {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface V2PlayerSeasonStatisticOutput
 */
export interface V2PlayerSeasonStatisticOutput {
    /**
     * 
     * @type {V2Player}
     * @memberof V2PlayerSeasonStatisticOutput
     */
    player?: V2Player;
    /**
     * 
     * @type {Array<V2Team>}
     * @memberof V2PlayerSeasonStatisticOutput
     */
    teams?: Array<V2Team>;
    /**
     * 
     * @type {V2Season}
     * @memberof V2PlayerSeasonStatisticOutput
     */
    season?: V2Season;
    /**
     * 
     * @type {Array<V2StatisticItem>}
     * @memberof V2PlayerSeasonStatisticOutput
     */
    statistics?: Array<V2StatisticItem>;
}
/**
 * 
 * @export
 * @interface V2PlayerSeasonStatisticOutputCollection
 */
export interface V2PlayerSeasonStatisticOutputCollection {
    /**
     * 
     * @type {Array<V2PlayerSeasonStatisticOutput>}
     * @memberof V2PlayerSeasonStatisticOutputCollection
     */
    statistics?: Array<V2PlayerSeasonStatisticOutput>;
}
/**
 * 
 * @export
 * @interface V2PlayerStatisticInput
 */
export interface V2PlayerStatisticInput {
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticInput
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticInput
     */
    matchId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticInput
     */
    teamId?: string;
    /**
     * 
     * @type {Array<PlayerStatisticItem>}
     * @memberof V2PlayerStatisticInput
     */
    statistics?: Array<PlayerStatisticItem>;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticInput
     */
    origin?: string;
}
/**
 * 
 * @export
 * @interface V2PlayerStatisticOutput
 */
export interface V2PlayerStatisticOutput {
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticOutput
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticOutput
     */
    matchId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticOutput
     */
    teamId?: string;
    /**
     * 
     * @type {any}
     * @memberof V2PlayerStatisticOutput
     */
    statistics?: any;
    /**
     * 
     * @type {string}
     * @memberof V2PlayerStatisticOutput
     */
    origin?: string;
}
/**
 * 
 * @export
 * @interface V2PostVenues
 */
export interface V2PostVenues {
    /**
     * 
     * @type {string}
     * @memberof V2PostVenues
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V2PostVenues
     */
    countryId: string;
    /**
     * 
     * @type {string}
     * @memberof V2PostVenues
     */
    cityId?: string;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof V2PostVenues
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface V2President
 */
export interface V2President {
    /**
     * 
     * @type {string}
     * @memberof V2President
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2President
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2PresidentInput
 */
export interface V2PresidentInput {
    /**
     * 
     * @type {string}
     * @memberof V2PresidentInput
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2PresidentUpdate
 */
export interface V2PresidentUpdate {
    /**
     * 
     * @type {string}
     * @memberof V2PresidentUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2PutVenues
 */
export interface V2PutVenues {
    /**
     * 
     * @type {string}
     * @memberof V2PutVenues
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2PutVenues
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V2PutVenues
     */
    countryId: string;
    /**
     * 
     * @type {string}
     * @memberof V2PutVenues
     */
    cityId?: string;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof V2PutVenues
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface V2RoundTypes
 */
export interface V2RoundTypes {
    /**
     * 
     * @type {Array<V2RoundWithStatus>}
     * @memberof V2RoundTypes
     */
    rounds?: Array<V2RoundWithStatus>;
}
/**
 * 
 * @export
 * @interface V2RoundWithStatus
 */
export interface V2RoundWithStatus {
    /**
     * 
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    endDate?: string;
    /**
     * Not available at endpoint /v2/rounds
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2RoundWithStatus
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface V2Season
 */
export interface V2Season {
    /**
     * 
     * @type {string}
     * @memberof V2Season
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Season
     */
    name?: string;
    /**
     * 
     * @type {V2Tournament}
     * @memberof V2Season
     */
    tournament?: V2Tournament;
    /**
     * 
     * @type {string}
     * @memberof V2Season
     */
    status?: V2Season.StatusEnum;
}

/**
 * @export
 * @namespace V2Season
 */
export namespace V2Season {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
/**
 * 
 * @export
 * @interface V2SeasonDetails
 */
export interface V2SeasonDetails {
    /**
     * 
     * @type {V2Season}
     * @memberof V2SeasonDetails
     */
    season?: V2Season;
    /**
     * 
     * @type {Array<V2StageDetails>}
     * @memberof V2SeasonDetails
     */
    stages?: Array<V2StageDetails>;
}
/**
 * 
 * @export
 * @interface V2SeasonList
 */
export interface V2SeasonList {
    /**
     * 
     * @type {Array<V2Season>}
     * @memberof V2SeasonList
     */
    seasons: Array<V2Season>;
}
/**
 * 
 * @export
 * @interface V2SeasonStage
 */
export interface V2SeasonStage {
    /**
     * 
     * @type {string}
     * @memberof V2SeasonStage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2SeasonStage
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2SeasonStage
     */
    type?: V2SeasonStage.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2SeasonStage
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2SeasonStage
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof V2SeasonStage
     */
    orderInSeason?: number;
    /**
     * 
     * @type {string}
     * @memberof V2SeasonStage
     */
    coverage?: string;
}

/**
 * @export
 * @namespace V2SeasonStage
 */
export namespace V2SeasonStage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GROUP = <any> 'GROUP',
        LEAGUE = <any> 'LEAGUE',
        KNOCKOUT = <any> 'KNOCK_OUT'
    }
}
/**
 * 
 * @export
 * @interface V2SeasonStageCollection
 */
export interface V2SeasonStageCollection {
    /**
     * 
     * @type {Array<V2MatchStage>}
     * @memberof V2SeasonStageCollection
     */
    stages?: Array<V2MatchStage>;
}
/**
 * 
 * @export
 * @interface V2SquadPlayer
 */
export interface V2SquadPlayer {
    /**
     * 
     * @type {V2Player}
     * @memberof V2SquadPlayer
     */
    player: V2Player;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayer
     */
    status: V2SquadPlayer.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayer
     */
    contractType?: V2SquadPlayer.ContractTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayer
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayer
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof V2SquadPlayer
     */
    shirtNumber?: number;
}

/**
 * @export
 * @namespace V2SquadPlayer
 */
export namespace V2SquadPlayer {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ContractTypeEnum {
        PERMANENT = <any> 'PERMANENT',
        LOAN = <any> 'LOAN',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface V2SquadPlayerInput
 */
export interface V2SquadPlayerInput {
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayerInput
     */
    playerId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayerInput
     */
    status?: V2SquadPlayerInput.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayerInput
     */
    contractType?: V2SquadPlayerInput.ContractTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayerInput
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof V2SquadPlayerInput
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof V2SquadPlayerInput
     */
    shirtNumber?: number;
}

/**
 * @export
 * @namespace V2SquadPlayerInput
 */
export namespace V2SquadPlayerInput {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ContractTypeEnum {
        PERMANENT = <any> 'PERMANENT',
        LOAN = <any> 'LOAN',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
/**
 * 
 * @export
 * @interface V2StageDetails
 */
export interface V2StageDetails {
    /**
     * 
     * @type {V2MatchStage}
     * @memberof V2StageDetails
     */
    stage?: V2MatchStage;
    /**
     * 
     * @type {Array<V2RoundWithStatus>}
     * @memberof V2StageDetails
     */
    rounds?: Array<V2RoundWithStatus>;
}
/**
 * 
 * @export
 * @interface V2StageGroup
 */
export interface V2StageGroup {
    /**
     * 
     * @type {string}
     * @memberof V2StageGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2StageGroup
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof V2StageGroup
     */
    orderInStage?: number;
}
/**
 * 
 * @export
 * @interface V2StageGroupCollection
 */
export interface V2StageGroupCollection {
    /**
     * 
     * @type {Array<V2Group>}
     * @memberof V2StageGroupCollection
     */
    groups?: Array<V2Group>;
}
/**
 * 
 * @export
 * @interface V2StageTeamInput
 */
export interface V2StageTeamInput {
    /**
     * 
     * @type {string}
     * @memberof V2StageTeamInput
     */
    teamId?: string;
}
/**
 * 
 * @export
 * @interface V2StandingEntryRuleInput
 */
export interface V2StandingEntryRuleInput {
    /**
     * 
     * @type {string}
     * @memberof V2StandingEntryRuleInput
     */
    standingRuleId?: string;
    /**
     * 
     * @type {number}
     * @memberof V2StandingEntryRuleInput
     */
    rank?: number;
}
/**
 * 
 * @export
 * @interface V2StandingEntryRuleWrapper
 */
export interface V2StandingEntryRuleWrapper {
    /**
     * 
     * @type {Array<V2StandingEntryRuleInput>}
     * @memberof V2StandingEntryRuleWrapper
     */
    rules?: Array<V2StandingEntryRuleInput>;
}
/**
 * 
 * @export
 * @interface V2StatisticItem
 */
export interface V2StatisticItem {
    /**
     * 
     * @type {string}
     * @memberof V2StatisticItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2StatisticItem
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface V2Team
 */
export interface V2Team {
    /**
     * 
     * @type {string}
     * @memberof V2Team
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof V2Team
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V2Team
     */
    threeLetterCode?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Team
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Team
     */
    type: V2Team.TypeEnum;
    /**
     * 
     * @type {V2Country}
     * @memberof V2Team
     */
    country: V2Country;
    /**
     * 
     * @type {V2VenuesGetId}
     * @memberof V2Team
     */
    venue?: V2VenuesGetId;
    /**
     * 
     * @type {TeamSocialDto}
     * @memberof V2Team
     */
    social?: TeamSocialDto;
    /**
     * 
     * @type {number}
     * @memberof V2Team
     */
    founded?: number;
    /**
     * 
     * @type {string}
     * @memberof V2Team
     */
    gender?: V2Team.GenderEnum;
}

/**
 * @export
 * @namespace V2Team
 */
export namespace V2Team {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PLACEHOLDER = <any> 'PLACEHOLDER',
        NATIONAL = <any> 'NATIONAL',
        CLUB = <any> 'CLUB'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface V2TeamColors
 */
export interface V2TeamColors {
    /**
     * 
     * @type {string}
     * @memberof V2TeamColors
     */
    entityType: string;
    /**
     * 
     * @type {string}
     * @memberof V2TeamColors
     */
    entityId: string;
    /**
     * 
     * @type {Array<V2TeamColorsColors>}
     * @memberof V2TeamColors
     */
    colors: Array<V2TeamColorsColors>;
}
/**
 * 
 * @export
 * @interface V2TeamColorsColors
 */
export interface V2TeamColorsColors {
    /**
     * 
     * @type {string}
     * @memberof V2TeamColorsColors
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TeamColorsColors
     */
    colorCode?: string;
}
/**
 * 
 * @export
 * @interface V2TeamProfile
 */
export interface V2TeamProfile {
    /**
     * 
     * @type {string}
     * @memberof V2TeamProfile
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TeamProfile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TeamProfile
     */
    threeLetterCode?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TeamProfile
     */
    shortName?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TeamProfile
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof V2TeamProfile
     */
    founded?: number;
    /**
     * 
     * @type {V2Country}
     * @memberof V2TeamProfile
     */
    country?: V2Country;
    /**
     * 
     * @type {V2VenuesGetId}
     * @memberof V2TeamProfile
     */
    venue?: V2VenuesGetId;
    /**
     * 
     * @type {TeamSocialDto}
     * @memberof V2TeamProfile
     */
    social?: TeamSocialDto;
    /**
     * 
     * @type {V2Coach}
     * @memberof V2TeamProfile
     */
    coach?: V2Coach;
    /**
     * 
     * @type {V2President}
     * @memberof V2TeamProfile
     */
    president?: V2President;
    /**
     * 
     * @type {string}
     * @memberof V2TeamProfile
     */
    gender?: V2TeamProfile.GenderEnum;
    /**
     * 
     * @type {Array<V2Season>}
     * @memberof V2TeamProfile
     */
    activeSeasons?: Array<V2Season>;
    /**
     * 
     * @type {Array<V2TeamColorsColors>}
     * @memberof V2TeamProfile
     */
    shirtColors?: Array<V2TeamColorsColors>;
}

/**
 * @export
 * @namespace V2TeamProfile
 */
export namespace V2TeamProfile {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
/**
 * 
 * @export
 * @interface V2TeamScore
 */
export interface V2TeamScore {
    /**
     * 
     * @type {number}
     * @memberof V2TeamScore
     */
    home?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TeamScore
     */
    away?: number;
}
/**
 * 
 * @export
 * @interface V2TeamScoreInput
 */
export interface V2TeamScoreInput {
    /**
     * 
     * @type {number}
     * @memberof V2TeamScoreInput
     */
    home?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TeamScoreInput
     */
    away?: number;
}
/**
 * 
 * @export
 * @interface V2TeamSquad
 */
export interface V2TeamSquad {
    /**
     * 
     * @type {V2Team}
     * @memberof V2TeamSquad
     */
    team: V2Team;
    /**
     * 
     * @type {Array<V2SquadPlayer>}
     * @memberof V2TeamSquad
     */
    players: Array<V2SquadPlayer>;
}
/**
 * 
 * @export
 * @interface V2TeamSquadInput
 */
export interface V2TeamSquadInput {
    /**
     * 
     * @type {Array<V2SquadPlayerInput>}
     * @memberof V2TeamSquadInput
     */
    players?: Array<V2SquadPlayerInput>;
}
/**
 * 
 * @export
 * @interface V2TopScorerEntryInput
 */
export interface V2TopScorerEntryInput {
    /**
     * 
     * @type {string}
     * @memberof V2TopScorerEntryInput
     */
    teamId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TopScorerEntryInput
     */
    playerId?: string;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    goals?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    played?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    assists?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    scoredFirst?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    minutes?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    penalties?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    yellowCards?: number;
    /**
     * 
     * @type {number}
     * @memberof V2TopScorerEntryInput
     */
    redCards?: number;
}
/**
 * 
 * @export
 * @interface V2TopScorerStandingInput
 */
export interface V2TopScorerStandingInput {
    /**
     * 
     * @type {Array<V2TopScorerEntryInput>}
     * @memberof V2TopScorerStandingInput
     */
    entries?: Array<V2TopScorerEntryInput>;
}
/**
 * 
 * @export
 * @interface V2Tournament
 */
export interface V2Tournament {
    /**
     * 
     * @type {string}
     * @memberof V2Tournament
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Tournament
     */
    name?: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2Tournament
     */
    country?: V2Country;
    /**
     * 
     * @type {string}
     * @memberof V2Tournament
     */
    gender?: V2Tournament.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof V2Tournament
     */
    type?: V2Tournament.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2Tournament
     */
    region?: V2Tournament.RegionEnum;
}

/**
 * @export
 * @namespace V2Tournament
 */
export namespace V2Tournament {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CUP = <any> 'CUP',
        LEAGUE = <any> 'LEAGUE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        DOMESTIC = <any> 'DOMESTIC',
        INTERNATIONAL = <any> 'INTERNATIONAL'
    }
}
/**
 * 
 * @export
 * @interface V2TournamentGroupCollection
 */
export interface V2TournamentGroupCollection {
    /**
     * 
     * @type {Array<Dto>}
     * @memberof V2TournamentGroupCollection
     */
    groups?: Array<Dto>;
}
/**
 * 
 * @export
 * @interface V2TournamentGroupGetOutput
 */
export interface V2TournamentGroupGetOutput {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupGetOutput
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupGetOutput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupGetOutput
     */
    description?: string;
    /**
     * 
     * @type {Array<V2TournamentItemOutput>}
     * @memberof V2TournamentGroupGetOutput
     */
    tournaments?: Array<V2TournamentItemOutput>;
}
/**
 * 
 * @export
 * @interface V2TournamentGroupInsertInput
 */
export interface V2TournamentGroupInsertInput {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupInsertInput
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupInsertInput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupInsertInput
     */
    description?: string;
    /**
     * 
     * @type {Array<TournamentItemDto>}
     * @memberof V2TournamentGroupInsertInput
     */
    tournaments?: Array<TournamentItemDto>;
}
/**
 * 
 * @export
 * @interface V2TournamentGroupSelection
 */
export interface V2TournamentGroupSelection {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupSelection
     */
    matchId?: string;
}
/**
 * 
 * @export
 * @interface V2TournamentGroupUpdateInput
 */
export interface V2TournamentGroupUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupUpdateInput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TournamentGroupUpdateInput
     */
    description?: string;
    /**
     * 
     * @type {Array<TournamentItemDto>}
     * @memberof V2TournamentGroupUpdateInput
     */
    tournaments?: Array<TournamentItemDto>;
}
/**
 * 
 * @export
 * @interface V2TournamentItemOutput
 */
export interface V2TournamentItemOutput {
    /**
     * 
     * @type {V2Tournament}
     * @memberof V2TournamentItemOutput
     */
    tournament?: V2Tournament;
    /**
     * 
     * @type {number}
     * @memberof V2TournamentItemOutput
     */
    sortOrder?: number;
}
/**
 * 
 * @export
 * @interface V2TournamentSeasonInsertInput
 */
export interface V2TournamentSeasonInsertInput {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentSeasonInsertInput
     */
    tournamentId?: string;
    /**
     * 
     * @type {string}
     * @memberof V2TournamentSeasonInsertInput
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2TournamentSeasonStatusInput
 */
export interface V2TournamentSeasonStatusInput {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentSeasonStatusInput
     */
    seasonId?: string;
}
/**
 * 
 * @export
 * @interface V2TournamentSeasonUpdateInput
 */
export interface V2TournamentSeasonUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof V2TournamentSeasonUpdateInput
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2Venues
 */
export interface V2Venues {
    /**
     * 
     * @type {string}
     * @memberof V2Venues
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2Venues
     */
    name: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2Venues
     */
    country: V2Country;
    /**
     * 
     * @type {V2City}
     * @memberof V2Venues
     */
    city?: V2City;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof V2Venues
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface V2VenuesGetId
 */
export interface V2VenuesGetId {
    /**
     * 
     * @type {string}
     * @memberof V2VenuesGetId
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2VenuesGetId
     */
    name?: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2VenuesGetId
     */
    country?: V2Country;
    /**
     * 
     * @type {V2City}
     * @memberof V2VenuesGetId
     */
    city?: V2City;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof V2VenuesGetId
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface V2VenuesList
 */
export interface V2VenuesList {
    /**
     * 
     * @type {Array<ListVenueDto>}
     * @memberof V2VenuesList
     */
    venues?: Array<ListVenueDto>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof V2VenuesList
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface V2VenuesPut
 */
export interface V2VenuesPut {
    /**
     * 
     * @type {string}
     * @memberof V2VenuesPut
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V2VenuesPut
     */
    name: string;
    /**
     * 
     * @type {V2Country}
     * @memberof V2VenuesPut
     */
    country: V2Country;
    /**
     * 
     * @type {V2City}
     * @memberof V2VenuesPut
     */
    city?: V2City;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof V2VenuesPut
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface Venue
 */
export interface Venue {
    /**
     * Unique identifier in the system
     * @type {number}
     * @memberof Venue
     */
    id: number;
    /**
     * Human readable name of the Venue
     * @type {string}
     * @memberof Venue
     */
    name: string;
    /**
     * 
     * @type {Country}
     * @memberof Venue
     */
    country?: Country;
    /**
     * 
     * @type {string}
     * @memberof Venue
     */
    city?: string;
    /**
     * 600x450 image of the Venue
     * @type {string}
     * @memberof Venue
     */
    urlImage?: string;
    /**
     * Total capacity of the stadium
     * @type {number}
     * @memberof Venue
     */
    capacity?: number;
    /**
     * Latitude coordinate of the stadium's location
     * @type {number}
     * @memberof Venue
     */
    lat?: number;
    /**
     * Longitude coordinate of the stadium's location
     * @type {number}
     * @memberof Venue
     */
    lng?: number;
}
/**
 * 
 * @export
 * @interface VenueDto
 */
export interface VenueDto {
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    name?: string;
    /**
     * 
     * @type {CountryDto}
     * @memberof VenueDto
     */
    country?: CountryDto;
    /**
     * 
     * @type {CityDto}
     * @memberof VenueDto
     */
    city?: CityDto;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof VenueDto
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface VenueEditDto
 */
export interface VenueEditDto {
    /**
     * 
     * @type {string}
     * @memberof VenueEditDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEditDto
     */
    countryId: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEditDto
     */
    cityId?: string;
    /**
     * 
     * @type {VenueProfileDto}
     * @memberof VenueEditDto
     */
    profile?: VenueProfileDto;
}
/**
 * 
 * @export
 * @interface VenuePageDto
 */
export interface VenuePageDto {
    /**
     * 
     * @type {Array<VenueDto>}
     * @memberof VenuePageDto
     */
    venues?: Array<VenueDto>;
    /**
     * 
     * @type {PageMetaDto}
     * @memberof VenuePageDto
     */
    pageMeta?: PageMetaDto;
}
/**
 * 
 * @export
 * @interface VenueProfileDto
 */
export interface VenueProfileDto {
    /**
     * 
     * @type {number}
     * @memberof VenueProfileDto
     */
    lat?: number;
    /**
     * 
     * @type {number}
     * @memberof VenueProfileDto
     */
    lng?: number;
    /**
     * 
     * @type {number}
     * @memberof VenueProfileDto
     */
    capacity?: number;
}
/**
 * AssetsApi - fetch parameter creator
 * @export
 */
export const AssetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk delete assets
         * @param {Array<V2AssetInput>} [body] Array of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsDelete(body?: Array<V2AssetInput>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2AssetInput&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk Upsert assets
         * @param {Array<V2AssetInput>} [body] Array of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsPost(body?: Array<V2AssetInput>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2AssetInput&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Bulk delete assets
         * @param {Array<V2AssetInput>} [body] Array of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsDelete(body?: Array<V2AssetInput>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).v2AssetsDelete(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk Upsert assets
         * @param {Array<V2AssetInput>} [body] Array of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsPost(body?: Array<V2AssetInput>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Asset> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).v2AssetsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Bulk delete assets
         * @param {Array<V2AssetInput>} [body] Array of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsDelete(body?: Array<V2AssetInput>, options?: any) {
            return AssetsApiFp(configuration).v2AssetsDelete(body, options)(fetch, basePath);
        },
        /**
         * Bulk Upsert assets
         * @param {Array<V2AssetInput>} [body] Array of assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2AssetsPost(body?: Array<V2AssetInput>, options?: any) {
            return AssetsApiFp(configuration).v2AssetsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Bulk delete assets
     * @param {Array<V2AssetInput>} [body] Array of assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public v2AssetsDelete(body?: Array<V2AssetInput>, options?: any) {
        return AssetsApiFp(this.configuration).v2AssetsDelete(body, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk Upsert assets
     * @param {Array<V2AssetInput>} [body] Array of assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public v2AssetsPost(body?: Array<V2AssetInput>, options?: any) {
        return AssetsApiFp(this.configuration).v2AssetsPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * BlacklistApi - fetch parameter creator
 * @export
 */
export const BlacklistApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove blacklist record by id.
         * @summary Remove the specified resource from storage.
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlacklistIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2BlacklistIdDelete.');
            }
            const localVarPath = `/v2/blacklist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk find in blacklist table and return matching entries by the unique blacklist key.
         * @param {Array<BlacklistKeyDto>} [body] Array of blacklistsKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlacklistSearchPost(body?: Array<BlacklistKeyDto>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/blacklist/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;BlacklistKeyDto&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlacklistApi - functional programming interface
 * @export
 */
export const BlacklistApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove blacklist record by id.
         * @summary Remove the specified resource from storage.
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlacklistIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BlacklistApiFetchParamCreator(configuration).v2BlacklistIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk find in blacklist table and return matching entries by the unique blacklist key.
         * @param {Array<BlacklistKeyDto>} [body] Array of blacklistsKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlacklistSearchPost(body?: Array<BlacklistKeyDto>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BlacklistDto>> {
            const localVarFetchArgs = BlacklistApiFetchParamCreator(configuration).v2BlacklistSearchPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlacklistApi - factory interface
 * @export
 */
export const BlacklistApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove blacklist record by id.
         * @summary Remove the specified resource from storage.
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlacklistIdDelete(id: string, options?: any) {
            return BlacklistApiFp(configuration).v2BlacklistIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Bulk find in blacklist table and return matching entries by the unique blacklist key.
         * @param {Array<BlacklistKeyDto>} [body] Array of blacklistsKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2BlacklistSearchPost(body?: Array<BlacklistKeyDto>, options?: any) {
            return BlacklistApiFp(configuration).v2BlacklistSearchPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * BlacklistApi - object-oriented interface
 * @export
 * @class BlacklistApi
 * @extends {BaseAPI}
 */
export class BlacklistApi extends BaseAPI {
    /**
     * Remove blacklist record by id.
     * @summary Remove the specified resource from storage.
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public v2BlacklistIdDelete(id: string, options?: any) {
        return BlacklistApiFp(this.configuration).v2BlacklistIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk find in blacklist table and return matching entries by the unique blacklist key.
     * @param {Array<BlacklistKeyDto>} [body] Array of blacklistsKeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public v2BlacklistSearchPost(body?: Array<BlacklistKeyDto>, options?: any) {
        return BlacklistApiFp(this.configuration).v2BlacklistSearchPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CitiesApi - fetch parameter creator
 * @export
 */
export const CitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update city information
         * @param {string} id Unique identifier of the resource.
         * @param {CityEditDto} [body] City information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CitiesIdPut(id: string, body?: CityEditDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2CitiesIdPut.');
            }
            const localVarPath = `/v2/cities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CityEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a newly created city in storage
         * @param {CityEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CitiesPost(body?: CityEditDto, options: any = {}): FetchArgs {
            const localVarPath = `/v2/cities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CityEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CitiesApi - functional programming interface
 * @export
 */
export const CitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update city information
         * @param {string} id Unique identifier of the resource.
         * @param {CityEditDto} [body] City information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CitiesIdPut(id: string, body?: CityEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CityDto> {
            const localVarFetchArgs = CitiesApiFetchParamCreator(configuration).v2CitiesIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store a newly created city in storage
         * @param {CityEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CitiesPost(body?: CityEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CityDto> {
            const localVarFetchArgs = CitiesApiFetchParamCreator(configuration).v2CitiesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CitiesApi - factory interface
 * @export
 */
export const CitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Update city information
         * @param {string} id Unique identifier of the resource.
         * @param {CityEditDto} [body] City information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CitiesIdPut(id: string, body?: CityEditDto, options?: any) {
            return CitiesApiFp(configuration).v2CitiesIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store a newly created city in storage
         * @param {CityEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CitiesPost(body?: CityEditDto, options?: any) {
            return CitiesApiFp(configuration).v2CitiesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CitiesApi - object-oriented interface
 * @export
 * @class CitiesApi
 * @extends {BaseAPI}
 */
export class CitiesApi extends BaseAPI {
    /**
     * Update city information
     * @param {string} id Unique identifier of the resource.
     * @param {CityEditDto} [body] City information to save in persistance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CitiesApi
     */
    public v2CitiesIdPut(id: string, body?: CityEditDto, options?: any) {
        return CitiesApiFp(this.configuration).v2CitiesIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store a newly created city in storage
     * @param {CityEditDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CitiesApi
     */
    public v2CitiesPost(body?: CityEditDto, options?: any) {
        return CitiesApiFp(this.configuration).v2CitiesPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CoachesApi - fetch parameter creator
 * @export
 */
export const CoachesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List coaches with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesGet(offset: number, limit: number, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling v2CoachesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v2CoachesGet.');
            }
            const localVarPath = `/v2/coaches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find coach by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesIdGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2CoachesIdGet.');
            }
            const localVarPath = `/v2/coaches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update coach information
         * @param {string} id Unique identifier of the resource.
         * @param {CoachEditDto} [body] Coach information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesIdPut(id: string, body?: CoachEditDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2CoachesIdPut.');
            }
            const localVarPath = `/v2/coaches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoachEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a newly created coach in storage
         * @param {CoachEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesPost(body?: CoachEditDto, options: any = {}): FetchArgs {
            const localVarPath = `/v2/coaches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CoachEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoachesApi - functional programming interface
 * @export
 */
export const CoachesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List coaches with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesGet(offset: number, limit: number, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoachPageDto> {
            const localVarFetchArgs = CoachesApiFetchParamCreator(configuration).v2CoachesGet(offset, limit, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Find coach by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesIdGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CoachDto>> {
            const localVarFetchArgs = CoachesApiFetchParamCreator(configuration).v2CoachesIdGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update coach information
         * @param {string} id Unique identifier of the resource.
         * @param {CoachEditDto} [body] Coach information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesIdPut(id: string, body?: CoachEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoachDto> {
            const localVarFetchArgs = CoachesApiFetchParamCreator(configuration).v2CoachesIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store a newly created coach in storage
         * @param {CoachEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesPost(body?: CoachEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CoachDto> {
            const localVarFetchArgs = CoachesApiFetchParamCreator(configuration).v2CoachesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CoachesApi - factory interface
 * @export
 */
export const CoachesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List coaches with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesGet(offset: number, limit: number, languageCode?: string, options?: any) {
            return CoachesApiFp(configuration).v2CoachesGet(offset, limit, languageCode, options)(fetch, basePath);
        },
        /**
         * Find coach by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesIdGet(id: string, languageCode?: string, options?: any) {
            return CoachesApiFp(configuration).v2CoachesIdGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Update coach information
         * @param {string} id Unique identifier of the resource.
         * @param {CoachEditDto} [body] Coach information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesIdPut(id: string, body?: CoachEditDto, options?: any) {
            return CoachesApiFp(configuration).v2CoachesIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store a newly created coach in storage
         * @param {CoachEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2CoachesPost(body?: CoachEditDto, options?: any) {
            return CoachesApiFp(configuration).v2CoachesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * CoachesApi - object-oriented interface
 * @export
 * @class CoachesApi
 * @extends {BaseAPI}
 */
export class CoachesApi extends BaseAPI {
    /**
     * List coaches with offset and limit parameters
     * @param {number} offset The number of items to skip before starting to collect the result set
     * @param {number} limit Limit the number of results returned
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoachesApi
     */
    public v2CoachesGet(offset: number, limit: number, languageCode?: string, options?: any) {
        return CoachesApiFp(this.configuration).v2CoachesGet(offset, limit, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Find coach by id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoachesApi
     */
    public v2CoachesIdGet(id: string, languageCode?: string, options?: any) {
        return CoachesApiFp(this.configuration).v2CoachesIdGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update coach information
     * @param {string} id Unique identifier of the resource.
     * @param {CoachEditDto} [body] Coach information to save in persistance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoachesApi
     */
    public v2CoachesIdPut(id: string, body?: CoachEditDto, options?: any) {
        return CoachesApiFp(this.configuration).v2CoachesIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store a newly created coach in storage
     * @param {CoachEditDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoachesApi
     */
    public v2CoachesPost(body?: CoachEditDto, options?: any) {
        return CoachesApiFp(this.configuration).v2CoachesPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CountriesApi - fetch parameter creator
 * @export
 */
export const CountriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of available Country resources
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGet(acceptLanguage?: string, options: any = {}): FetchArgs {
            const localVarPath = `/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of available Country resources
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGet(acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Country>> {
            const localVarFetchArgs = CountriesApiFetchParamCreator(configuration).countriesGet(acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of available Country resources
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesGet(acceptLanguage?: string, options?: any) {
            return CountriesApiFp(configuration).countriesGet(acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * Get a list of available Country resources
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesGet(acceptLanguage?: string, options?: any) {
        return CountriesApiFp(this.configuration).countriesGet(acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * EventIncidentsApi - fetch parameter creator
 * @export
 */
export const EventIncidentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIncidentsGet(acceptLanguage?: string, lastUpdate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/event_incidents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (lastUpdate !== undefined) {
                localVarQueryParameter['last_update'] = (lastUpdate as any).toISOString();
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventIncidentsApi - functional programming interface
 * @export
 */
export const EventIncidentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIncidentsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventIncident>> {
            const localVarFetchArgs = EventIncidentsApiFetchParamCreator(configuration).eventIncidentsGet(acceptLanguage, lastUpdate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventIncidentsApi - factory interface
 * @export
 */
export const EventIncidentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventIncidentsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
            return EventIncidentsApiFp(configuration).eventIncidentsGet(acceptLanguage, lastUpdate, options)(fetch, basePath);
        },
    };
};

/**
 * EventIncidentsApi - object-oriented interface
 * @export
 * @class EventIncidentsApi
 * @extends {BaseAPI}
 */
export class EventIncidentsApi extends BaseAPI {
    /**
     * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventIncidentsApi
     */
    public eventIncidentsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
        return EventIncidentsApiFp(this.configuration).eventIncidentsGet(acceptLanguage, lastUpdate, options)(this.fetch, this.basePath);
    }

}
/**
 * EventPlayerTypeApi - fetch parameter creator
 * @export
 */
export const EventPlayerTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of available EventPlayerType objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPlayerTypesGet(acceptLanguage?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event_player_types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventPlayerTypeApi - functional programming interface
 * @export
 */
export const EventPlayerTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of available EventPlayerType objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPlayerTypesGet(acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventPlayerType> {
            const localVarFetchArgs = EventPlayerTypeApiFetchParamCreator(configuration).eventPlayerTypesGet(acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventPlayerTypeApi - factory interface
 * @export
 */
export const EventPlayerTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of available EventPlayerType objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventPlayerTypesGet(acceptLanguage?: string, options?: any) {
            return EventPlayerTypeApiFp(configuration).eventPlayerTypesGet(acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * EventPlayerTypeApi - object-oriented interface
 * @export
 * @class EventPlayerTypeApi
 * @extends {BaseAPI}
 */
export class EventPlayerTypeApi extends BaseAPI {
    /**
     * Get a list of available EventPlayerType objects in the system
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventPlayerTypeApi
     */
    public eventPlayerTypesGet(acceptLanguage?: string, options?: any) {
        return EventPlayerTypeApiFp(this.configuration).eventPlayerTypesGet(acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * EventStatusApi - fetch parameter creator
 * @export
 */
export const EventStatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of available EventStatus objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventStatusGet(acceptLanguage?: string, options: any = {}): FetchArgs {
            const localVarPath = `/event_status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventStatusApi - functional programming interface
 * @export
 */
export const EventStatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of available EventStatus objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventStatusGet(acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventStatus> {
            const localVarFetchArgs = EventStatusApiFetchParamCreator(configuration).eventStatusGet(acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventStatusApi - factory interface
 * @export
 */
export const EventStatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of available EventStatus objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventStatusGet(acceptLanguage?: string, options?: any) {
            return EventStatusApiFp(configuration).eventStatusGet(acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * EventStatusApi - object-oriented interface
 * @export
 * @class EventStatusApi
 * @extends {BaseAPI}
 */
export class EventStatusApi extends BaseAPI {
    /**
     * Get a list of available EventStatus objects in the system
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventStatusApi
     */
    public eventStatusGet(acceptLanguage?: string, options?: any) {
        return EventStatusApiFp(this.configuration).eventStatusGet(acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of events by home and away team id
         * @param {number} homeId Filter events with home team id
         * @param {number} awayId Filter events with away team id
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsByTeamsGet(homeId: number, awayId: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'homeId' is not null or undefined
            if (homeId === null || homeId === undefined) {
                throw new RequiredError('homeId','Required parameter homeId was null or undefined when calling eventsByTeamsGet.');
            }
            // verify required parameter 'awayId' is not null or undefined
            if (awayId === null || awayId === undefined) {
                throw new RequiredError('awayId','Required parameter awayId was null or undefined when calling eventsByTeamsGet.');
            }
            const localVarPath = `/events/by_teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (homeId !== undefined) {
                localVarQueryParameter['home_id'] = homeId;
            }

            if (awayId !== undefined) {
                localVarQueryParameter['away_id'] = awayId;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Events
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
         * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
         * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
         * @param {string} [clientOrder] Order matching events for a specific client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(acceptLanguage?: string, fromTime?: Date, toTime?: Date, groupBy?: string, clientOrder?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fromTime !== undefined) {
                localVarQueryParameter['from_time'] = (fromTime as any).toISOString();
            }

            if (toTime !== undefined) {
                localVarQueryParameter['to_time'] = (toTime as any).toISOString();
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (clientOrder !== undefined) {
                localVarQueryParameter['client_order'] = clientOrder;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specifies additional information to include with the standing response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet(id: string, acceptLanguage?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdGet.');
            }
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventIncident objects
         * @param {string} [direction] Whether to sort the results by ascending or descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdIncidentsGet(id: string, acceptLanguage?: string, groupBy?: string, direction?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdIncidentsGet.');
            }
            const localVarPath = `/events/{id}/incidents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lineup information for an event. Includes players, formation and coach
         * @param {number} id Event.id for which lineups are requested
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdLineupsGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdLineupsGet.');
            }
            const localVarPath = `/events/{id}/lineups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventPlayer objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdPlayersGet.');
            }
            const localVarPath = `/events/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available pre-game odds for an Event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPregameoddsGet(id: string, xOddClient: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdPregameoddsGet.');
            }
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling eventsIdPregameoddsGet.');
            }
            const localVarPath = `/events/{id}/pregameodds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of events which are currently live
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsLiveGet(acceptLanguage?: string, groupBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/events/live`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of events which have been updated since the specified timestamp
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updated Events during the last hour
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsSinceGet(acceptLanguage?: string, lastUpdate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/events/since`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (lastUpdate !== undefined) {
                localVarQueryParameter['last_update'] = (lastUpdate as any).toISOString();
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of matches for team/between teams
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromStartTime] Return matches with start_time &gt;&#x3D; from_start_time. RFC 3339 format
         * @param {Date} [toStartTime] Return matches with start_time &lt;&#x3D; from_start_time. RFC 3339 format
         * @param {string} [teamIds] List for team IDs separated by commas. In case of one ID, it will return all matches for a selected team, in case of multiple - it will return matches between selected teams.
         * @param {string} [matchIds] List for match IDs separated by commas.
         * @param {string} [tournamentIds] List for tournament IDs separated by commas.
         * @param {string} [stageIds] List for stage IDs separated by commas.
         * @param {string} [rounds] List for rounds separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {string} [statusTypes] List of status types.
         * @param {number} [offset] Results offset
         * @param {number} [limit] Results limit
         * @param {string} [tournamentOrder] Tournament filtering and ordering.
         * @param {string} [refereeId] Filter matches by referee
         * @param {string} [venueId] Filter matches by venue
         * @param {string} [statusCode] Filter matches by event_status.code
         * @param {string} [sortDirection] Result ordering - asc/desc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchesGet(acceptLanguage?: string, fromStartTime?: Date, toStartTime?: Date, teamIds?: string, matchIds?: string, tournamentIds?: string, stageIds?: string, rounds?: string, seasonIds?: string, statusTypes?: string, offset?: number, limit?: number, tournamentOrder?: string, refereeId?: string, venueId?: string, statusCode?: string, sortDirection?: string, options: any = {}): FetchArgs {
            const localVarPath = `/matches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fromStartTime !== undefined) {
                localVarQueryParameter['from_start_time'] = (fromStartTime as any).toISOString();
            }

            if (toStartTime !== undefined) {
                localVarQueryParameter['to_start_time'] = (toStartTime as any).toISOString();
            }

            if (teamIds !== undefined) {
                localVarQueryParameter['team_ids'] = teamIds;
            }

            if (matchIds !== undefined) {
                localVarQueryParameter['match_ids'] = matchIds;
            }

            if (tournamentIds !== undefined) {
                localVarQueryParameter['tournament_ids'] = tournamentIds;
            }

            if (stageIds !== undefined) {
                localVarQueryParameter['stage_ids'] = stageIds;
            }

            if (rounds !== undefined) {
                localVarQueryParameter['rounds'] = rounds;
            }

            if (seasonIds !== undefined) {
                localVarQueryParameter['season_ids'] = seasonIds;
            }

            if (statusTypes !== undefined) {
                localVarQueryParameter['status_types'] = statusTypes;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tournamentOrder !== undefined) {
                localVarQueryParameter['tournament_order'] = tournamentOrder;
            }

            if (refereeId !== undefined) {
                localVarQueryParameter['referee_id'] = refereeId;
            }

            if (venueId !== undefined) {
                localVarQueryParameter['venue_id'] = venueId;
            }

            if (statusCode !== undefined) {
                localVarQueryParameter['status_code'] = statusCode;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of events which are fixtures in a given TournamentSeasonStage resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [round] Filter the event list by a specific round
         * @param {string} [sortDirection] Sort results by date in ascending or descending order
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdEventsGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of events by home and away team id
         * @param {number} homeId Filter events with home team id
         * @param {number} awayId Filter events with away team id
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsByTeamsGet(homeId: number, awayId: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsByTeamsGet(homeId, awayId, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Events
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
         * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
         * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
         * @param {string} [clientOrder] Order matching events for a specific client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(acceptLanguage?: string, fromTime?: Date, toTime?: Date, groupBy?: string, clientOrder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsGet(acceptLanguage, fromTime, toTime, groupBy, clientOrder, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specifies additional information to include with the standing response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsIdGet(id, acceptLanguage, expand, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventIncident objects
         * @param {string} [direction] Whether to sort the results by ascending or descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdIncidentsGet(id: string, acceptLanguage?: string, groupBy?: string, direction?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventIncident>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsIdIncidentsGet(id, acceptLanguage, groupBy, direction, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lineup information for an event. Includes players, formation and coach
         * @param {number} id Event.id for which lineups are requested
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdLineupsGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Lineup> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsIdLineupsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventPlayer objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventPlayer>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsIdPlayersGet(id, acceptLanguage, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get available pre-game odds for an Event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPregameoddsGet(id: string, xOddClient: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsIdPregameoddsGet(id, xOddClient, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of events which are currently live
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsLiveGet(acceptLanguage?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsLiveGet(acceptLanguage, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of events which have been updated since the specified timestamp
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updated Events during the last hour
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsSinceGet(acceptLanguage?: string, lastUpdate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).eventsSinceGet(acceptLanguage, lastUpdate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of matches for team/between teams
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromStartTime] Return matches with start_time &gt;&#x3D; from_start_time. RFC 3339 format
         * @param {Date} [toStartTime] Return matches with start_time &lt;&#x3D; from_start_time. RFC 3339 format
         * @param {string} [teamIds] List for team IDs separated by commas. In case of one ID, it will return all matches for a selected team, in case of multiple - it will return matches between selected teams.
         * @param {string} [matchIds] List for match IDs separated by commas.
         * @param {string} [tournamentIds] List for tournament IDs separated by commas.
         * @param {string} [stageIds] List for stage IDs separated by commas.
         * @param {string} [rounds] List for rounds separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {string} [statusTypes] List of status types.
         * @param {number} [offset] Results offset
         * @param {number} [limit] Results limit
         * @param {string} [tournamentOrder] Tournament filtering and ordering.
         * @param {string} [refereeId] Filter matches by referee
         * @param {string} [venueId] Filter matches by venue
         * @param {string} [statusCode] Filter matches by event_status.code
         * @param {string} [sortDirection] Result ordering - asc/desc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchesGet(acceptLanguage?: string, fromStartTime?: Date, toStartTime?: Date, teamIds?: string, matchIds?: string, tournamentIds?: string, stageIds?: string, rounds?: string, seasonIds?: string, statusTypes?: string, offset?: number, limit?: number, tournamentOrder?: string, refereeId?: string, venueId?: string, statusCode?: string, sortDirection?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).matchesGet(acceptLanguage, fromStartTime, toStartTime, teamIds, matchIds, tournamentIds, stageIds, rounds, seasonIds, statusTypes, offset, limit, tournamentOrder, refereeId, venueId, statusCode, sortDirection, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of events which are fixtures in a given TournamentSeasonStage resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [round] Filter the event list by a specific round
         * @param {string} [sortDirection] Sort results by date in ascending or descending order
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventsByDate>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdEventsGet(id, round, sortDirection, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of events by home and away team id
         * @param {number} homeId Filter events with home team id
         * @param {number} awayId Filter events with away team id
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsByTeamsGet(homeId: number, awayId: number, acceptLanguage?: string, options?: any) {
            return EventsApiFp(configuration).eventsByTeamsGet(homeId, awayId, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of Events
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
         * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
         * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
         * @param {string} [clientOrder] Order matching events for a specific client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(acceptLanguage?: string, fromTime?: Date, toTime?: Date, groupBy?: string, clientOrder?: string, options?: any) {
            return EventsApiFp(configuration).eventsGet(acceptLanguage, fromTime, toTime, groupBy, clientOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specifies additional information to include with the standing response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
            return EventsApiFp(configuration).eventsIdGet(id, acceptLanguage, expand, options)(fetch, basePath);
        },
        /**
         * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventIncident objects
         * @param {string} [direction] Whether to sort the results by ascending or descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdIncidentsGet(id: string, acceptLanguage?: string, groupBy?: string, direction?: string, options?: any) {
            return EventsApiFp(configuration).eventsIdIncidentsGet(id, acceptLanguage, groupBy, direction, options)(fetch, basePath);
        },
        /**
         * Get lineup information for an event. Includes players, formation and coach
         * @param {number} id Event.id for which lineups are requested
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdLineupsGet(id: number, acceptLanguage?: string, options?: any) {
            return EventsApiFp(configuration).eventsIdLineupsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventPlayer objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
            return EventsApiFp(configuration).eventsIdPlayersGet(id, acceptLanguage, groupBy, options)(fetch, basePath);
        },
        /**
         * Get available pre-game odds for an Event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPregameoddsGet(id: string, xOddClient: string, options?: any) {
            return EventsApiFp(configuration).eventsIdPregameoddsGet(id, xOddClient, options)(fetch, basePath);
        },
        /**
         * Get a list of events which are currently live
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsLiveGet(acceptLanguage?: string, groupBy?: string, options?: any) {
            return EventsApiFp(configuration).eventsLiveGet(acceptLanguage, groupBy, options)(fetch, basePath);
        },
        /**
         * Get a list of events which have been updated since the specified timestamp
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updated Events during the last hour
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsSinceGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
            return EventsApiFp(configuration).eventsSinceGet(acceptLanguage, lastUpdate, options)(fetch, basePath);
        },
        /**
         * Get a list of matches for team/between teams
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromStartTime] Return matches with start_time &gt;&#x3D; from_start_time. RFC 3339 format
         * @param {Date} [toStartTime] Return matches with start_time &lt;&#x3D; from_start_time. RFC 3339 format
         * @param {string} [teamIds] List for team IDs separated by commas. In case of one ID, it will return all matches for a selected team, in case of multiple - it will return matches between selected teams.
         * @param {string} [matchIds] List for match IDs separated by commas.
         * @param {string} [tournamentIds] List for tournament IDs separated by commas.
         * @param {string} [stageIds] List for stage IDs separated by commas.
         * @param {string} [rounds] List for rounds separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {string} [statusTypes] List of status types.
         * @param {number} [offset] Results offset
         * @param {number} [limit] Results limit
         * @param {string} [tournamentOrder] Tournament filtering and ordering.
         * @param {string} [refereeId] Filter matches by referee
         * @param {string} [venueId] Filter matches by venue
         * @param {string} [statusCode] Filter matches by event_status.code
         * @param {string} [sortDirection] Result ordering - asc/desc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchesGet(acceptLanguage?: string, fromStartTime?: Date, toStartTime?: Date, teamIds?: string, matchIds?: string, tournamentIds?: string, stageIds?: string, rounds?: string, seasonIds?: string, statusTypes?: string, offset?: number, limit?: number, tournamentOrder?: string, refereeId?: string, venueId?: string, statusCode?: string, sortDirection?: string, options?: any) {
            return EventsApiFp(configuration).matchesGet(acceptLanguage, fromStartTime, toStartTime, teamIds, matchIds, tournamentIds, stageIds, rounds, seasonIds, statusTypes, offset, limit, tournamentOrder, refereeId, venueId, statusCode, sortDirection, options)(fetch, basePath);
        },
        /**
         * Get a list of events which are fixtures in a given TournamentSeasonStage resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [round] Filter the event list by a specific round
         * @param {string} [sortDirection] Sort results by date in ascending or descending order
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options?: any) {
            return EventsApiFp(configuration).tournamentsSeasonsStagesIdEventsGet(id, round, sortDirection, acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Get a list of events by home and away team id
     * @param {number} homeId Filter events with home team id
     * @param {number} awayId Filter events with away team id
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsByTeamsGet(homeId: number, awayId: number, acceptLanguage?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsByTeamsGet(homeId, awayId, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Events
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
     * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
     * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
     * @param {string} [clientOrder] Order matching events for a specific client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsGet(acceptLanguage?: string, fromTime?: Date, toTime?: Date, groupBy?: string, clientOrder?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsGet(acceptLanguage, fromTime, toTime, groupBy, clientOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [expand] Specifies additional information to include with the standing response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsIdGet(id, acceptLanguage, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventIncident objects
     * @param {string} [direction] Whether to sort the results by ascending or descending order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdIncidentsGet(id: string, acceptLanguage?: string, groupBy?: string, direction?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsIdIncidentsGet(id, acceptLanguage, groupBy, direction, options)(this.fetch, this.basePath);
    }

    /**
     * Get lineup information for an event. Includes players, formation and coach
     * @param {number} id Event.id for which lineups are requested
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdLineupsGet(id: number, acceptLanguage?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsIdLineupsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Group results by a property. If &#x27;team&#x27; is used the json object has &#x27;home_team&#x27; and &#x27;away_team&#x27;, each containing an array of EventPlayer objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsIdPlayersGet(id, acceptLanguage, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get available pre-game odds for an Event
     * @param {string} id Unique identifier of the resource.
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdPregameoddsGet(id: string, xOddClient: string, options?: any) {
        return EventsApiFp(this.configuration).eventsIdPregameoddsGet(id, xOddClient, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of events which are currently live
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Group events by a specified property. Event models are returned as an &#x27;items&#x27; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsLiveGet(acceptLanguage?: string, groupBy?: string, options?: any) {
        return EventsApiFp(this.configuration).eventsLiveGet(acceptLanguage, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of events which have been updated since the specified timestamp
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updated Events during the last hour
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsSinceGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
        return EventsApiFp(this.configuration).eventsSinceGet(acceptLanguage, lastUpdate, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of matches for team/between teams
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [fromStartTime] Return matches with start_time &gt;&#x3D; from_start_time. RFC 3339 format
     * @param {Date} [toStartTime] Return matches with start_time &lt;&#x3D; from_start_time. RFC 3339 format
     * @param {string} [teamIds] List for team IDs separated by commas. In case of one ID, it will return all matches for a selected team, in case of multiple - it will return matches between selected teams.
     * @param {string} [matchIds] List for match IDs separated by commas.
     * @param {string} [tournamentIds] List for tournament IDs separated by commas.
     * @param {string} [stageIds] List for stage IDs separated by commas.
     * @param {string} [rounds] List for rounds separated by commas.
     * @param {string} [seasonIds] List for season IDs separated by commas.
     * @param {string} [statusTypes] List of status types.
     * @param {number} [offset] Results offset
     * @param {number} [limit] Results limit
     * @param {string} [tournamentOrder] Tournament filtering and ordering.
     * @param {string} [refereeId] Filter matches by referee
     * @param {string} [venueId] Filter matches by venue
     * @param {string} [statusCode] Filter matches by event_status.code
     * @param {string} [sortDirection] Result ordering - asc/desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public matchesGet(acceptLanguage?: string, fromStartTime?: Date, toStartTime?: Date, teamIds?: string, matchIds?: string, tournamentIds?: string, stageIds?: string, rounds?: string, seasonIds?: string, statusTypes?: string, offset?: number, limit?: number, tournamentOrder?: string, refereeId?: string, venueId?: string, statusCode?: string, sortDirection?: string, options?: any) {
        return EventsApiFp(this.configuration).matchesGet(acceptLanguage, fromStartTime, toStartTime, teamIds, matchIds, tournamentIds, stageIds, rounds, seasonIds, statusTypes, offset, limit, tournamentOrder, refereeId, venueId, statusCode, sortDirection, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of events which are fixtures in a given TournamentSeasonStage resource
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [round] Filter the event list by a specific round
     * @param {string} [sortDirection] Sort results by date in ascending or descending order
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options?: any) {
        return EventsApiFp(this.configuration).tournamentsSeasonsStagesIdEventsGet(id, round, sortDirection, acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * KnockoutSchemeApi - fetch parameter creator
 * @export
 */
export const KnockoutSchemeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} stageId Get knockout schemes for given stage id
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2KnockoutSchemesStageIdGet(stageId: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'stageId' is not null or undefined
            if (stageId === null || stageId === undefined) {
                throw new RequiredError('stageId','Required parameter stageId was null or undefined when calling v2KnockoutSchemesStageIdGet.');
            }
            const localVarPath = `/v2/knockout-schemes/{stage_id}`
                .replace(`{${"stage_id"}}`, encodeURIComponent(String(stageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnockoutSchemeApi - functional programming interface
 * @export
 */
export const KnockoutSchemeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} stageId Get knockout schemes for given stage id
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2KnockoutSchemesStageIdGet(stageId: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2KnockoutScheme>> {
            const localVarFetchArgs = KnockoutSchemeApiFetchParamCreator(configuration).v2KnockoutSchemesStageIdGet(stageId, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KnockoutSchemeApi - factory interface
 * @export
 */
export const KnockoutSchemeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} stageId Get knockout schemes for given stage id
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2KnockoutSchemesStageIdGet(stageId: string, languageCode?: string, options?: any) {
            return KnockoutSchemeApiFp(configuration).v2KnockoutSchemesStageIdGet(stageId, languageCode, options)(fetch, basePath);
        },
    };
};

/**
 * KnockoutSchemeApi - object-oriented interface
 * @export
 * @class KnockoutSchemeApi
 * @extends {BaseAPI}
 */
export class KnockoutSchemeApi extends BaseAPI {
    /**
     * 
     * @param {string} stageId Get knockout schemes for given stage id
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnockoutSchemeApi
     */
    public v2KnockoutSchemesStageIdGet(stageId: string, languageCode?: string, options?: any) {
        return KnockoutSchemeApiFp(this.configuration).v2KnockoutSchemesStageIdGet(stageId, languageCode, options)(this.fetch, this.basePath);
    }

}
/**
 * LanguagesApi - fetch parameter creator
 * @export
 */
export const LanguagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all possible languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2LanguagesGet(options: any = {}): FetchArgs {
            const localVarPath = `/v2/languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all possible languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2LanguagesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LanguageDto>> {
            const localVarFetchArgs = LanguagesApiFetchParamCreator(configuration).v2LanguagesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all possible languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2LanguagesGet(options?: any) {
            return LanguagesApiFp(configuration).v2LanguagesGet(options)(fetch, basePath);
        },
    };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * Get all possible languages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public v2LanguagesGet(options?: any) {
        return LanguagesApiFp(this.configuration).v2LanguagesGet(options)(this.fetch, this.basePath);
    }

}
/**
 * LineupsApi - fetch parameter creator
 * @export
 */
export const LineupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get lineup information. Includes players, formation and coach
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter lineups which have updates only after the specified time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineupsGet(acceptLanguage?: string, lastUpdate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/lineups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (lastUpdate !== undefined) {
                localVarQueryParameter['last_update'] = (lastUpdate as any).toISOString();
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lineups by match id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdLineupsGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2MatchesIdLineupsGet.');
            }
            const localVarPath = `/v2/matches/{id}/lineups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Lineup information
         * @param {V2LineupInput} body Lineup information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdLineupsPut(body: V2LineupInput, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2MatchesIdLineupsPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2MatchesIdLineupsPut.');
            }
            const localVarPath = `/v2/matches/{id}/lineups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2LineupInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LineupsApi - functional programming interface
 * @export
 */
export const LineupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get lineup information. Includes players, formation and coach
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter lineups which have updates only after the specified time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineupsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Lineup>> {
            const localVarFetchArgs = LineupsApiFetchParamCreator(configuration).lineupsGet(acceptLanguage, lastUpdate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lineups by match id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdLineupsGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Lineup> {
            const localVarFetchArgs = LineupsApiFetchParamCreator(configuration).v2MatchesIdLineupsGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Lineup information
         * @param {V2LineupInput} body Lineup information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdLineupsPut(body: V2LineupInput, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Lineup> {
            const localVarFetchArgs = LineupsApiFetchParamCreator(configuration).v2MatchesIdLineupsPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LineupsApi - factory interface
 * @export
 */
export const LineupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get lineup information. Includes players, formation and coach
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter lineups which have updates only after the specified time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineupsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
            return LineupsApiFp(configuration).lineupsGet(acceptLanguage, lastUpdate, options)(fetch, basePath);
        },
        /**
         * Get lineups by match id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdLineupsGet(id: string, languageCode?: string, options?: any) {
            return LineupsApiFp(configuration).v2MatchesIdLineupsGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Update Lineup information
         * @param {V2LineupInput} body Lineup information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdLineupsPut(body: V2LineupInput, id: string, options?: any) {
            return LineupsApiFp(configuration).v2MatchesIdLineupsPut(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * LineupsApi - object-oriented interface
 * @export
 * @class LineupsApi
 * @extends {BaseAPI}
 */
export class LineupsApi extends BaseAPI {
    /**
     * Get lineup information. Includes players, formation and coach
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [lastUpdate] Filter lineups which have updates only after the specified time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineupsApi
     */
    public lineupsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
        return LineupsApiFp(this.configuration).lineupsGet(acceptLanguage, lastUpdate, options)(this.fetch, this.basePath);
    }

    /**
     * Get lineups by match id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineupsApi
     */
    public v2MatchesIdLineupsGet(id: string, languageCode?: string, options?: any) {
        return LineupsApiFp(this.configuration).v2MatchesIdLineupsGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update Lineup information
     * @param {V2LineupInput} body Lineup information to save in persistance
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineupsApi
     */
    public v2MatchesIdLineupsPut(body: V2LineupInput, id: string, options?: any) {
        return LineupsApiFp(this.configuration).v2MatchesIdLineupsPut(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MappingsApi - fetch parameter creator
 * @export
 */
export const MappingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get FootballApi ID to Sportal ID maps for various types of objects
         * @param {string} [object] Filter ID maps by a specific object type
         * @param {number} [id] Return single Sportal ID for the specified FootballAPI &#x27;id&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappingsSportalGet(object?: string, id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/mappings/sportal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Sportal to Football API ID maps for various types of objects
         * @param {string} [object] Filter ID maps by a specific object type
         * @param {number} [id] Return single FotballApi ID for the specified Sportal &#x27;id&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappingsSportalReverseGet(object?: string, id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/mappings/sportal/reverse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MappingsApi - functional programming interface
 * @export
 */
export const MappingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get FootballApi ID to Sportal ID maps for various types of objects
         * @param {string} [object] Filter ID maps by a specific object type
         * @param {number} [id] Return single Sportal ID for the specified FootballAPI &#x27;id&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappingsSportalGet(object?: string, id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MappingsApiFetchParamCreator(configuration).mappingsSportalGet(object, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Sportal to Football API ID maps for various types of objects
         * @param {string} [object] Filter ID maps by a specific object type
         * @param {number} [id] Return single FotballApi ID for the specified Sportal &#x27;id&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappingsSportalReverseGet(object?: string, id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MappingsApiFetchParamCreator(configuration).mappingsSportalReverseGet(object, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MappingsApi - factory interface
 * @export
 */
export const MappingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get FootballApi ID to Sportal ID maps for various types of objects
         * @param {string} [object] Filter ID maps by a specific object type
         * @param {number} [id] Return single Sportal ID for the specified FootballAPI &#x27;id&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappingsSportalGet(object?: string, id?: number, options?: any) {
            return MappingsApiFp(configuration).mappingsSportalGet(object, id, options)(fetch, basePath);
        },
        /**
         * Get Sportal to Football API ID maps for various types of objects
         * @param {string} [object] Filter ID maps by a specific object type
         * @param {number} [id] Return single FotballApi ID for the specified Sportal &#x27;id&#x27;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappingsSportalReverseGet(object?: string, id?: number, options?: any) {
            return MappingsApiFp(configuration).mappingsSportalReverseGet(object, id, options)(fetch, basePath);
        },
    };
};

/**
 * MappingsApi - object-oriented interface
 * @export
 * @class MappingsApi
 * @extends {BaseAPI}
 */
export class MappingsApi extends BaseAPI {
    /**
     * Get FootballApi ID to Sportal ID maps for various types of objects
     * @param {string} [object] Filter ID maps by a specific object type
     * @param {number} [id] Return single Sportal ID for the specified FootballAPI &#x27;id&#x27;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MappingsApi
     */
    public mappingsSportalGet(object?: string, id?: number, options?: any) {
        return MappingsApiFp(this.configuration).mappingsSportalGet(object, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get Sportal to Football API ID maps for various types of objects
     * @param {string} [object] Filter ID maps by a specific object type
     * @param {number} [id] Return single FotballApi ID for the specified Sportal &#x27;id&#x27;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MappingsApi
     */
    public mappingsSportalReverseGet(object?: string, id?: number, options?: any) {
        return MappingsApiFp(this.configuration).mappingsSportalReverseGet(object, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MatchEventsApi - fetch parameter creator
 * @export
 */
export const MatchEventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get match events by match id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdEventsGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2MatchesIdEventsGet.');
            }
            const localVarPath = `/v2/matches/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces all match events with the given input
         * @param {V2MatchEventInputWrapper} body Match event information to save
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdEventsPut(body: V2MatchEventInputWrapper, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2MatchesIdEventsPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2MatchesIdEventsPut.');
            }
            const localVarPath = `/v2/matches/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2MatchEventInputWrapper" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchEventsApi - functional programming interface
 * @export
 */
export const MatchEventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get match events by match id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdEventsGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2MatchEventProfile> {
            const localVarFetchArgs = MatchEventsApiFetchParamCreator(configuration).v2MatchesIdEventsGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Replaces all match events with the given input
         * @param {V2MatchEventInputWrapper} body Match event information to save
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdEventsPut(body: V2MatchEventInputWrapper, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2MatchEventProfile> {
            const localVarFetchArgs = MatchEventsApiFetchParamCreator(configuration).v2MatchesIdEventsPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MatchEventsApi - factory interface
 * @export
 */
export const MatchEventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get match events by match id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdEventsGet(id: string, languageCode?: string, options?: any) {
            return MatchEventsApiFp(configuration).v2MatchesIdEventsGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Replaces all match events with the given input
         * @param {V2MatchEventInputWrapper} body Match event information to save
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdEventsPut(body: V2MatchEventInputWrapper, id: string, options?: any) {
            return MatchEventsApiFp(configuration).v2MatchesIdEventsPut(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * MatchEventsApi - object-oriented interface
 * @export
 * @class MatchEventsApi
 * @extends {BaseAPI}
 */
export class MatchEventsApi extends BaseAPI {
    /**
     * Get match events by match id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchEventsApi
     */
    public v2MatchesIdEventsGet(id: string, languageCode?: string, options?: any) {
        return MatchEventsApiFp(this.configuration).v2MatchesIdEventsGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Replaces all match events with the given input
     * @param {V2MatchEventInputWrapper} body Match event information to save
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchEventsApi
     */
    public v2MatchesIdEventsPut(body: V2MatchEventInputWrapper, id: string, options?: any) {
        return MatchEventsApiFp(this.configuration).v2MatchesIdEventsPut(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * MatchesApi - fetch parameter creator
 * @export
 */
export const MatchesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of live commentaries with specified match id and language
         * @param {string} id Unique identifier of the resource.
         * @param {string} languageCode Return translations depending on language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchesIdCommentaryGet(id: string, languageCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling matchesIdCommentaryGet.');
            }
            // verify required parameter 'languageCode' is not null or undefined
            if (languageCode === null || languageCode === undefined) {
                throw new RequiredError('languageCode','Required parameter languageCode was null or undefined when calling matchesIdCommentaryGet.');
            }
            const localVarPath = `/matches/{id}/commentary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of matches
         * @param {number} limit Select an upper limit for the matches that would be returned
         * @param {number} offset Select an offset for the matches that would be returned
         * @param {Array<number>} [tournamentIds] Filter matches, which have been played as part of the listed tournaments
         * @param {Array<number>} [seasonIds] Filter matches, which have been played as part of the listed tournament seasons
         * @param {Array<number>} [stageIds] Filter matches, which have been played as part of the listed tournament stages
         * @param {Array<number>} [groupIds] Filter matches, which have been played as part of the listed tournament groups
         * @param {Array<string>} [roundIds] Filter matches, which have been played as part of the listed tournament rounds
         * @param {Array<string>} [roundFilter] Filter matches by combinations of stage_id and round_id. Format: {stage_id}:{round_id}
         * @param {Date} [fromKickoffTime] Filter matches, which have a start_time after the specified date, format is ISO 8601
         * @param {Date} [toKickoffTime] Filter matches, which have a start_time before the specified date, format is ISO 8601
         * @param {Array<number>} [teamIds] Filter matches by teams which have taken part in them
         * @param {Array<string>} [statusTypes] Filter matches by their status types
         * @param {Array<string>} [statusCodes] Filter matches by their status codes
         * @param {number} [refereeId] Filter matches by the referee who has taken part in them
         * @param {string} [venueId] Filter matches by the venue that has hosted them
         * @param {string} [sortDirection] Sort matches in asc|desc order by start_time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesGet(limit: number, offset: number, tournamentIds?: Array<number>, seasonIds?: Array<number>, stageIds?: Array<number>, groupIds?: Array<number>, roundIds?: Array<string>, roundFilter?: Array<string>, fromKickoffTime?: Date, toKickoffTime?: Date, teamIds?: Array<number>, statusTypes?: Array<string>, statusCodes?: Array<string>, refereeId?: number, venueId?: string, sortDirection?: string, options: any = {}): FetchArgs {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v2MatchesGet.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling v2MatchesGet.');
            }
            const localVarPath = `/v2/matches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (tournamentIds) {
                localVarQueryParameter['tournament_ids'] = tournamentIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (seasonIds) {
                localVarQueryParameter['season_ids'] = seasonIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (stageIds) {
                localVarQueryParameter['stage_ids'] = stageIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (groupIds) {
                localVarQueryParameter['group_ids'] = groupIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (roundIds) {
                localVarQueryParameter['round_ids'] = roundIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (roundFilter) {
                localVarQueryParameter['round_filter'] = roundFilter.join(COLLECTION_FORMATS["csv"]);
            }

            if (fromKickoffTime !== undefined) {
                localVarQueryParameter['from_kickoff_time'] = (fromKickoffTime as any).toISOString();
            }

            if (toKickoffTime !== undefined) {
                localVarQueryParameter['to_kickoff_time'] = (toKickoffTime as any).toISOString();
            }

            if (teamIds) {
                localVarQueryParameter['team_ids'] = teamIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (statusTypes) {
                localVarQueryParameter['status_types'] = statusTypes.join(COLLECTION_FORMATS["csv"]);
            }

            if (statusCodes) {
                localVarQueryParameter['status_codes'] = statusCodes.join(COLLECTION_FORMATS["csv"]);
            }

            if (refereeId !== undefined) {
                localVarQueryParameter['referee_id'] = refereeId;
            }

            if (venueId !== undefined) {
                localVarQueryParameter['venue_id'] = venueId;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2MatchesIdGet.');
            }
            const localVarPath = `/v2/matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {V2MatchInput} body Match information to save
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdPut(body: V2MatchInput, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2MatchesIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2MatchesIdPut.');
            }
            const localVarPath = `/v2/matches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2MatchInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of matches
         * @param {Array<number>} [matchIds] Filter matches by their IDs
         * @param {string} [date] Filter matches by the date when they were played, format is ISO 8601
         * @param {number} [utcOffset] Filter matches by date and UTC offset, allowed value range: [-12,14]
         * @param {string} [tournamentGroup] Filter matches by a tournament group code
         * @param {Array<string>} [statusTypes] Filter matches by status types
         * @param {string} [selectionFilter] Fetch selected matches for specific date and tournament_group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesLivescoreGet(matchIds?: Array<number>, date?: string, utcOffset?: number, tournamentGroup?: string, statusTypes?: Array<string>, selectionFilter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/matches/livescore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (matchIds) {
                localVarQueryParameter['match_ids'] = matchIds.join(COLLECTION_FORMATS["csv"]);
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any).toISOString();
            }

            if (utcOffset !== undefined) {
                localVarQueryParameter['utc_offset'] = utcOffset;
            }

            if (tournamentGroup !== undefined) {
                localVarQueryParameter['tournament_group'] = tournamentGroup;
            }

            if (statusTypes) {
                localVarQueryParameter['status_types'] = statusTypes.join(COLLECTION_FORMATS["csv"]);
            }

            if (selectionFilter !== undefined) {
                localVarQueryParameter['selection_filter'] = selectionFilter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {V2MatchInput} body Match information to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesPost(body: V2MatchInput, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2MatchesPost.');
            }
            const localVarPath = `/v2/matches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2MatchInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchesApi - functional programming interface
 * @export
 */
export const MatchesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of live commentaries with specified match id and language
         * @param {string} id Unique identifier of the resource.
         * @param {string} languageCode Return translations depending on language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchesIdCommentaryGet(id: string, languageCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LiveCommentaryOutputDto>> {
            const localVarFetchArgs = MatchesApiFetchParamCreator(configuration).matchesIdCommentaryGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of matches
         * @param {number} limit Select an upper limit for the matches that would be returned
         * @param {number} offset Select an offset for the matches that would be returned
         * @param {Array<number>} [tournamentIds] Filter matches, which have been played as part of the listed tournaments
         * @param {Array<number>} [seasonIds] Filter matches, which have been played as part of the listed tournament seasons
         * @param {Array<number>} [stageIds] Filter matches, which have been played as part of the listed tournament stages
         * @param {Array<number>} [groupIds] Filter matches, which have been played as part of the listed tournament groups
         * @param {Array<string>} [roundIds] Filter matches, which have been played as part of the listed tournament rounds
         * @param {Array<string>} [roundFilter] Filter matches by combinations of stage_id and round_id. Format: {stage_id}:{round_id}
         * @param {Date} [fromKickoffTime] Filter matches, which have a start_time after the specified date, format is ISO 8601
         * @param {Date} [toKickoffTime] Filter matches, which have a start_time before the specified date, format is ISO 8601
         * @param {Array<number>} [teamIds] Filter matches by teams which have taken part in them
         * @param {Array<string>} [statusTypes] Filter matches by their status types
         * @param {Array<string>} [statusCodes] Filter matches by their status codes
         * @param {number} [refereeId] Filter matches by the referee who has taken part in them
         * @param {string} [venueId] Filter matches by the venue that has hosted them
         * @param {string} [sortDirection] Sort matches in asc|desc order by start_time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesGet(limit: number, offset: number, tournamentIds?: Array<number>, seasonIds?: Array<number>, stageIds?: Array<number>, groupIds?: Array<number>, roundIds?: Array<string>, roundFilter?: Array<string>, fromKickoffTime?: Date, toKickoffTime?: Date, teamIds?: Array<number>, statusTypes?: Array<string>, statusCodes?: Array<string>, refereeId?: number, venueId?: string, sortDirection?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2Match>> {
            const localVarFetchArgs = MatchesApiFetchParamCreator(configuration).v2MatchesGet(limit, offset, tournamentIds, seasonIds, stageIds, groupIds, roundIds, roundFilter, fromKickoffTime, toKickoffTime, teamIds, statusTypes, statusCodes, refereeId, venueId, sortDirection, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Match> {
            const localVarFetchArgs = MatchesApiFetchParamCreator(configuration).v2MatchesIdGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {V2MatchInput} body Match information to save
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdPut(body: V2MatchInput, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Match> {
            const localVarFetchArgs = MatchesApiFetchParamCreator(configuration).v2MatchesIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of matches
         * @param {Array<number>} [matchIds] Filter matches by their IDs
         * @param {string} [date] Filter matches by the date when they were played, format is ISO 8601
         * @param {number} [utcOffset] Filter matches by date and UTC offset, allowed value range: [-12,14]
         * @param {string} [tournamentGroup] Filter matches by a tournament group code
         * @param {Array<string>} [statusTypes] Filter matches by status types
         * @param {string} [selectionFilter] Fetch selected matches for specific date and tournament_group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesLivescoreGet(matchIds?: Array<number>, date?: string, utcOffset?: number, tournamentGroup?: string, statusTypes?: Array<string>, selectionFilter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2Match>> {
            const localVarFetchArgs = MatchesApiFetchParamCreator(configuration).v2MatchesLivescoreGet(matchIds, date, utcOffset, tournamentGroup, statusTypes, selectionFilter, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {V2MatchInput} body Match information to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesPost(body: V2MatchInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Match> {
            const localVarFetchArgs = MatchesApiFetchParamCreator(configuration).v2MatchesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MatchesApi - factory interface
 * @export
 */
export const MatchesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of live commentaries with specified match id and language
         * @param {string} id Unique identifier of the resource.
         * @param {string} languageCode Return translations depending on language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchesIdCommentaryGet(id: string, languageCode: string, options?: any) {
            return MatchesApiFp(configuration).matchesIdCommentaryGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Get a list of matches
         * @param {number} limit Select an upper limit for the matches that would be returned
         * @param {number} offset Select an offset for the matches that would be returned
         * @param {Array<number>} [tournamentIds] Filter matches, which have been played as part of the listed tournaments
         * @param {Array<number>} [seasonIds] Filter matches, which have been played as part of the listed tournament seasons
         * @param {Array<number>} [stageIds] Filter matches, which have been played as part of the listed tournament stages
         * @param {Array<number>} [groupIds] Filter matches, which have been played as part of the listed tournament groups
         * @param {Array<string>} [roundIds] Filter matches, which have been played as part of the listed tournament rounds
         * @param {Array<string>} [roundFilter] Filter matches by combinations of stage_id and round_id. Format: {stage_id}:{round_id}
         * @param {Date} [fromKickoffTime] Filter matches, which have a start_time after the specified date, format is ISO 8601
         * @param {Date} [toKickoffTime] Filter matches, which have a start_time before the specified date, format is ISO 8601
         * @param {Array<number>} [teamIds] Filter matches by teams which have taken part in them
         * @param {Array<string>} [statusTypes] Filter matches by their status types
         * @param {Array<string>} [statusCodes] Filter matches by their status codes
         * @param {number} [refereeId] Filter matches by the referee who has taken part in them
         * @param {string} [venueId] Filter matches by the venue that has hosted them
         * @param {string} [sortDirection] Sort matches in asc|desc order by start_time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesGet(limit: number, offset: number, tournamentIds?: Array<number>, seasonIds?: Array<number>, stageIds?: Array<number>, groupIds?: Array<number>, roundIds?: Array<string>, roundFilter?: Array<string>, fromKickoffTime?: Date, toKickoffTime?: Date, teamIds?: Array<number>, statusTypes?: Array<string>, statusCodes?: Array<string>, refereeId?: number, venueId?: string, sortDirection?: string, options?: any) {
            return MatchesApiFp(configuration).v2MatchesGet(limit, offset, tournamentIds, seasonIds, stageIds, groupIds, roundIds, roundFilter, fromKickoffTime, toKickoffTime, teamIds, statusTypes, statusCodes, refereeId, venueId, sortDirection, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdGet(id: string, languageCode?: string, options?: any) {
            return MatchesApiFp(configuration).v2MatchesIdGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * 
         * @param {V2MatchInput} body Match information to save
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesIdPut(body: V2MatchInput, id: string, options?: any) {
            return MatchesApiFp(configuration).v2MatchesIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Get a list of matches
         * @param {Array<number>} [matchIds] Filter matches by their IDs
         * @param {string} [date] Filter matches by the date when they were played, format is ISO 8601
         * @param {number} [utcOffset] Filter matches by date and UTC offset, allowed value range: [-12,14]
         * @param {string} [tournamentGroup] Filter matches by a tournament group code
         * @param {Array<string>} [statusTypes] Filter matches by status types
         * @param {string} [selectionFilter] Fetch selected matches for specific date and tournament_group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesLivescoreGet(matchIds?: Array<number>, date?: string, utcOffset?: number, tournamentGroup?: string, statusTypes?: Array<string>, selectionFilter?: string, options?: any) {
            return MatchesApiFp(configuration).v2MatchesLivescoreGet(matchIds, date, utcOffset, tournamentGroup, statusTypes, selectionFilter, options)(fetch, basePath);
        },
        /**
         * 
         * @param {V2MatchInput} body Match information to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MatchesPost(body: V2MatchInput, options?: any) {
            return MatchesApiFp(configuration).v2MatchesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * MatchesApi - object-oriented interface
 * @export
 * @class MatchesApi
 * @extends {BaseAPI}
 */
export class MatchesApi extends BaseAPI {
    /**
     * Get a list of live commentaries with specified match id and language
     * @param {string} id Unique identifier of the resource.
     * @param {string} languageCode Return translations depending on language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public matchesIdCommentaryGet(id: string, languageCode: string, options?: any) {
        return MatchesApiFp(this.configuration).matchesIdCommentaryGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of matches
     * @param {number} limit Select an upper limit for the matches that would be returned
     * @param {number} offset Select an offset for the matches that would be returned
     * @param {Array<number>} [tournamentIds] Filter matches, which have been played as part of the listed tournaments
     * @param {Array<number>} [seasonIds] Filter matches, which have been played as part of the listed tournament seasons
     * @param {Array<number>} [stageIds] Filter matches, which have been played as part of the listed tournament stages
     * @param {Array<number>} [groupIds] Filter matches, which have been played as part of the listed tournament groups
     * @param {Array<string>} [roundIds] Filter matches, which have been played as part of the listed tournament rounds
     * @param {Array<string>} [roundFilter] Filter matches by combinations of stage_id and round_id. Format: {stage_id}:{round_id}
     * @param {Date} [fromKickoffTime] Filter matches, which have a start_time after the specified date, format is ISO 8601
     * @param {Date} [toKickoffTime] Filter matches, which have a start_time before the specified date, format is ISO 8601
     * @param {Array<number>} [teamIds] Filter matches by teams which have taken part in them
     * @param {Array<string>} [statusTypes] Filter matches by their status types
     * @param {Array<string>} [statusCodes] Filter matches by their status codes
     * @param {number} [refereeId] Filter matches by the referee who has taken part in them
     * @param {string} [venueId] Filter matches by the venue that has hosted them
     * @param {string} [sortDirection] Sort matches in asc|desc order by start_time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public v2MatchesGet(limit: number, offset: number, tournamentIds?: Array<number>, seasonIds?: Array<number>, stageIds?: Array<number>, groupIds?: Array<number>, roundIds?: Array<string>, roundFilter?: Array<string>, fromKickoffTime?: Date, toKickoffTime?: Date, teamIds?: Array<number>, statusTypes?: Array<string>, statusCodes?: Array<string>, refereeId?: number, venueId?: string, sortDirection?: string, options?: any) {
        return MatchesApiFp(this.configuration).v2MatchesGet(limit, offset, tournamentIds, seasonIds, stageIds, groupIds, roundIds, roundFilter, fromKickoffTime, toKickoffTime, teamIds, statusTypes, statusCodes, refereeId, venueId, sortDirection, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public v2MatchesIdGet(id: string, languageCode?: string, options?: any) {
        return MatchesApiFp(this.configuration).v2MatchesIdGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {V2MatchInput} body Match information to save
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public v2MatchesIdPut(body: V2MatchInput, id: string, options?: any) {
        return MatchesApiFp(this.configuration).v2MatchesIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of matches
     * @param {Array<number>} [matchIds] Filter matches by their IDs
     * @param {string} [date] Filter matches by the date when they were played, format is ISO 8601
     * @param {number} [utcOffset] Filter matches by date and UTC offset, allowed value range: [-12,14]
     * @param {string} [tournamentGroup] Filter matches by a tournament group code
     * @param {Array<string>} [statusTypes] Filter matches by status types
     * @param {string} [selectionFilter] Fetch selected matches for specific date and tournament_group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public v2MatchesLivescoreGet(matchIds?: Array<number>, date?: string, utcOffset?: number, tournamentGroup?: string, statusTypes?: Array<string>, selectionFilter?: string, options?: any) {
        return MatchesApiFp(this.configuration).v2MatchesLivescoreGet(matchIds, date, utcOffset, tournamentGroup, statusTypes, selectionFilter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {V2MatchInput} body Match information to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public v2MatchesPost(body: V2MatchInput, options?: any) {
        return MatchesApiFp(this.configuration).v2MatchesPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * OddsApi - fetch parameter creator
 * @export
 */
export const OddsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get available liveodds for an event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdLiveoddsGet(id: string, xOddClient: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdLiveoddsGet.');
            }
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling eventsIdLiveoddsGet.');
            }
            const localVarPath = `/events/{id}/liveodds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of odds available in the system
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdOddsGet(id: string, xOddClient: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdOddsGet.');
            }
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling eventsIdOddsGet.');
            }
            const localVarPath = `/events/{id}/odds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available pre-game odds for an Event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPregameoddsGet(id: string, xOddClient: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdPregameoddsGet.');
            }
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling eventsIdPregameoddsGet.');
            }
            const localVarPath = `/events/{id}/pregameodds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of liveodds available in the system
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveoddsGet(xOddClient: string, options: any = {}): FetchArgs {
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling liveoddsGet.');
            }
            const localVarPath = `/liveodds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of OddProviders available in the system. If X-Odd-Client is specified they will be filtered and ordered by the client configuration.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oddProvidersGet(xOddClient: string, options: any = {}): FetchArgs {
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling oddProvidersGet.');
            }
            const localVarPath = `/odd_providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Odds
         * @param {string} oddClient Odd client code
         * @param {string} sportType Sport type filter
         * @param {string} eventType Event type filter
         * @param {Date} [fromEventStartTime] Return odds for Events with start_time &gt;&#x3D; from_event_start_time. RFC 3339 format
         * @param {Date} [toEventStartTime] Return odds for Events with start_time &lt;&#x3D; to_event_start_time. RFC 3339 format
         * @param {number} [teamId] Team ID
         * @param {string} [teamIds] List for team IDs separated by commas.
         * @param {string} [eventOrder] Order matching events for a specific client
         * @param {string} [matchIds] List for match IDs separated by commas.
         * @param {string} [tournamentIds] List for tournament IDs separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {string} [oddsType] Pregame or live odds selector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oddsGet(oddClient: string, sportType: string, eventType: string, fromEventStartTime?: Date, toEventStartTime?: Date, teamId?: number, teamIds?: string, eventOrder?: string, matchIds?: string, tournamentIds?: string, seasonIds?: string, oddsType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'oddClient' is not null or undefined
            if (oddClient === null || oddClient === undefined) {
                throw new RequiredError('oddClient','Required parameter oddClient was null or undefined when calling oddsGet.');
            }
            // verify required parameter 'sportType' is not null or undefined
            if (sportType === null || sportType === undefined) {
                throw new RequiredError('sportType','Required parameter sportType was null or undefined when calling oddsGet.');
            }
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling oddsGet.');
            }
            const localVarPath = `/odds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fromEventStartTime !== undefined) {
                localVarQueryParameter['from_event_start_time'] = (fromEventStartTime as any).toISOString();
            }

            if (toEventStartTime !== undefined) {
                localVarQueryParameter['to_event_start_time'] = (toEventStartTime as any).toISOString();
            }

            if (oddClient !== undefined) {
                localVarQueryParameter['odd_client'] = oddClient;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (teamIds !== undefined) {
                localVarQueryParameter['team_ids'] = teamIds;
            }

            if (eventOrder !== undefined) {
                localVarQueryParameter['event_order'] = eventOrder;
            }

            if (sportType !== undefined) {
                localVarQueryParameter['sport_type'] = sportType;
            }

            if (matchIds !== undefined) {
                localVarQueryParameter['match_ids'] = matchIds;
            }

            if (tournamentIds !== undefined) {
                localVarQueryParameter['tournament_ids'] = tournamentIds;
            }

            if (seasonIds !== undefined) {
                localVarQueryParameter['season_ids'] = seasonIds;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['event_type'] = eventType;
            }

            if (oddsType !== undefined) {
                localVarQueryParameter['odds_type'] = oddsType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Odd Providers which have odds available for a given Event
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {Date} [fromTime] Return odds for Events with start_time &gt;&#x3D; from_time. RFC 3339 format
         * @param {Date} [toTime] Return odds for Events with start_time &lt;&#x3D; to_time. RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pregameoddsGet(xOddClient: string, fromTime?: Date, toTime?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'xOddClient' is not null or undefined
            if (xOddClient === null || xOddClient === undefined) {
                throw new RequiredError('xOddClient','Required parameter xOddClient was null or undefined when calling pregameoddsGet.');
            }
            const localVarPath = `/pregameodds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fromTime !== undefined) {
                localVarQueryParameter['from_time'] = (fromTime as any).toISOString();
            }

            if (toTime !== undefined) {
                localVarQueryParameter['to_time'] = (toTime as any).toISOString();
            }

            if (xOddClient !== undefined && xOddClient !== null) {
                localVarHeaderParameter['X-Odd-Client'] = String(xOddClient);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OddsApi - functional programming interface
 * @export
 */
export const OddsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get available liveodds for an event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdLiveoddsGet(id: string, xOddClient: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).eventsIdLiveoddsGet(id, xOddClient, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of odds available in the system
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdOddsGet(id: string, xOddClient: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).eventsIdOddsGet(id, xOddClient, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get available pre-game odds for an Event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPregameoddsGet(id: string, xOddClient: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).eventsIdPregameoddsGet(id, xOddClient, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of liveodds available in the system
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveoddsGet(xOddClient: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).liveoddsGet(xOddClient, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return a list of OddProviders available in the system. If X-Odd-Client is specified they will be filtered and ordered by the client configuration.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oddProvidersGet(xOddClient: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OddProvider>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).oddProvidersGet(xOddClient, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Odds
         * @param {string} oddClient Odd client code
         * @param {string} sportType Sport type filter
         * @param {string} eventType Event type filter
         * @param {Date} [fromEventStartTime] Return odds for Events with start_time &gt;&#x3D; from_event_start_time. RFC 3339 format
         * @param {Date} [toEventStartTime] Return odds for Events with start_time &lt;&#x3D; to_event_start_time. RFC 3339 format
         * @param {number} [teamId] Team ID
         * @param {string} [teamIds] List for team IDs separated by commas.
         * @param {string} [eventOrder] Order matching events for a specific client
         * @param {string} [matchIds] List for match IDs separated by commas.
         * @param {string} [tournamentIds] List for tournament IDs separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {string} [oddsType] Pregame or live odds selector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oddsGet(oddClient: string, sportType: string, eventType: string, fromEventStartTime?: Date, toEventStartTime?: Date, teamId?: number, teamIds?: string, eventOrder?: string, matchIds?: string, tournamentIds?: string, seasonIds?: string, oddsType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).oddsGet(oddClient, sportType, eventType, fromEventStartTime, toEventStartTime, teamId, teamIds, eventOrder, matchIds, tournamentIds, seasonIds, oddsType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Odd Providers which have odds available for a given Event
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {Date} [fromTime] Return odds for Events with start_time &gt;&#x3D; from_time. RFC 3339 format
         * @param {Date} [toTime] Return odds for Events with start_time &lt;&#x3D; to_time. RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pregameoddsGet(xOddClient: string, fromTime?: Date, toTime?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Odd>> {
            const localVarFetchArgs = OddsApiFetchParamCreator(configuration).pregameoddsGet(xOddClient, fromTime, toTime, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OddsApi - factory interface
 * @export
 */
export const OddsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get available liveodds for an event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdLiveoddsGet(id: string, xOddClient: string, options?: any) {
            return OddsApiFp(configuration).eventsIdLiveoddsGet(id, xOddClient, options)(fetch, basePath);
        },
        /**
         * Get a list of odds available in the system
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdOddsGet(id: string, xOddClient: string, options?: any) {
            return OddsApiFp(configuration).eventsIdOddsGet(id, xOddClient, options)(fetch, basePath);
        },
        /**
         * Get available pre-game odds for an Event
         * @param {string} id Unique identifier of the resource.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPregameoddsGet(id: string, xOddClient: string, options?: any) {
            return OddsApiFp(configuration).eventsIdPregameoddsGet(id, xOddClient, options)(fetch, basePath);
        },
        /**
         * Get a list of liveodds available in the system
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveoddsGet(xOddClient: string, options?: any) {
            return OddsApiFp(configuration).liveoddsGet(xOddClient, options)(fetch, basePath);
        },
        /**
         * Return a list of OddProviders available in the system. If X-Odd-Client is specified they will be filtered and ordered by the client configuration.
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oddProvidersGet(xOddClient: string, options?: any) {
            return OddsApiFp(configuration).oddProvidersGet(xOddClient, options)(fetch, basePath);
        },
        /**
         * Returns a list of Odds
         * @param {string} oddClient Odd client code
         * @param {string} sportType Sport type filter
         * @param {string} eventType Event type filter
         * @param {Date} [fromEventStartTime] Return odds for Events with start_time &gt;&#x3D; from_event_start_time. RFC 3339 format
         * @param {Date} [toEventStartTime] Return odds for Events with start_time &lt;&#x3D; to_event_start_time. RFC 3339 format
         * @param {number} [teamId] Team ID
         * @param {string} [teamIds] List for team IDs separated by commas.
         * @param {string} [eventOrder] Order matching events for a specific client
         * @param {string} [matchIds] List for match IDs separated by commas.
         * @param {string} [tournamentIds] List for tournament IDs separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {string} [oddsType] Pregame or live odds selector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oddsGet(oddClient: string, sportType: string, eventType: string, fromEventStartTime?: Date, toEventStartTime?: Date, teamId?: number, teamIds?: string, eventOrder?: string, matchIds?: string, tournamentIds?: string, seasonIds?: string, oddsType?: string, options?: any) {
            return OddsApiFp(configuration).oddsGet(oddClient, sportType, eventType, fromEventStartTime, toEventStartTime, teamId, teamIds, eventOrder, matchIds, tournamentIds, seasonIds, oddsType, options)(fetch, basePath);
        },
        /**
         * Returns a list of Odd Providers which have odds available for a given Event
         * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
         * @param {Date} [fromTime] Return odds for Events with start_time &gt;&#x3D; from_time. RFC 3339 format
         * @param {Date} [toTime] Return odds for Events with start_time &lt;&#x3D; to_time. RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pregameoddsGet(xOddClient: string, fromTime?: Date, toTime?: Date, options?: any) {
            return OddsApiFp(configuration).pregameoddsGet(xOddClient, fromTime, toTime, options)(fetch, basePath);
        },
    };
};

/**
 * OddsApi - object-oriented interface
 * @export
 * @class OddsApi
 * @extends {BaseAPI}
 */
export class OddsApi extends BaseAPI {
    /**
     * Get available liveodds for an event
     * @param {string} id Unique identifier of the resource.
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public eventsIdLiveoddsGet(id: string, xOddClient: string, options?: any) {
        return OddsApiFp(this.configuration).eventsIdLiveoddsGet(id, xOddClient, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of odds available in the system
     * @param {string} id Unique identifier of the resource.
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public eventsIdOddsGet(id: string, xOddClient: string, options?: any) {
        return OddsApiFp(this.configuration).eventsIdOddsGet(id, xOddClient, options)(this.fetch, this.basePath);
    }

    /**
     * Get available pre-game odds for an Event
     * @param {string} id Unique identifier of the resource.
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public eventsIdPregameoddsGet(id: string, xOddClient: string, options?: any) {
        return OddsApiFp(this.configuration).eventsIdPregameoddsGet(id, xOddClient, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of liveodds available in the system
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public liveoddsGet(xOddClient: string, options?: any) {
        return OddsApiFp(this.configuration).liveoddsGet(xOddClient, options)(this.fetch, this.basePath);
    }

    /**
     * Return a list of OddProviders available in the system. If X-Odd-Client is specified they will be filtered and ordered by the client configuration.
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public oddProvidersGet(xOddClient: string, options?: any) {
        return OddsApiFp(this.configuration).oddProvidersGet(xOddClient, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of Odds
     * @param {string} oddClient Odd client code
     * @param {string} sportType Sport type filter
     * @param {string} eventType Event type filter
     * @param {Date} [fromEventStartTime] Return odds for Events with start_time &gt;&#x3D; from_event_start_time. RFC 3339 format
     * @param {Date} [toEventStartTime] Return odds for Events with start_time &lt;&#x3D; to_event_start_time. RFC 3339 format
     * @param {number} [teamId] Team ID
     * @param {string} [teamIds] List for team IDs separated by commas.
     * @param {string} [eventOrder] Order matching events for a specific client
     * @param {string} [matchIds] List for match IDs separated by commas.
     * @param {string} [tournamentIds] List for tournament IDs separated by commas.
     * @param {string} [seasonIds] List for season IDs separated by commas.
     * @param {string} [oddsType] Pregame or live odds selector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public oddsGet(oddClient: string, sportType: string, eventType: string, fromEventStartTime?: Date, toEventStartTime?: Date, teamId?: number, teamIds?: string, eventOrder?: string, matchIds?: string, tournamentIds?: string, seasonIds?: string, oddsType?: string, options?: any) {
        return OddsApiFp(this.configuration).oddsGet(oddClient, sportType, eventType, fromEventStartTime, toEventStartTime, teamId, teamIds, eventOrder, matchIds, tournamentIds, seasonIds, oddsType, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of Odd Providers which have odds available for a given Event
     * @param {string} xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#x27;coupon&#x27; key with the odds fo building URLs.
     * @param {Date} [fromTime] Return odds for Events with start_time &gt;&#x3D; from_time. RFC 3339 format
     * @param {Date} [toTime] Return odds for Events with start_time &lt;&#x3D; to_time. RFC 3339 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OddsApi
     */
    public pregameoddsGet(xOddClient: string, fromTime?: Date, toTime?: Date, options?: any) {
        return OddsApiFp(this.configuration).pregameoddsGet(xOddClient, fromTime, toTime, options)(this.fetch, this.basePath);
    }

}
/**
 * PlayerStatisticApi - fetch parameter creator
 * @export
 */
export const PlayerStatisticApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} languageCode Return translations depending on language code
         * @param {string} [playerIds] List for player IDs separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {number} [teamId] Return only statistics for players which are currently in the specified team&#x27;s squad
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsPlayersGet(languageCode: string, playerIds?: string, seasonIds?: string, teamId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'languageCode' is not null or undefined
            if (languageCode === null || languageCode === undefined) {
                throw new RequiredError('languageCode','Required parameter languageCode was null or undefined when calling statisticsPlayersGet.');
            }
            const localVarPath = `/statistics/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (playerIds !== undefined) {
                localVarQueryParameter['player_ids'] = playerIds;
            }

            if (seasonIds !== undefined) {
                localVarQueryParameter['season_ids'] = seasonIds;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk Upsert player statistics
         * @param {Array<V2PlayerStatisticInput>} [body] Array of player match statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatisticsPlayersMatchPut(body?: Array<V2PlayerStatisticInput>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/statistics/players/match`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2PlayerStatisticInput&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve player statistics, grouped by player and season
         * @param {string} [playerIds] CSV list of player id values
         * @param {string} [seasonIds] CSV list of tournament season id values
         * @param {number} [teamId] Team unique identifier
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatisticsPlayersSeasonGet(playerIds?: string, seasonIds?: string, teamId?: number, languageCode?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/statistics/players/season`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (playerIds !== undefined) {
                localVarQueryParameter['player_ids'] = playerIds;
            }

            if (seasonIds !== undefined) {
                localVarQueryParameter['season_ids'] = seasonIds;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerStatisticApi - functional programming interface
 * @export
 */
export const PlayerStatisticApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} languageCode Return translations depending on language code
         * @param {string} [playerIds] List for player IDs separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {number} [teamId] Return only statistics for players which are currently in the specified team&#x27;s squad
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsPlayersGet(languageCode: string, playerIds?: string, seasonIds?: string, teamId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OutputDto>> {
            const localVarFetchArgs = PlayerStatisticApiFetchParamCreator(configuration).statisticsPlayersGet(languageCode, playerIds, seasonIds, teamId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk Upsert player statistics
         * @param {Array<V2PlayerStatisticInput>} [body] Array of player match statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatisticsPlayersMatchPut(body?: Array<V2PlayerStatisticInput>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2PlayerStatisticOutput>> {
            const localVarFetchArgs = PlayerStatisticApiFetchParamCreator(configuration).v2StatisticsPlayersMatchPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve player statistics, grouped by player and season
         * @param {string} [playerIds] CSV list of player id values
         * @param {string} [seasonIds] CSV list of tournament season id values
         * @param {number} [teamId] Team unique identifier
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatisticsPlayersSeasonGet(playerIds?: string, seasonIds?: string, teamId?: number, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2PlayerSeasonStatisticOutputCollection>> {
            const localVarFetchArgs = PlayerStatisticApiFetchParamCreator(configuration).v2StatisticsPlayersSeasonGet(playerIds, seasonIds, teamId, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayerStatisticApi - factory interface
 * @export
 */
export const PlayerStatisticApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} languageCode Return translations depending on language code
         * @param {string} [playerIds] List for player IDs separated by commas.
         * @param {string} [seasonIds] List for season IDs separated by commas.
         * @param {number} [teamId] Return only statistics for players which are currently in the specified team&#x27;s squad
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsPlayersGet(languageCode: string, playerIds?: string, seasonIds?: string, teamId?: number, options?: any) {
            return PlayerStatisticApiFp(configuration).statisticsPlayersGet(languageCode, playerIds, seasonIds, teamId, options)(fetch, basePath);
        },
        /**
         * Bulk Upsert player statistics
         * @param {Array<V2PlayerStatisticInput>} [body] Array of player match statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatisticsPlayersMatchPut(body?: Array<V2PlayerStatisticInput>, options?: any) {
            return PlayerStatisticApiFp(configuration).v2StatisticsPlayersMatchPut(body, options)(fetch, basePath);
        },
        /**
         * Retrieve player statistics, grouped by player and season
         * @param {string} [playerIds] CSV list of player id values
         * @param {string} [seasonIds] CSV list of tournament season id values
         * @param {number} [teamId] Team unique identifier
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StatisticsPlayersSeasonGet(playerIds?: string, seasonIds?: string, teamId?: number, languageCode?: string, options?: any) {
            return PlayerStatisticApiFp(configuration).v2StatisticsPlayersSeasonGet(playerIds, seasonIds, teamId, languageCode, options)(fetch, basePath);
        },
    };
};

/**
 * PlayerStatisticApi - object-oriented interface
 * @export
 * @class PlayerStatisticApi
 * @extends {BaseAPI}
 */
export class PlayerStatisticApi extends BaseAPI {
    /**
     * 
     * @param {string} languageCode Return translations depending on language code
     * @param {string} [playerIds] List for player IDs separated by commas.
     * @param {string} [seasonIds] List for season IDs separated by commas.
     * @param {number} [teamId] Return only statistics for players which are currently in the specified team&#x27;s squad
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerStatisticApi
     */
    public statisticsPlayersGet(languageCode: string, playerIds?: string, seasonIds?: string, teamId?: number, options?: any) {
        return PlayerStatisticApiFp(this.configuration).statisticsPlayersGet(languageCode, playerIds, seasonIds, teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk Upsert player statistics
     * @param {Array<V2PlayerStatisticInput>} [body] Array of player match statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerStatisticApi
     */
    public v2StatisticsPlayersMatchPut(body?: Array<V2PlayerStatisticInput>, options?: any) {
        return PlayerStatisticApiFp(this.configuration).v2StatisticsPlayersMatchPut(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve player statistics, grouped by player and season
     * @param {string} [playerIds] CSV list of player id values
     * @param {string} [seasonIds] CSV list of tournament season id values
     * @param {number} [teamId] Team unique identifier
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerStatisticApi
     */
    public v2StatisticsPlayersSeasonGet(playerIds?: string, seasonIds?: string, teamId?: number, languageCode?: string, options?: any) {
        return PlayerStatisticApiFp(this.configuration).v2StatisticsPlayersSeasonGet(playerIds, seasonIds, teamId, languageCode, options)(this.fetch, this.basePath);
    }

}
/**
 * PlayersApi - fetch parameter creator
 * @export
 */
export const PlayersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search player list by parameters
         * @param {string} name Filter players by names. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;Ronaldo&#x27; it will match both &#x27;Cristiono Ronaldo&#x27; and &#x27;Ronaldo&#x27;
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [maxResults] Limit the number of results returned
         * @param {number} [teamId] Return only players which are currently in the specified team&#x27;s squad
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(name: string, acceptLanguage?: string, maxResults?: number, teamId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling playersGet.');
            }
            const localVarPath = `/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific Player
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specify additional information to include in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdGet(id: string, acceptLanguage?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersIdGet.');
            }
            const localVarPath = `/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics throughout a Player's career
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [type] Filter statistics for different types of team and competition
         * @param {string} [groupBy] Group response by a given property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdStatisticsGet(id: string, acceptLanguage?: string, type?: string, groupBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersIdStatisticsGet.');
            }
            const localVarPath = `/players/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Teams in which a Player has participated during his career
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdTeamsGet(id: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling playersIdTeamsGet.');
            }
            const localVarPath = `/players/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search player list by parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersGet(offset: number, limit: number, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling v2PlayersGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v2PlayersGet.');
            }
            const localVarPath = `/v2/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the active clubs of a player
         * @param {string} id Unique identifier of the resource.
         * @param {V2ActiveClubsInput} [body] Active clubs input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdClubsActivePut(id: string, body?: V2ActiveClubsInput, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2PlayersIdClubsActivePut.');
            }
            const localVarPath = `/v2/players/{id}/clubs/active`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2ActiveClubsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get player by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2PlayersIdGet.');
            }
            const localVarPath = `/v2/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Player information
         * @param {PlayerEditDto} body Player information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdPut(body: PlayerEditDto, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2PlayersIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2PlayersIdPut.');
            }
            const localVarPath = `/v2/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlayerEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a newly created player in storage.
         * @param {PlayerEditDto} [body] PlayerEditDto object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersPost(body?: PlayerEditDto, options: any = {}): FetchArgs {
            const localVarPath = `/v2/players`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlayerEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Search player list by parameters
         * @param {string} name Filter players by names. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;Ronaldo&#x27; it will match both &#x27;Cristiono Ronaldo&#x27; and &#x27;Ronaldo&#x27;
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [maxResults] Limit the number of results returned
         * @param {number} [teamId] Return only players which are currently in the specified team&#x27;s squad
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(name: string, acceptLanguage?: string, maxResults?: number, teamId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Player>> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersGet(name, acceptLanguage, maxResults, teamId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a specific Player
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specify additional information to include in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerProfile> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersIdGet(id, acceptLanguage, expand, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns statistics throughout a Player's career
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [type] Filter statistics for different types of team and competition
         * @param {string} [groupBy] Group response by a given property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdStatisticsGet(id: string, acceptLanguage?: string, type?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PlayerStatistics>> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersIdStatisticsGet(id, acceptLanguage, type, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the Teams in which a Player has participated during his career
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdTeamsGet(id: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PlayerTeam>> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).playersIdTeamsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search player list by parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersGet(offset: number, limit: number, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerPageDto> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).v2PlayersGet(offset, limit, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the active clubs of a player
         * @param {string} id Unique identifier of the resource.
         * @param {V2ActiveClubsInput} [body] Active clubs input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdClubsActivePut(id: string, body?: V2ActiveClubsInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2PlayerActiveClub>> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).v2PlayersIdClubsActivePut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get player by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2PlayerProfile> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).v2PlayersIdGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Player information
         * @param {PlayerEditDto} body Player information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdPut(body: PlayerEditDto, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).v2PlayersIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store a newly created player in storage.
         * @param {PlayerEditDto} [body] PlayerEditDto object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersPost(body?: PlayerEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PlayerDto> {
            const localVarFetchArgs = PlayersApiFetchParamCreator(configuration).v2PlayersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Search player list by parameters
         * @param {string} name Filter players by names. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;Ronaldo&#x27; it will match both &#x27;Cristiono Ronaldo&#x27; and &#x27;Ronaldo&#x27;
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [maxResults] Limit the number of results returned
         * @param {number} [teamId] Return only players which are currently in the specified team&#x27;s squad
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersGet(name: string, acceptLanguage?: string, maxResults?: number, teamId?: number, options?: any) {
            return PlayersApiFp(configuration).playersGet(name, acceptLanguage, maxResults, teamId, options)(fetch, basePath);
        },
        /**
         * Get information about a specific Player
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specify additional information to include in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
            return PlayersApiFp(configuration).playersIdGet(id, acceptLanguage, expand, options)(fetch, basePath);
        },
        /**
         * Returns statistics throughout a Player's career
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [type] Filter statistics for different types of team and competition
         * @param {string} [groupBy] Group response by a given property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdStatisticsGet(id: string, acceptLanguage?: string, type?: string, groupBy?: string, options?: any) {
            return PlayersApiFp(configuration).playersIdStatisticsGet(id, acceptLanguage, type, groupBy, options)(fetch, basePath);
        },
        /**
         * Get the Teams in which a Player has participated during his career
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersIdTeamsGet(id: string, acceptLanguage?: string, options?: any) {
            return PlayersApiFp(configuration).playersIdTeamsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Search player list by parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersGet(offset: number, limit: number, languageCode?: string, options?: any) {
            return PlayersApiFp(configuration).v2PlayersGet(offset, limit, languageCode, options)(fetch, basePath);
        },
        /**
         * Update the active clubs of a player
         * @param {string} id Unique identifier of the resource.
         * @param {V2ActiveClubsInput} [body] Active clubs input
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdClubsActivePut(id: string, body?: V2ActiveClubsInput, options?: any) {
            return PlayersApiFp(configuration).v2PlayersIdClubsActivePut(id, body, options)(fetch, basePath);
        },
        /**
         * Get player by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdGet(id: string, languageCode?: string, options?: any) {
            return PlayersApiFp(configuration).v2PlayersIdGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Update Player information
         * @param {PlayerEditDto} body Player information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersIdPut(body: PlayerEditDto, id: string, options?: any) {
            return PlayersApiFp(configuration).v2PlayersIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Store a newly created player in storage.
         * @param {PlayerEditDto} [body] PlayerEditDto object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PlayersPost(body?: PlayerEditDto, options?: any) {
            return PlayersApiFp(configuration).v2PlayersPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     * Search player list by parameters
     * @param {string} name Filter players by names. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;Ronaldo&#x27; it will match both &#x27;Cristiono Ronaldo&#x27; and &#x27;Ronaldo&#x27;
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {number} [maxResults] Limit the number of results returned
     * @param {number} [teamId] Return only players which are currently in the specified team&#x27;s squad
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersGet(name: string, acceptLanguage?: string, maxResults?: number, teamId?: number, options?: any) {
        return PlayersApiFp(this.configuration).playersGet(name, acceptLanguage, maxResults, teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about a specific Player
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [expand] Specify additional information to include in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
        return PlayersApiFp(this.configuration).playersIdGet(id, acceptLanguage, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Returns statistics throughout a Player's career
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [type] Filter statistics for different types of team and competition
     * @param {string} [groupBy] Group response by a given property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersIdStatisticsGet(id: string, acceptLanguage?: string, type?: string, groupBy?: string, options?: any) {
        return PlayersApiFp(this.configuration).playersIdStatisticsGet(id, acceptLanguage, type, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get the Teams in which a Player has participated during his career
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersIdTeamsGet(id: string, acceptLanguage?: string, options?: any) {
        return PlayersApiFp(this.configuration).playersIdTeamsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Search player list by parameters
     * @param {number} offset The number of items to skip before starting to collect the result set
     * @param {number} limit Limit the number of results returned
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public v2PlayersGet(offset: number, limit: number, languageCode?: string, options?: any) {
        return PlayersApiFp(this.configuration).v2PlayersGet(offset, limit, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update the active clubs of a player
     * @param {string} id Unique identifier of the resource.
     * @param {V2ActiveClubsInput} [body] Active clubs input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public v2PlayersIdClubsActivePut(id: string, body?: V2ActiveClubsInput, options?: any) {
        return PlayersApiFp(this.configuration).v2PlayersIdClubsActivePut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get player by id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public v2PlayersIdGet(id: string, languageCode?: string, options?: any) {
        return PlayersApiFp(this.configuration).v2PlayersIdGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update Player information
     * @param {PlayerEditDto} body Player information to save in persistance
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public v2PlayersIdPut(body: PlayerEditDto, id: string, options?: any) {
        return PlayersApiFp(this.configuration).v2PlayersIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Store a newly created player in storage.
     * @param {PlayerEditDto} [body] PlayerEditDto object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public v2PlayersPost(body?: PlayerEditDto, options?: any) {
        return PlayersApiFp(this.configuration).v2PlayersPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PresidentsApi - fetch parameter creator
 * @export
 */
export const PresidentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update president information
         * @param {string} id Unique identifier of the resource.
         * @param {V2PresidentUpdate} [body] President information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PresidentsIdPut(id: string, body?: V2PresidentUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2PresidentsIdPut.');
            }
            const localVarPath = `/v2/presidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2PresidentUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a newly created president in storage
         * @param {V2PresidentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PresidentsPost(body?: V2PresidentInput, options: any = {}): FetchArgs {
            const localVarPath = `/v2/presidents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2PresidentInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PresidentsApi - functional programming interface
 * @export
 */
export const PresidentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update president information
         * @param {string} id Unique identifier of the resource.
         * @param {V2PresidentUpdate} [body] President information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PresidentsIdPut(id: string, body?: V2PresidentUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2President> {
            const localVarFetchArgs = PresidentsApiFetchParamCreator(configuration).v2PresidentsIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store a newly created president in storage
         * @param {V2PresidentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PresidentsPost(body?: V2PresidentInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2President> {
            const localVarFetchArgs = PresidentsApiFetchParamCreator(configuration).v2PresidentsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PresidentsApi - factory interface
 * @export
 */
export const PresidentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Update president information
         * @param {string} id Unique identifier of the resource.
         * @param {V2PresidentUpdate} [body] President information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PresidentsIdPut(id: string, body?: V2PresidentUpdate, options?: any) {
            return PresidentsApiFp(configuration).v2PresidentsIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store a newly created president in storage
         * @param {V2PresidentInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2PresidentsPost(body?: V2PresidentInput, options?: any) {
            return PresidentsApiFp(configuration).v2PresidentsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * PresidentsApi - object-oriented interface
 * @export
 * @class PresidentsApi
 * @extends {BaseAPI}
 */
export class PresidentsApi extends BaseAPI {
    /**
     * Update president information
     * @param {string} id Unique identifier of the resource.
     * @param {V2PresidentUpdate} [body] President information to save in persistance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresidentsApi
     */
    public v2PresidentsIdPut(id: string, body?: V2PresidentUpdate, options?: any) {
        return PresidentsApiFp(this.configuration).v2PresidentsIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store a newly created president in storage
     * @param {V2PresidentInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresidentsApi
     */
    public v2PresidentsPost(body?: V2PresidentInput, options?: any) {
        return PresidentsApiFp(this.configuration).v2PresidentsPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProviderMappingsApi - fetch parameter creator
 * @export
 */
export const ProviderMappingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk find provider to internal ID mappings by their provider ID and entity type.
         * @param {MappingsSearchBody} [body] Data entity provider name and array of mapping requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MappingsSearchPost(body?: MappingsSearchBody, options: any = {}): FetchArgs {
            const localVarPath = `/v2/mappings/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MappingsSearchBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderMappingsApi - functional programming interface
 * @export
 */
export const ProviderMappingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Bulk find provider to internal ID mappings by their provider ID and entity type.
         * @param {MappingsSearchBody} [body] Data entity provider name and array of mapping requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MappingsSearchPost(body?: MappingsSearchBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2MappingDto>> {
            const localVarFetchArgs = ProviderMappingsApiFetchParamCreator(configuration).v2MappingsSearchPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProviderMappingsApi - factory interface
 * @export
 */
export const ProviderMappingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Bulk find provider to internal ID mappings by their provider ID and entity type.
         * @param {MappingsSearchBody} [body] Data entity provider name and array of mapping requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2MappingsSearchPost(body?: MappingsSearchBody, options?: any) {
            return ProviderMappingsApiFp(configuration).v2MappingsSearchPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * ProviderMappingsApi - object-oriented interface
 * @export
 * @class ProviderMappingsApi
 * @extends {BaseAPI}
 */
export class ProviderMappingsApi extends BaseAPI {
    /**
     * Bulk find provider to internal ID mappings by their provider ID and entity type.
     * @param {MappingsSearchBody} [body] Data entity provider name and array of mapping requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderMappingsApi
     */
    public v2MappingsSearchPost(body?: MappingsSearchBody, options?: any) {
        return ProviderMappingsApiFp(this.configuration).v2MappingsSearchPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * RefereesApi - fetch parameter creator
 * @export
 */
export const RefereesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List referees with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [seasonIds] Filter referees which have refereed matches in the specified CSV season_ids
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling v2RefereesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v2RefereesGet.');
            }
            const localVarPath = `/v2/referees`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (seasonIds !== undefined) {
                localVarQueryParameter['season_ids'] = seasonIds;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get referee by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesIdGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2RefereesIdGet.');
            }
            const localVarPath = `/v2/referees/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update referee information
         * @param {string} id Unique identifier of the resource.
         * @param {RefereeEditDto} [body] Referee information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesIdPut(id: string, body?: RefereeEditDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2RefereesIdPut.');
            }
            const localVarPath = `/v2/referees/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RefereeEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a newly created referee in storage
         * @param {RefereeEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesPost(body?: RefereeEditDto, options: any = {}): FetchArgs {
            const localVarPath = `/v2/referees`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RefereeEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefereesApi - functional programming interface
 * @export
 */
export const RefereesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List referees with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [seasonIds] Filter referees which have refereed matches in the specified CSV season_ids
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefereePageDto> {
            const localVarFetchArgs = RefereesApiFetchParamCreator(configuration).v2RefereesGet(offset, limit, seasonIds, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get referee by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesIdGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefereeDto> {
            const localVarFetchArgs = RefereesApiFetchParamCreator(configuration).v2RefereesIdGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update referee information
         * @param {string} id Unique identifier of the resource.
         * @param {RefereeEditDto} [body] Referee information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesIdPut(id: string, body?: RefereeEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefereeDto> {
            const localVarFetchArgs = RefereesApiFetchParamCreator(configuration).v2RefereesIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store a newly created referee in storage
         * @param {RefereeEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesPost(body?: RefereeEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefereeDto> {
            const localVarFetchArgs = RefereesApiFetchParamCreator(configuration).v2RefereesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RefereesApi - factory interface
 * @export
 */
export const RefereesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List referees with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [seasonIds] Filter referees which have refereed matches in the specified CSV season_ids
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options?: any) {
            return RefereesApiFp(configuration).v2RefereesGet(offset, limit, seasonIds, languageCode, options)(fetch, basePath);
        },
        /**
         * Get referee by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesIdGet(id: string, languageCode?: string, options?: any) {
            return RefereesApiFp(configuration).v2RefereesIdGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Update referee information
         * @param {string} id Unique identifier of the resource.
         * @param {RefereeEditDto} [body] Referee information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesIdPut(id: string, body?: RefereeEditDto, options?: any) {
            return RefereesApiFp(configuration).v2RefereesIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store a newly created referee in storage
         * @param {RefereeEditDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RefereesPost(body?: RefereeEditDto, options?: any) {
            return RefereesApiFp(configuration).v2RefereesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * RefereesApi - object-oriented interface
 * @export
 * @class RefereesApi
 * @extends {BaseAPI}
 */
export class RefereesApi extends BaseAPI {
    /**
     * List referees with offset and limit parameters
     * @param {number} offset The number of items to skip before starting to collect the result set
     * @param {number} limit Limit the number of results returned
     * @param {string} [seasonIds] Filter referees which have refereed matches in the specified CSV season_ids
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefereesApi
     */
    public v2RefereesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options?: any) {
        return RefereesApiFp(this.configuration).v2RefereesGet(offset, limit, seasonIds, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get referee by id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefereesApi
     */
    public v2RefereesIdGet(id: string, languageCode?: string, options?: any) {
        return RefereesApiFp(this.configuration).v2RefereesIdGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update referee information
     * @param {string} id Unique identifier of the resource.
     * @param {RefereeEditDto} [body] Referee information to save in persistance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefereesApi
     */
    public v2RefereesIdPut(id: string, body?: RefereeEditDto, options?: any) {
        return RefereesApiFp(this.configuration).v2RefereesIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store a newly created referee in storage
     * @param {RefereeEditDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefereesApi
     */
    public v2RefereesPost(body?: RefereeEditDto, options?: any) {
        return RefereesApiFp(this.configuration).v2RefereesPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * RoundsApi - fetch parameter creator
 * @export
 */
export const RoundsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of rounds per season
         * @param {number} seasonId Filter round types per a season ID
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RoundsGet(seasonId: number, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling v2RoundsGet.');
            }
            const localVarPath = `/v2/rounds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (seasonId !== undefined) {
                localVarQueryParameter['season_id'] = seasonId;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of rounds per stage
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdRoundsGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StagesIdRoundsGet.');
            }
            const localVarPath = `/v2/stages/{id}/rounds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoundsApi - functional programming interface
 * @export
 */
export const RoundsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of rounds per season
         * @param {number} seasonId Filter round types per a season ID
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RoundsGet(seasonId: number, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2RoundTypes> {
            const localVarFetchArgs = RoundsApiFetchParamCreator(configuration).v2RoundsGet(seasonId, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of rounds per stage
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdRoundsGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2RoundTypes> {
            const localVarFetchArgs = RoundsApiFetchParamCreator(configuration).v2StagesIdRoundsGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoundsApi - factory interface
 * @export
 */
export const RoundsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of rounds per season
         * @param {number} seasonId Filter round types per a season ID
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2RoundsGet(seasonId: number, languageCode?: string, options?: any) {
            return RoundsApiFp(configuration).v2RoundsGet(seasonId, languageCode, options)(fetch, basePath);
        },
        /**
         * Get a list of rounds per stage
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdRoundsGet(id: string, languageCode?: string, options?: any) {
            return RoundsApiFp(configuration).v2StagesIdRoundsGet(id, languageCode, options)(fetch, basePath);
        },
    };
};

/**
 * RoundsApi - object-oriented interface
 * @export
 * @class RoundsApi
 * @extends {BaseAPI}
 */
export class RoundsApi extends BaseAPI {
    /**
     * Get a list of rounds per season
     * @param {number} seasonId Filter round types per a season ID
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoundsApi
     */
    public v2RoundsGet(seasonId: number, languageCode?: string, options?: any) {
        return RoundsApiFp(this.configuration).v2RoundsGet(seasonId, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of rounds per stage
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoundsApi
     */
    public v2StagesIdRoundsGet(id: string, languageCode?: string, options?: any) {
        return RoundsApiFp(this.configuration).v2StagesIdRoundsGet(id, languageCode, options)(this.fetch, this.basePath);
    }

}
/**
 * SeasonApi - fetch parameter creator
 * @export
 */
export const SeasonApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the details of a season by season_id, or by tournament_id and active status
         * @param {string} [seasonId] The ID of the season of interest
         * @param {string} [tournamentId] The ID of the tournament whose active season is of interest
         * @param {string} [status] Required only when the tournament_id parameter is provided
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsDetailsGet(seasonId?: string, tournamentId?: string, status?: string, languageCode?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/seasons/details`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (seasonId !== undefined) {
                localVarQueryParameter['season_id'] = seasonId;
            }

            if (tournamentId !== undefined) {
                localVarQueryParameter['tournament_id'] = tournamentId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get seasons by tournament_id, team_id and status
         * @param {string} [tournamentId] Required only if no other parameters are provided
         * @param {string} [teamId] Required only if no other paramenters are provided
         * @param {string} [status] Required only if no other parameters are provided
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsGet(tournamentId?: string, teamId?: string, status?: string, languageCode?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/seasons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (tournamentId !== undefined) {
                localVarQueryParameter['tournament_id'] = tournamentId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing season
         * @param {V2TournamentSeasonUpdateInput} body Season name
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdPut(body: V2TournamentSeasonUpdateInput, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2SeasonsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2SeasonsIdPut.');
            }
            const localVarPath = `/v2/seasons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TournamentSeasonUpdateInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all stages for specific season
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdStagesGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2SeasonsIdStagesGet.');
            }
            const localVarPath = `/v2/seasons/{id}/stages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update multiple stages
         * @param {Array<V2SeasonStage>} body List of stages to be updated or created
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdStagesPost(body: Array<V2SeasonStage>, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2SeasonsIdStagesPost.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2SeasonsIdStagesPost.');
            }
            const localVarPath = `/v2/seasons/{id}/stages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2SeasonStage&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new season
         * @param {V2TournamentSeasonInsertInput} body Season information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsPost(body: V2TournamentSeasonInsertInput, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2SeasonsPost.');
            }
            const localVarPath = `/v2/seasons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TournamentSeasonInsertInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete stage
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StagesIdDelete.');
            }
            const localVarPath = `/v2/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the current season as active and change all other seasons in the tournament to inactive
         * @param {V2TournamentSeasonStatusInput} body Season unique identifier
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsIdSeasonsCurrentPatch(body: V2TournamentSeasonStatusInput, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2TournamentsIdSeasonsCurrentPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2TournamentsIdSeasonsCurrentPatch.');
            }
            const localVarPath = `/v2/tournaments/{id}/seasons/current`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TournamentSeasonStatusInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SeasonApi - functional programming interface
 * @export
 */
export const SeasonApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the details of a season by season_id, or by tournament_id and active status
         * @param {string} [seasonId] The ID of the season of interest
         * @param {string} [tournamentId] The ID of the tournament whose active season is of interest
         * @param {string} [status] Required only when the tournament_id parameter is provided
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsDetailsGet(seasonId?: string, tournamentId?: string, status?: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2SeasonDetails> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2SeasonsDetailsGet(seasonId, tournamentId, status, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get seasons by tournament_id, team_id and status
         * @param {string} [tournamentId] Required only if no other parameters are provided
         * @param {string} [teamId] Required only if no other paramenters are provided
         * @param {string} [status] Required only if no other parameters are provided
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsGet(tournamentId?: string, teamId?: string, status?: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2SeasonList> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2SeasonsGet(tournamentId, teamId, status, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an existing season
         * @param {V2TournamentSeasonUpdateInput} body Season name
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdPut(body: V2TournamentSeasonUpdateInput, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Season> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2SeasonsIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all stages for specific season
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdStagesGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2SeasonStageCollection> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2SeasonsIdStagesGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update multiple stages
         * @param {Array<V2SeasonStage>} body List of stages to be updated or created
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdStagesPost(body: Array<V2SeasonStage>, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2SeasonStageCollection> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2SeasonsIdStagesPost(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new season
         * @param {V2TournamentSeasonInsertInput} body Season information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsPost(body: V2TournamentSeasonInsertInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Season> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2SeasonsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete stage
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2StagesIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set the current season as active and change all other seasons in the tournament to inactive
         * @param {V2TournamentSeasonStatusInput} body Season unique identifier
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsIdSeasonsCurrentPatch(body: V2TournamentSeasonStatusInput, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Season> {
            const localVarFetchArgs = SeasonApiFetchParamCreator(configuration).v2TournamentsIdSeasonsCurrentPatch(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SeasonApi - factory interface
 * @export
 */
export const SeasonApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the details of a season by season_id, or by tournament_id and active status
         * @param {string} [seasonId] The ID of the season of interest
         * @param {string} [tournamentId] The ID of the tournament whose active season is of interest
         * @param {string} [status] Required only when the tournament_id parameter is provided
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsDetailsGet(seasonId?: string, tournamentId?: string, status?: string, languageCode?: string, options?: any) {
            return SeasonApiFp(configuration).v2SeasonsDetailsGet(seasonId, tournamentId, status, languageCode, options)(fetch, basePath);
        },
        /**
         * Get seasons by tournament_id, team_id and status
         * @param {string} [tournamentId] Required only if no other parameters are provided
         * @param {string} [teamId] Required only if no other paramenters are provided
         * @param {string} [status] Required only if no other parameters are provided
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsGet(tournamentId?: string, teamId?: string, status?: string, languageCode?: string, options?: any) {
            return SeasonApiFp(configuration).v2SeasonsGet(tournamentId, teamId, status, languageCode, options)(fetch, basePath);
        },
        /**
         * Update an existing season
         * @param {V2TournamentSeasonUpdateInput} body Season name
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdPut(body: V2TournamentSeasonUpdateInput, id: string, options?: any) {
            return SeasonApiFp(configuration).v2SeasonsIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * List all stages for specific season
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdStagesGet(id: string, languageCode?: string, options?: any) {
            return SeasonApiFp(configuration).v2SeasonsIdStagesGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Create or update multiple stages
         * @param {Array<V2SeasonStage>} body List of stages to be updated or created
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsIdStagesPost(body: Array<V2SeasonStage>, id: string, options?: any) {
            return SeasonApiFp(configuration).v2SeasonsIdStagesPost(body, id, options)(fetch, basePath);
        },
        /**
         * Create a new season
         * @param {V2TournamentSeasonInsertInput} body Season information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2SeasonsPost(body: V2TournamentSeasonInsertInput, options?: any) {
            return SeasonApiFp(configuration).v2SeasonsPost(body, options)(fetch, basePath);
        },
        /**
         * Permanently delete stage
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdDelete(id: string, options?: any) {
            return SeasonApiFp(configuration).v2StagesIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Set the current season as active and change all other seasons in the tournament to inactive
         * @param {V2TournamentSeasonStatusInput} body Season unique identifier
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsIdSeasonsCurrentPatch(body: V2TournamentSeasonStatusInput, id: string, options?: any) {
            return SeasonApiFp(configuration).v2TournamentsIdSeasonsCurrentPatch(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SeasonApi - object-oriented interface
 * @export
 * @class SeasonApi
 * @extends {BaseAPI}
 */
export class SeasonApi extends BaseAPI {
    /**
     * Get the details of a season by season_id, or by tournament_id and active status
     * @param {string} [seasonId] The ID of the season of interest
     * @param {string} [tournamentId] The ID of the tournament whose active season is of interest
     * @param {string} [status] Required only when the tournament_id parameter is provided
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2SeasonsDetailsGet(seasonId?: string, tournamentId?: string, status?: string, languageCode?: string, options?: any) {
        return SeasonApiFp(this.configuration).v2SeasonsDetailsGet(seasonId, tournamentId, status, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get seasons by tournament_id, team_id and status
     * @param {string} [tournamentId] Required only if no other parameters are provided
     * @param {string} [teamId] Required only if no other paramenters are provided
     * @param {string} [status] Required only if no other parameters are provided
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2SeasonsGet(tournamentId?: string, teamId?: string, status?: string, languageCode?: string, options?: any) {
        return SeasonApiFp(this.configuration).v2SeasonsGet(tournamentId, teamId, status, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update an existing season
     * @param {V2TournamentSeasonUpdateInput} body Season name
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2SeasonsIdPut(body: V2TournamentSeasonUpdateInput, id: string, options?: any) {
        return SeasonApiFp(this.configuration).v2SeasonsIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * List all stages for specific season
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2SeasonsIdStagesGet(id: string, languageCode?: string, options?: any) {
        return SeasonApiFp(this.configuration).v2SeasonsIdStagesGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update multiple stages
     * @param {Array<V2SeasonStage>} body List of stages to be updated or created
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2SeasonsIdStagesPost(body: Array<V2SeasonStage>, id: string, options?: any) {
        return SeasonApiFp(this.configuration).v2SeasonsIdStagesPost(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new season
     * @param {V2TournamentSeasonInsertInput} body Season information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2SeasonsPost(body: V2TournamentSeasonInsertInput, options?: any) {
        return SeasonApiFp(this.configuration).v2SeasonsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently delete stage
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2StagesIdDelete(id: string, options?: any) {
        return SeasonApiFp(this.configuration).v2StagesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Set the current season as active and change all other seasons in the tournament to inactive
     * @param {V2TournamentSeasonStatusInput} body Season unique identifier
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonApi
     */
    public v2TournamentsIdSeasonsCurrentPatch(body: V2TournamentSeasonStatusInput, id: string, options?: any) {
        return SeasonApiFp(this.configuration).v2TournamentsIdSeasonsCurrentPatch(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * StagesApi - fetch parameter creator
 * @export
 */
export const StagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Listing for Stages resources
         * @param {number} [teamId] Filter stages by a team which is participating in the stage
         * @param {string} [tournamentIds] CSV list of tournament.id values to filter stages
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagesGet(teamId?: number, tournamentIds?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            const localVarPath = `/stages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (tournamentIds !== undefined) {
                localVarQueryParameter['tournament_ids'] = tournamentIds;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete group
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2GroupsIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2GroupsIdDelete.');
            }
            const localVarPath = `/v2/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all groups for specific stage
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdGroupsGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StagesIdGroupsGet.');
            }
            const localVarPath = `/v2/stages/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update multiple groups
         * @param {Array<V2StageGroup>} body List of groups to be updated or created
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdGroupsPost(body: Array<V2StageGroup>, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2StagesIdGroupsPost.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StagesIdGroupsPost.');
            }
            const localVarPath = `/v2/stages/{id}/groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2StageGroup&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace teams in stage
         * @param {Array<V2StageTeamInput>} body List of team ids
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdTeamsPut(body: Array<V2StageTeamInput>, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2StagesIdTeamsPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StagesIdTeamsPut.');
            }
            const localVarPath = `/v2/stages/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2StageTeamInput&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StagesApi - functional programming interface
 * @export
 */
export const StagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Listing for Stages resources
         * @param {number} [teamId] Filter stages by a team which is participating in the stage
         * @param {string} [tournamentIds] CSV list of tournament.id values to filter stages
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagesGet(teamId?: number, tournamentIds?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StageDto>> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).stagesGet(teamId, tournamentIds, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete group
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2GroupsIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).v2GroupsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all groups for specific stage
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdGroupsGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2StageGroupCollection> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).v2StagesIdGroupsGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create or update multiple groups
         * @param {Array<V2StageGroup>} body List of groups to be updated or created
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdGroupsPost(body: Array<V2StageGroup>, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2StageGroupCollection> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).v2StagesIdGroupsPost(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Replace teams in stage
         * @param {Array<V2StageTeamInput>} body List of team ids
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdTeamsPut(body: Array<V2StageTeamInput>, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StagesApiFetchParamCreator(configuration).v2StagesIdTeamsPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StagesApi - factory interface
 * @export
 */
export const StagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Listing for Stages resources
         * @param {number} [teamId] Filter stages by a team which is participating in the stage
         * @param {string} [tournamentIds] CSV list of tournament.id values to filter stages
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagesGet(teamId?: number, tournamentIds?: string, acceptLanguage?: string, options?: any) {
            return StagesApiFp(configuration).stagesGet(teamId, tournamentIds, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Permanently delete group
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2GroupsIdDelete(id: string, options?: any) {
            return StagesApiFp(configuration).v2GroupsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * List all groups for specific stage
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdGroupsGet(id: string, languageCode?: string, options?: any) {
            return StagesApiFp(configuration).v2StagesIdGroupsGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Create or update multiple groups
         * @param {Array<V2StageGroup>} body List of groups to be updated or created
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdGroupsPost(body: Array<V2StageGroup>, id: string, options?: any) {
            return StagesApiFp(configuration).v2StagesIdGroupsPost(body, id, options)(fetch, basePath);
        },
        /**
         * Replace teams in stage
         * @param {Array<V2StageTeamInput>} body List of team ids
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StagesIdTeamsPut(body: Array<V2StageTeamInput>, id: string, options?: any) {
            return StagesApiFp(configuration).v2StagesIdTeamsPut(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * StagesApi - object-oriented interface
 * @export
 * @class StagesApi
 * @extends {BaseAPI}
 */
export class StagesApi extends BaseAPI {
    /**
     * Listing for Stages resources
     * @param {number} [teamId] Filter stages by a team which is participating in the stage
     * @param {string} [tournamentIds] CSV list of tournament.id values to filter stages
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public stagesGet(teamId?: number, tournamentIds?: string, acceptLanguage?: string, options?: any) {
        return StagesApiFp(this.configuration).stagesGet(teamId, tournamentIds, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently delete group
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public v2GroupsIdDelete(id: string, options?: any) {
        return StagesApiFp(this.configuration).v2GroupsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * List all groups for specific stage
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public v2StagesIdGroupsGet(id: string, languageCode?: string, options?: any) {
        return StagesApiFp(this.configuration).v2StagesIdGroupsGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Create or update multiple groups
     * @param {Array<V2StageGroup>} body List of groups to be updated or created
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public v2StagesIdGroupsPost(body: Array<V2StageGroup>, id: string, options?: any) {
        return StagesApiFp(this.configuration).v2StagesIdGroupsPost(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Replace teams in stage
     * @param {Array<V2StageTeamInput>} body List of team ids
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StagesApi
     */
    public v2StagesIdTeamsPut(body: Array<V2StageTeamInput>, id: string, options?: any) {
        return StagesApiFp(this.configuration).v2StagesIdTeamsPut(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * StandingRuleApi - fetch parameter creator
 * @export
 */
export const StandingRuleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of available StandingRule objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standingRulesGet(acceptLanguage?: string, options: any = {}): FetchArgs {
            const localVarPath = `/standing_rules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StandingRuleApi - functional programming interface
 * @export
 */
export const StandingRuleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of available StandingRule objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standingRulesGet(acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StandingRule> {
            const localVarFetchArgs = StandingRuleApiFetchParamCreator(configuration).standingRulesGet(acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StandingRuleApi - factory interface
 * @export
 */
export const StandingRuleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of available StandingRule objects in the system
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standingRulesGet(acceptLanguage?: string, options?: any) {
            return StandingRuleApiFp(configuration).standingRulesGet(acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * StandingRuleApi - object-oriented interface
 * @export
 * @class StandingRuleApi
 * @extends {BaseAPI}
 */
export class StandingRuleApi extends BaseAPI {
    /**
     * Get a list of available StandingRule objects in the system
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandingRuleApi
     */
    public standingRulesGet(acceptLanguage?: string, options?: any) {
        return StandingRuleApiFp(this.configuration).standingRulesGet(acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * StandingsApi - fetch parameter creator
 * @export
 */
export const StandingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update a league standing table
         * @param {V2LeagueStandingInput} body List of all entries for the standing
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsLeagueEntityIdPut(body: V2LeagueStandingInput, entity: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2StandingsLeagueEntityIdPut.');
            }
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling v2StandingsLeagueEntityIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StandingsLeagueEntityIdPut.');
            }
            const localVarPath = `/v2/standings/league/{entity}/{id}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2LeagueStandingInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach standing rules to a league standing
         * @param {V2StandingEntryRuleWrapper} body list of rules for every rank
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsLeagueEntityIdRulesPut(body: V2StandingEntryRuleWrapper, entity: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2StandingsLeagueEntityIdRulesPut.');
            }
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling v2StandingsLeagueEntityIdRulesPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StandingsLeagueEntityIdRulesPut.');
            }
            const localVarPath = `/v2/standings/league/{entity}/{id}/rules`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2StandingEntryRuleWrapper" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a topscorer standing table
         * @param {V2TopScorerStandingInput} body List of all entries for the standing
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsTopscorerEntityIdPut(body: V2TopScorerStandingInput, entity: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2StandingsTopscorerEntityIdPut.');
            }
            // verify required parameter 'entity' is not null or undefined
            if (entity === null || entity === undefined) {
                throw new RequiredError('entity','Required parameter entity was null or undefined when calling v2StandingsTopscorerEntityIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2StandingsTopscorerEntityIdPut.');
            }
            const localVarPath = `/v2/standings/topscorer/{entity}/{id}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TopScorerStandingInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StandingsApi - functional programming interface
 * @export
 */
export const StandingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update a league standing table
         * @param {V2LeagueStandingInput} body List of all entries for the standing
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsLeagueEntityIdPut(body: V2LeagueStandingInput, entity: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StandingsApiFetchParamCreator(configuration).v2StandingsLeagueEntityIdPut(body, entity, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attach standing rules to a league standing
         * @param {V2StandingEntryRuleWrapper} body list of rules for every rank
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsLeagueEntityIdRulesPut(body: V2StandingEntryRuleWrapper, entity: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StandingsApiFetchParamCreator(configuration).v2StandingsLeagueEntityIdRulesPut(body, entity, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a topscorer standing table
         * @param {V2TopScorerStandingInput} body List of all entries for the standing
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsTopscorerEntityIdPut(body: V2TopScorerStandingInput, entity: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StandingsApiFetchParamCreator(configuration).v2StandingsTopscorerEntityIdPut(body, entity, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StandingsApi - factory interface
 * @export
 */
export const StandingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Update a league standing table
         * @param {V2LeagueStandingInput} body List of all entries for the standing
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsLeagueEntityIdPut(body: V2LeagueStandingInput, entity: string, id: string, options?: any) {
            return StandingsApiFp(configuration).v2StandingsLeagueEntityIdPut(body, entity, id, options)(fetch, basePath);
        },
        /**
         * Attach standing rules to a league standing
         * @param {V2StandingEntryRuleWrapper} body list of rules for every rank
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsLeagueEntityIdRulesPut(body: V2StandingEntryRuleWrapper, entity: string, id: string, options?: any) {
            return StandingsApiFp(configuration).v2StandingsLeagueEntityIdRulesPut(body, entity, id, options)(fetch, basePath);
        },
        /**
         * Update a topscorer standing table
         * @param {V2TopScorerStandingInput} body List of all entries for the standing
         * @param {string} entity type of entity to attach standing to
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2StandingsTopscorerEntityIdPut(body: V2TopScorerStandingInput, entity: string, id: string, options?: any) {
            return StandingsApiFp(configuration).v2StandingsTopscorerEntityIdPut(body, entity, id, options)(fetch, basePath);
        },
    };
};

/**
 * StandingsApi - object-oriented interface
 * @export
 * @class StandingsApi
 * @extends {BaseAPI}
 */
export class StandingsApi extends BaseAPI {
    /**
     * Update a league standing table
     * @param {V2LeagueStandingInput} body List of all entries for the standing
     * @param {string} entity type of entity to attach standing to
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandingsApi
     */
    public v2StandingsLeagueEntityIdPut(body: V2LeagueStandingInput, entity: string, id: string, options?: any) {
        return StandingsApiFp(this.configuration).v2StandingsLeagueEntityIdPut(body, entity, id, options)(this.fetch, this.basePath);
    }

    /**
     * Attach standing rules to a league standing
     * @param {V2StandingEntryRuleWrapper} body list of rules for every rank
     * @param {string} entity type of entity to attach standing to
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandingsApi
     */
    public v2StandingsLeagueEntityIdRulesPut(body: V2StandingEntryRuleWrapper, entity: string, id: string, options?: any) {
        return StandingsApiFp(this.configuration).v2StandingsLeagueEntityIdRulesPut(body, entity, id, options)(this.fetch, this.basePath);
    }

    /**
     * Update a topscorer standing table
     * @param {V2TopScorerStandingInput} body List of all entries for the standing
     * @param {string} entity type of entity to attach standing to
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandingsApi
     */
    public v2StandingsTopscorerEntityIdPut(body: V2TopScorerStandingInput, entity: string, id: string, options?: any) {
        return StandingsApiFp(this.configuration).v2StandingsTopscorerEntityIdPut(body, entity, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TeamSquadApi - fetch parameter creator
 * @export
 */
export const TeamSquadApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get teams squad
         * @param {string} id Unique identifier of the resource.
         * @param {string} [memberStatus] 
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdSquadGet(id: string, memberStatus?: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2TeamsIdSquadGet.');
            }
            const localVarPath = `/v2/teams/{id}/squad`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (memberStatus !== undefined) {
                localVarQueryParameter['memberStatus'] = memberStatus;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update TeamSquad members
         * @param {V2TeamSquadInput} body TeamSquad members to update. Null value for a property means no update
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdSquadPatch(body: V2TeamSquadInput, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2TeamsIdSquadPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2TeamsIdSquadPatch.');
            }
            const localVarPath = `/v2/teams/{id}/squad`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TeamSquadInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamSquadApi - functional programming interface
 * @export
 */
export const TeamSquadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get teams squad
         * @param {string} id Unique identifier of the resource.
         * @param {string} [memberStatus] 
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdSquadGet(id: string, memberStatus?: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TeamSquad> {
            const localVarFetchArgs = TeamSquadApiFetchParamCreator(configuration).v2TeamsIdSquadGet(id, memberStatus, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update TeamSquad members
         * @param {V2TeamSquadInput} body TeamSquad members to update. Null value for a property means no update
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdSquadPatch(body: V2TeamSquadInput, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TeamSquad> {
            const localVarFetchArgs = TeamSquadApiFetchParamCreator(configuration).v2TeamsIdSquadPatch(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamSquadApi - factory interface
 * @export
 */
export const TeamSquadApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get teams squad
         * @param {string} id Unique identifier of the resource.
         * @param {string} [memberStatus] 
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdSquadGet(id: string, memberStatus?: string, languageCode?: string, options?: any) {
            return TeamSquadApiFp(configuration).v2TeamsIdSquadGet(id, memberStatus, languageCode, options)(fetch, basePath);
        },
        /**
         * Update TeamSquad members
         * @param {V2TeamSquadInput} body TeamSquad members to update. Null value for a property means no update
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdSquadPatch(body: V2TeamSquadInput, id: string, options?: any) {
            return TeamSquadApiFp(configuration).v2TeamsIdSquadPatch(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TeamSquadApi - object-oriented interface
 * @export
 * @class TeamSquadApi
 * @extends {BaseAPI}
 */
export class TeamSquadApi extends BaseAPI {
    /**
     * Get teams squad
     * @param {string} id Unique identifier of the resource.
     * @param {string} [memberStatus] 
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSquadApi
     */
    public v2TeamsIdSquadGet(id: string, memberStatus?: string, languageCode?: string, options?: any) {
        return TeamSquadApiFp(this.configuration).v2TeamsIdSquadGet(id, memberStatus, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update TeamSquad members
     * @param {V2TeamSquadInput} body TeamSquad members to update. Null value for a property means no update
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamSquadApi
     */
    public v2TeamsIdSquadPatch(body: V2TeamSquadInput, id: string, options?: any) {
        return TeamSquadApiFp(this.configuration).v2TeamsIdSquadPatch(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TeamStatsApi - fetch parameter creator
 * @export
 */
export const TeamStatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get statistics for the performance of each team involved in the event
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTeamstatsGet(acceptLanguage?: string, lastUpdate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/event_teamstats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (lastUpdate !== undefined) {
                localVarQueryParameter['last_update'] = (lastUpdate as any).toISOString();
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get statistics for the performance of each team involved in the event
         * @param {number} id Event.id for which team stats are requested
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdTeamstatsGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eventsIdTeamstatsGet.');
            }
            const localVarPath = `/events/{id}/teamstats`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamStatsApi - functional programming interface
 * @export
 */
export const TeamStatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get statistics for the performance of each team involved in the event
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTeamstatsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventTeamStats>> {
            const localVarFetchArgs = TeamStatsApiFetchParamCreator(configuration).eventTeamstatsGet(acceptLanguage, lastUpdate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get statistics for the performance of each team involved in the event
         * @param {number} id Event.id for which team stats are requested
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdTeamstatsGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventTeamStats>> {
            const localVarFetchArgs = TeamStatsApiFetchParamCreator(configuration).eventsIdTeamstatsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamStatsApi - factory interface
 * @export
 */
export const TeamStatsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get statistics for the performance of each team involved in the event
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTeamstatsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
            return TeamStatsApiFp(configuration).eventTeamstatsGet(acceptLanguage, lastUpdate, options)(fetch, basePath);
        },
        /**
         * Get statistics for the performance of each team involved in the event
         * @param {number} id Event.id for which team stats are requested
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdTeamstatsGet(id: number, acceptLanguage?: string, options?: any) {
            return TeamStatsApiFp(configuration).eventsIdTeamstatsGet(id, acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * TeamStatsApi - object-oriented interface
 * @export
 * @class TeamStatsApi
 * @extends {BaseAPI}
 */
export class TeamStatsApi extends BaseAPI {
    /**
     * Get statistics for the performance of each team involved in the event
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [lastUpdate] Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamStatsApi
     */
    public eventTeamstatsGet(acceptLanguage?: string, lastUpdate?: Date, options?: any) {
        return TeamStatsApiFp(this.configuration).eventTeamstatsGet(acceptLanguage, lastUpdate, options)(this.fetch, this.basePath);
    }

    /**
     * Get statistics for the performance of each team involved in the event
     * @param {number} id Event.id for which team stats are requested
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamStatsApi
     */
    public eventsIdTeamstatsGet(id: number, acceptLanguage?: string, options?: any) {
        return TeamStatsApiFp(this.configuration).eventsIdTeamstatsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * TeamsApi - fetch parameter creator
 * @export
 */
export const TeamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Teams for a specific Country.id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [national] Filter teams for different types of national and non national
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesIdTeamsGet(id: string, acceptLanguage?: string, national?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling countriesIdTeamsGet.');
            }
            const localVarPath = `/countries/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (national !== undefined) {
                localVarQueryParameter['national'] = national;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search all teams by parameters
         * @param {string} name Filter by team. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;United&#x27; it will match both &#x27;West Ham United&#x27; and &#x27;Newcastle United&#x27;
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [maxResults] Limit the number of results returned
         * @param {number} [countryId] Filter teams just from the specified country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(name: string, acceptLanguage?: string, maxResults?: number, countryId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling teamsGet.');
            }
            const localVarPath = `/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['country_id'] = countryId;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of events in which a team with a specified id has participated
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
         * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
         * @param {string} [direction] Whether to sort the results by ascending or descending order
         * @param {number} [tournamentSeasonStageId] Filter events for a specific tournament_season_stage.id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdEventsGet(id: string, acceptLanguage?: string, fromTime?: Date, toTime?: Date, direction?: string, tournamentSeasonStageId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdEventsGet.');
            }
            const localVarPath = `/teams/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fromTime !== undefined) {
                localVarQueryParameter['from_time'] = (fromTime as any).toISOString();
            }

            if (toTime !== undefined) {
                localVarQueryParameter['to_time'] = (toTime as any).toISOString();
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (tournamentSeasonStageId !== undefined) {
                localVarQueryParameter['tournament_season_stage_id'] = tournamentSeasonStageId;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Team form information accross all tournaments
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Whether to include information about every event in the TeamForm response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdFormGet(id: string, acceptLanguage?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdFormGet.');
            }
            const localVarPath = `/teams/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific Team
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specifies additional information to include with the Team response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdGet(id: string, acceptLanguage?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdGet.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current squad for a Team
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group players by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdPlayersGet.');
            }
            const localVarPath = `/teams/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get player statistics for the current season in the Team's League
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group the response by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsGet(id: string, acceptLanguage?: string, groupBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdPlayersStatisticsGet.');
            }
            const localVarPath = `/teams/{id}/players/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of TournamentSeasons for which Player Statistics are available
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsSeasonsGet(id: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdPlayersStatisticsSeasonsGet.');
            }
            const localVarPath = `/teams/{id}/players/statistics/seasons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get player statistics for the current season in the Team's League
         * @param {number} seasonId Unique identifier of the TournamentSeason resource
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group the response by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId: number, id: string, acceptLanguage?: string, groupBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling teamsIdPlayersStatisticsSeasonsSeasonIdGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdPlayersStatisticsSeasonsSeasonIdGet.');
            }
            const localVarPath = `/teams/{id}/players/statistics/seasons/{seasonId}`
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the statistics for the latest League the team participates in
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [standing] Select whether to include a full league standing or just the team&#x27;s position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdStatisticsLeagueGet(id: string, acceptLanguage?: string, standing?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamsIdStatisticsLeagueGet.');
            }
            const localVarPath = `/teams/{id}/statistics/league`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (standing !== undefined) {
                localVarQueryParameter['standing'] = standing;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsIdTeamsGet.');
            }
            const localVarPath = `/tournaments/seasons/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdTeamsGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually insert team colors by team or event.
         * @param {V2TeamColors} [body] Team shirt colors data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsColorsPost(body?: V2TeamColors, options: any = {}): FetchArgs {
            const localVarPath = `/v2/teams/colors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TeamColors" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get teams list
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsGet(offset: number, limit: number, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling v2TeamsGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v2TeamsGet.');
            }
            const localVarPath = `/v2/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get team by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2TeamsIdGet.');
            }
            const localVarPath = `/v2/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Team information
         * @param {TeamEditDto} body Team information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdPut(body: TeamEditDto, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2TeamsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2TeamsIdPut.');
            }
            const localVarPath = `/v2/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually insert team.
         * @param {TeamEditDto} [body] TeamEditDto object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsPost(body?: TeamEditDto, options: any = {}): FetchArgs {
            const localVarPath = `/v2/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Teams for a specific Country.id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [national] Filter teams for different types of national and non national
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesIdTeamsGet(id: string, acceptLanguage?: string, national?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).countriesIdTeamsGet(id, acceptLanguage, national, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search all teams by parameters
         * @param {string} name Filter by team. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;United&#x27; it will match both &#x27;West Ham United&#x27; and &#x27;Newcastle United&#x27;
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [maxResults] Limit the number of results returned
         * @param {number} [countryId] Filter teams just from the specified country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(name: string, acceptLanguage?: string, maxResults?: number, countryId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsGet(name, acceptLanguage, maxResults, countryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of events in which a team with a specified id has participated
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
         * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
         * @param {string} [direction] Whether to sort the results by ascending or descending order
         * @param {number} [tournamentSeasonStageId] Filter events for a specific tournament_season_stage.id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdEventsGet(id: string, acceptLanguage?: string, fromTime?: Date, toTime?: Date, direction?: string, tournamentSeasonStageId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdEventsGet(id, acceptLanguage, fromTime, toTime, direction, tournamentSeasonStageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Team form information accross all tournaments
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Whether to include information about every event in the TeamForm response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdFormGet(id: string, acceptLanguage?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamForm>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdFormGet(id, acceptLanguage, expand, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a specific Team
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specifies additional information to include with the Team response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdGet(id, acceptLanguage, expand, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the current squad for a Team
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group players by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TeamPlayer>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdPlayersGet(id, acceptLanguage, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get player statistics for the current season in the Team's League
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group the response by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamPlayerSeasonStatistics> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdPlayersStatisticsGet(id, acceptLanguage, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of TournamentSeasons for which Player Statistics are available
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsSeasonsGet(id: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TournamentSeasonWithTournament>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdPlayersStatisticsSeasonsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get player statistics for the current season in the Team's League
         * @param {number} seasonId Unique identifier of the TournamentSeason resource
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group the response by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId: number, id: string, acceptLanguage?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamPlayerSeasonStatistics> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId, id, acceptLanguage, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the statistics for the latest League the team participates in
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [standing] Select whether to include a full league standing or just the team&#x27;s position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdStatisticsLeagueGet(id: string, acceptLanguage?: string, standing?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamSeasonStatistics> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamsIdStatisticsLeagueGet(id, acceptLanguage, standing, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PartialTeam>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).tournamentsSeasonsIdTeamsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PartialTeam>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdTeamsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Manually insert team colors by team or event.
         * @param {V2TeamColors} [body] Team shirt colors data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsColorsPost(body?: V2TeamColors, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TeamColors> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).v2TeamsColorsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get teams list
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsGet(offset: number, limit: number, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TeamPageDto> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).v2TeamsGet(offset, limit, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get team by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TeamProfile> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).v2TeamsIdGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Team information
         * @param {TeamEditDto} body Team information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdPut(body: TeamEditDto, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TeamProfile> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).v2TeamsIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Manually insert team.
         * @param {TeamEditDto} [body] TeamEditDto object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsPost(body?: TeamEditDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TeamProfile> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).v2TeamsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Teams for a specific Country.id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [national] Filter teams for different types of national and non national
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesIdTeamsGet(id: string, acceptLanguage?: string, national?: string, options?: any) {
            return TeamsApiFp(configuration).countriesIdTeamsGet(id, acceptLanguage, national, options)(fetch, basePath);
        },
        /**
         * Search all teams by parameters
         * @param {string} name Filter by team. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;United&#x27; it will match both &#x27;West Ham United&#x27; and &#x27;Newcastle United&#x27;
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [maxResults] Limit the number of results returned
         * @param {number} [countryId] Filter teams just from the specified country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(name: string, acceptLanguage?: string, maxResults?: number, countryId?: number, options?: any) {
            return TeamsApiFp(configuration).teamsGet(name, acceptLanguage, maxResults, countryId, options)(fetch, basePath);
        },
        /**
         * Get a list of events in which a team with a specified id has participated
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
         * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
         * @param {string} [direction] Whether to sort the results by ascending or descending order
         * @param {number} [tournamentSeasonStageId] Filter events for a specific tournament_season_stage.id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdEventsGet(id: string, acceptLanguage?: string, fromTime?: Date, toTime?: Date, direction?: string, tournamentSeasonStageId?: number, options?: any) {
            return TeamsApiFp(configuration).teamsIdEventsGet(id, acceptLanguage, fromTime, toTime, direction, tournamentSeasonStageId, options)(fetch, basePath);
        },
        /**
         * Get Team form information accross all tournaments
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Whether to include information about every event in the TeamForm response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdFormGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdFormGet(id, acceptLanguage, expand, options)(fetch, basePath);
        },
        /**
         * Get information about a specific Team
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [expand] Specifies additional information to include with the Team response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdGet(id, acceptLanguage, expand, options)(fetch, basePath);
        },
        /**
         * Get the current squad for a Team
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group players by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdPlayersGet(id, acceptLanguage, groupBy, options)(fetch, basePath);
        },
        /**
         * Get player statistics for the current season in the Team's League
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group the response by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdPlayersStatisticsGet(id, acceptLanguage, groupBy, options)(fetch, basePath);
        },
        /**
         * Get a list of TournamentSeasons for which Player Statistics are available
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsSeasonsGet(id: string, acceptLanguage?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdPlayersStatisticsSeasonsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get player statistics for the current season in the Team's League
         * @param {number} seasonId Unique identifier of the TournamentSeason resource
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Group the response by a specific property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId: number, id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId, id, acceptLanguage, groupBy, options)(fetch, basePath);
        },
        /**
         * Get the statistics for the latest League the team participates in
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [standing] Select whether to include a full league standing or just the team&#x27;s position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsIdStatisticsLeagueGet(id: string, acceptLanguage?: string, standing?: string, options?: any) {
            return TeamsApiFp(configuration).teamsIdStatisticsLeagueGet(id, acceptLanguage, standing, options)(fetch, basePath);
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
            return TeamsApiFp(configuration).tournamentsSeasonsIdTeamsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
            return TeamsApiFp(configuration).tournamentsSeasonsStagesIdTeamsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Manually insert team colors by team or event.
         * @param {V2TeamColors} [body] Team shirt colors data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsColorsPost(body?: V2TeamColors, options?: any) {
            return TeamsApiFp(configuration).v2TeamsColorsPost(body, options)(fetch, basePath);
        },
        /**
         * Get teams list
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsGet(offset: number, limit: number, languageCode?: string, options?: any) {
            return TeamsApiFp(configuration).v2TeamsGet(offset, limit, languageCode, options)(fetch, basePath);
        },
        /**
         * Get team by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdGet(id: string, languageCode?: string, options?: any) {
            return TeamsApiFp(configuration).v2TeamsIdGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Update Team information
         * @param {TeamEditDto} body Team information to save in persistance
         * @param {string} id Unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsIdPut(body: TeamEditDto, id: string, options?: any) {
            return TeamsApiFp(configuration).v2TeamsIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Manually insert team.
         * @param {TeamEditDto} [body] TeamEditDto object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TeamsPost(body?: TeamEditDto, options?: any) {
            return TeamsApiFp(configuration).v2TeamsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * Get Teams for a specific Country.id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [national] Filter teams for different types of national and non national
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public countriesIdTeamsGet(id: string, acceptLanguage?: string, national?: string, options?: any) {
        return TeamsApiFp(this.configuration).countriesIdTeamsGet(id, acceptLanguage, national, options)(this.fetch, this.basePath);
    }

    /**
     * Search all teams by parameters
     * @param {string} name Filter by team. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#x27;United&#x27; it will match both &#x27;West Ham United&#x27; and &#x27;Newcastle United&#x27;
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {number} [maxResults] Limit the number of results returned
     * @param {number} [countryId] Filter teams just from the specified country
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsGet(name: string, acceptLanguage?: string, maxResults?: number, countryId?: number, options?: any) {
        return TeamsApiFp(this.configuration).teamsGet(name, acceptLanguage, maxResults, countryId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of events in which a team with a specified id has participated
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {Date} [fromTime] Filter events, which have a start_time after the specified date, format is RFC 3339
     * @param {Date} [toTime] Filter events, which have a start_time before the specified date, format is RFC 3339
     * @param {string} [direction] Whether to sort the results by ascending or descending order
     * @param {number} [tournamentSeasonStageId] Filter events for a specific tournament_season_stage.id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdEventsGet(id: string, acceptLanguage?: string, fromTime?: Date, toTime?: Date, direction?: string, tournamentSeasonStageId?: number, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdEventsGet(id, acceptLanguage, fromTime, toTime, direction, tournamentSeasonStageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get Team form information accross all tournaments
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [expand] Whether to include information about every event in the TeamForm response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdFormGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdFormGet(id, acceptLanguage, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about a specific Team
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [expand] Specifies additional information to include with the Team response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdGet(id: string, acceptLanguage?: string, expand?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdGet(id, acceptLanguage, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get the current squad for a Team
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Group players by a specific property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdPlayersGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdPlayersGet(id, acceptLanguage, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get player statistics for the current season in the Team's League
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Group the response by a specific property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdPlayersStatisticsGet(id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdPlayersStatisticsGet(id, acceptLanguage, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of TournamentSeasons for which Player Statistics are available
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdPlayersStatisticsSeasonsGet(id: string, acceptLanguage?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdPlayersStatisticsSeasonsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get player statistics for the current season in the Team's League
     * @param {number} seasonId Unique identifier of the TournamentSeason resource
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Group the response by a specific property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId: number, id: string, acceptLanguage?: string, groupBy?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdPlayersStatisticsSeasonsSeasonIdGet(seasonId, id, acceptLanguage, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get the statistics for the latest League the team participates in
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [standing] Select whether to include a full league standing or just the team&#x27;s position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsIdStatisticsLeagueGet(id: string, acceptLanguage?: string, standing?: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsIdStatisticsLeagueGet(id, acceptLanguage, standing, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Teams, which are participating in a given TournamentSeason
     * @param {number} id Unique identifier of the TournamentSeason resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
        return TeamsApiFp(this.configuration).tournamentsSeasonsIdTeamsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Teams, which are participating in a given TournamentSeasonStage
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
        return TeamsApiFp(this.configuration).tournamentsSeasonsStagesIdTeamsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Manually insert team colors by team or event.
     * @param {V2TeamColors} [body] Team shirt colors data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public v2TeamsColorsPost(body?: V2TeamColors, options?: any) {
        return TeamsApiFp(this.configuration).v2TeamsColorsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get teams list
     * @param {number} offset The number of items to skip before starting to collect the result set
     * @param {number} limit Limit the number of results returned
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public v2TeamsGet(offset: number, limit: number, languageCode?: string, options?: any) {
        return TeamsApiFp(this.configuration).v2TeamsGet(offset, limit, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get team by id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public v2TeamsIdGet(id: string, languageCode?: string, options?: any) {
        return TeamsApiFp(this.configuration).v2TeamsIdGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update Team information
     * @param {TeamEditDto} body Team information to save in persistance
     * @param {string} id Unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public v2TeamsIdPut(body: TeamEditDto, id: string, options?: any) {
        return TeamsApiFp(this.configuration).v2TeamsIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Manually insert team.
     * @param {TeamEditDto} [body] TeamEditDto object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public v2TeamsPost(body?: TeamEditDto, options?: any) {
        return TeamsApiFp(this.configuration).v2TeamsPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * TournamentGroupsApi - fetch parameter creator
 * @export
 */
export const TournamentGroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all tournaments for a given group name and their order
         * @param {string} code Tournament group code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodeGet(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling v2TournamentsGroupsCodeGet.');
            }
            const localVarPath = `/v2/tournaments/groups/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing tournament group
         * @param {V2TournamentGroupUpdateInput} body Tournament group information
         * @param {string} code Tournament group unique code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodePut(body: V2TournamentGroupUpdateInput, code: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2TournamentsGroupsCodePut.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling v2TournamentsGroupsCodePut.');
            }
            const localVarPath = `/v2/tournaments/groups/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TournamentGroupUpdateInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code Client code
         * @param {string} date Date in ISO 8601 format (Y-m-d)
         * @param {Array<V2TournamentGroupSelection>} [body] Array of match ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodeSelectionDatePost(code: string, date: string, body?: Array<V2TournamentGroupSelection>, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling v2TournamentsGroupsCodeSelectionDatePost.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling v2TournamentsGroupsCodeSelectionDatePost.');
            }
            const localVarPath = `/v2/tournaments/groups/{code}/selection/{date}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V2TournamentGroupSelection&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tournament groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsGet(options: any = {}): FetchArgs {
            const localVarPath = `/v2/tournaments/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tournament group
         * @param {V2TournamentGroupInsertInput} body Tournament group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsPost(body: V2TournamentGroupInsertInput, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling v2TournamentsGroupsPost.');
            }
            const localVarPath = `/v2/tournaments/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2TournamentGroupInsertInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentGroupsApi - functional programming interface
 * @export
 */
export const TournamentGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all tournaments for a given group name and their order
         * @param {string} code Tournament group code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodeGet(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TournamentGroupGetOutput> {
            const localVarFetchArgs = TournamentGroupsApiFetchParamCreator(configuration).v2TournamentsGroupsCodeGet(code, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an existing tournament group
         * @param {V2TournamentGroupUpdateInput} body Tournament group information
         * @param {string} code Tournament group unique code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodePut(body: V2TournamentGroupUpdateInput, code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TournamentGroupsApiFetchParamCreator(configuration).v2TournamentsGroupsCodePut(body, code, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} code Client code
         * @param {string} date Date in ISO 8601 format (Y-m-d)
         * @param {Array<V2TournamentGroupSelection>} [body] Array of match ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodeSelectionDatePost(code: string, date: string, body?: Array<V2TournamentGroupSelection>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TournamentGroupsApiFetchParamCreator(configuration).v2TournamentsGroupsCodeSelectionDatePost(code, date, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all tournament groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2TournamentGroupCollection> {
            const localVarFetchArgs = TournamentGroupsApiFetchParamCreator(configuration).v2TournamentsGroupsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new tournament group
         * @param {V2TournamentGroupInsertInput} body Tournament group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsPost(body: V2TournamentGroupInsertInput, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TournamentGroupsApiFetchParamCreator(configuration).v2TournamentsGroupsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TournamentGroupsApi - factory interface
 * @export
 */
export const TournamentGroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all tournaments for a given group name and their order
         * @param {string} code Tournament group code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodeGet(code: string, options?: any) {
            return TournamentGroupsApiFp(configuration).v2TournamentsGroupsCodeGet(code, options)(fetch, basePath);
        },
        /**
         * Update an existing tournament group
         * @param {V2TournamentGroupUpdateInput} body Tournament group information
         * @param {string} code Tournament group unique code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodePut(body: V2TournamentGroupUpdateInput, code: string, options?: any) {
            return TournamentGroupsApiFp(configuration).v2TournamentsGroupsCodePut(body, code, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} code Client code
         * @param {string} date Date in ISO 8601 format (Y-m-d)
         * @param {Array<V2TournamentGroupSelection>} [body] Array of match ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsCodeSelectionDatePost(code: string, date: string, body?: Array<V2TournamentGroupSelection>, options?: any) {
            return TournamentGroupsApiFp(configuration).v2TournamentsGroupsCodeSelectionDatePost(code, date, body, options)(fetch, basePath);
        },
        /**
         * List all tournament groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsGet(options?: any) {
            return TournamentGroupsApiFp(configuration).v2TournamentsGroupsGet(options)(fetch, basePath);
        },
        /**
         * Create a new tournament group
         * @param {V2TournamentGroupInsertInput} body Tournament group information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TournamentsGroupsPost(body: V2TournamentGroupInsertInput, options?: any) {
            return TournamentGroupsApiFp(configuration).v2TournamentsGroupsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * TournamentGroupsApi - object-oriented interface
 * @export
 * @class TournamentGroupsApi
 * @extends {BaseAPI}
 */
export class TournamentGroupsApi extends BaseAPI {
    /**
     * List all tournaments for a given group name and their order
     * @param {string} code Tournament group code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentGroupsApi
     */
    public v2TournamentsGroupsCodeGet(code: string, options?: any) {
        return TournamentGroupsApiFp(this.configuration).v2TournamentsGroupsCodeGet(code, options)(this.fetch, this.basePath);
    }

    /**
     * Update an existing tournament group
     * @param {V2TournamentGroupUpdateInput} body Tournament group information
     * @param {string} code Tournament group unique code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentGroupsApi
     */
    public v2TournamentsGroupsCodePut(body: V2TournamentGroupUpdateInput, code: string, options?: any) {
        return TournamentGroupsApiFp(this.configuration).v2TournamentsGroupsCodePut(body, code, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} code Client code
     * @param {string} date Date in ISO 8601 format (Y-m-d)
     * @param {Array<V2TournamentGroupSelection>} [body] Array of match ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentGroupsApi
     */
    public v2TournamentsGroupsCodeSelectionDatePost(code: string, date: string, body?: Array<V2TournamentGroupSelection>, options?: any) {
        return TournamentGroupsApiFp(this.configuration).v2TournamentsGroupsCodeSelectionDatePost(code, date, body, options)(this.fetch, this.basePath);
    }

    /**
     * List all tournament groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentGroupsApi
     */
    public v2TournamentsGroupsGet(options?: any) {
        return TournamentGroupsApiFp(this.configuration).v2TournamentsGroupsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Create a new tournament group
     * @param {V2TournamentGroupInsertInput} body Tournament group information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentGroupsApi
     */
    public v2TournamentsGroupsPost(body: V2TournamentGroupInsertInput, options?: any) {
        return TournamentGroupsApiFp(this.configuration).v2TournamentsGroupsPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * TournamentsApi - fetch parameter creator
 * @export
 */
export const TournamentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of available Tournament resources
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [countryId] Get Tournaments from a specific Country.id
         * @param {string} [clientOrder] Get Tournaments ordered for a specific client
         * @param {string} [expandClientSortorder] Include extra information with Tournament response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsGet(acceptLanguage?: string, countryId?: number, clientOrder?: string, expandClientSortorder?: string, options: any = {}): FetchArgs {
            const localVarPath = `/tournaments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (countryId !== undefined) {
                localVarQueryParameter['country_id'] = countryId;
            }

            if (clientOrder !== undefined) {
                localVarQueryParameter['client_order'] = clientOrder;
            }

            if (expandClientSortorder !== undefined) {
                localVarQueryParameter['expand_client_sortorder'] = expandClientSortorder;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdGet(id: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsIdGet.');
            }
            const localVarPath = `/tournaments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of seasons for a given Tournament id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdSeasonsGet(id: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsIdSeasonsGet.');
            }
            const localVarPath = `/tournaments/{id}/seasons`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for the latest season for a given Tournament. This is an alias to whatever resource is first in /tournaments/{id}/seasons
         * @param {number} id Unique identifier of the Tournament resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdSeasonsLatestGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsIdSeasonsLatestGet.');
            }
            const localVarPath = `/tournaments/{id}/seasons/latest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a standing by red,yellow cards for a specific TournamentSeason resource.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdCardlistGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsIdCardlistGet.');
            }
            const localVarPath = `/tournaments/seasons/{id}/cardlist`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Events, for a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Whether to group events by date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdEventsGet(id: number, acceptLanguage?: string, groupBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsIdEventsGet.');
            }
            const localVarPath = `/tournaments/seasons/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a given TournamentSeason resource id.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsIdGet.');
            }
            const localVarPath = `/tournaments/seasons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsIdTeamsGet.');
            }
            const localVarPath = `/tournaments/seasons/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of topscorers for a specific TournamentSeason resource.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTopscorerGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsIdTopscorerGet.');
            }
            const localVarPath = `/tournaments/seasons/{id}/topscorer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all currently active tournament season stages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesActiveGet(options: any = {}): FetchArgs {
            const localVarPath = `/tournaments/seasons/stages/active`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a StageGroup Resource
         * @param {number} id Unique identifier of the StageGroup resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesGroupsIdGet(id: number, expand?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesGroupsIdGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Standing for a StageGroup Resource
         * @param {number} id Unique identifier of the StageGroup resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesGroupsIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesGroupsIdStandingGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/groups/{id}/standing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of events which are fixtures in a given TournamentSeasonStage resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [round] Filter the event list by a specific round
         * @param {string} [sortDirection] Sort results by date in ascending or descending order
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdEventsGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (round !== undefined) {
                localVarQueryParameter['round'] = round;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a TournamentSeasonStage Resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdGet(id: number, expand?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of rounds for a specific TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify what additional information to include with the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdRoundsGet(id: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdRoundsGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}/rounds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Standing for a TournamentSeasonStage Resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdStandingGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}/standing`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdTeamsGet.');
            }
            const localVarPath = `/tournaments/seasons/stages/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentsApi - functional programming interface
 * @export
 */
export const TournamentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of available Tournament resources
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [countryId] Get Tournaments from a specific Country.id
         * @param {string} [clientOrder] Get Tournaments ordered for a specific client
         * @param {string} [expandClientSortorder] Include extra information with Tournament response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsGet(acceptLanguage?: string, countryId?: number, clientOrder?: string, expandClientSortorder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tournament>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsGet(acceptLanguage, countryId, clientOrder, expandClientSortorder, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdGet(id: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentWithSeasons> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsIdGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of seasons for a given Tournament id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdSeasonsGet(id: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TournamentSeason>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsIdSeasonsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information for the latest season for a given Tournament. This is an alias to whatever resource is first in /tournaments/{id}/seasons
         * @param {number} id Unique identifier of the Tournament resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdSeasonsLatestGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentSeasonWithStages> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsIdSeasonsLatestGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a standing by red,yellow cards for a specific TournamentSeason resource.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdCardlistGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CardlistStandingData>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsIdCardlistGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Events, for a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Whether to group events by date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdEventsGet(id: number, acceptLanguage?: string, groupBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsIdEventsGet(id, acceptLanguage, groupBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information for a given TournamentSeason resource id.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentSeasonWithStages> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsIdGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PartialTeam>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsIdTeamsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of topscorers for a specific TournamentSeason resource.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTopscorerGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TopscorerStandingData>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsIdTopscorerGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all currently active tournament season stages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesActiveGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TournamentSeasonStage>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesActiveGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information for a StageGroup Resource
         * @param {number} id Unique identifier of the StageGroup resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesGroupsIdGet(id: number, expand?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StageGroupWithStandingTournamentSeasonStage> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesGroupsIdGet(id, expand, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Standing for a StageGroup Resource
         * @param {number} id Unique identifier of the StageGroup resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesGroupsIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeagueStandingData>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesGroupsIdStandingGet(id, expand, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of events which are fixtures in a given TournamentSeasonStage resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [round] Filter the event list by a specific round
         * @param {string} [sortDirection] Sort results by date in ascending or descending order
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventsByDate>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdEventsGet(id, round, sortDirection, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information for a TournamentSeasonStage Resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdGet(id: number, expand?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentSeasonStageWithStandingGroups> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdGet(id, expand, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of rounds for a specific TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify what additional information to include with the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdRoundsGet(id: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Round>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdRoundsGet(id, expand, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Standing for a TournamentSeasonStage Resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LeagueStandingData>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdStandingGet(id, expand, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PartialTeam>> {
            const localVarFetchArgs = TournamentsApiFetchParamCreator(configuration).tournamentsSeasonsStagesIdTeamsGet(id, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TournamentsApi - factory interface
 * @export
 */
export const TournamentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of available Tournament resources
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {number} [countryId] Get Tournaments from a specific Country.id
         * @param {string} [clientOrder] Get Tournaments ordered for a specific client
         * @param {string} [expandClientSortorder] Include extra information with Tournament response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsGet(acceptLanguage?: string, countryId?: number, clientOrder?: string, expandClientSortorder?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsGet(acceptLanguage, countryId, clientOrder, expandClientSortorder, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdGet(id: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsIdGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of seasons for a given Tournament id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdSeasonsGet(id: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsIdSeasonsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get information for the latest season for a given Tournament. This is an alias to whatever resource is first in /tournaments/{id}/seasons
         * @param {number} id Unique identifier of the Tournament resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsIdSeasonsLatestGet(id: number, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsIdSeasonsLatestGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a standing by red,yellow cards for a specific TournamentSeason resource.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdCardlistGet(id: number, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsIdCardlistGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of Events, for a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {string} [groupBy] Whether to group events by date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdEventsGet(id: number, acceptLanguage?: string, groupBy?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsIdEventsGet(id, acceptLanguage, groupBy, options)(fetch, basePath);
        },
        /**
         * Get information for a given TournamentSeason resource id.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdGet(id: number, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsIdGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeason
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsIdTeamsGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of topscorers for a specific TournamentSeason resource.
         * @param {number} id Unique identifier of the TournamentSeason resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsIdTopscorerGet(id: number, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsIdTopscorerGet(id, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get all currently active tournament season stages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesActiveGet(options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesActiveGet(options)(fetch, basePath);
        },
        /**
         * Get information for a StageGroup Resource
         * @param {number} id Unique identifier of the StageGroup resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesGroupsIdGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesGroupsIdGet(id, expand, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get Standing for a StageGroup Resource
         * @param {number} id Unique identifier of the StageGroup resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesGroupsIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesGroupsIdStandingGet(id, expand, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of events which are fixtures in a given TournamentSeasonStage resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [round] Filter the event list by a specific round
         * @param {string} [sortDirection] Sort results by date in ascending or descending order
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesIdEventsGet(id, round, sortDirection, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get information for a TournamentSeasonStage Resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesIdGet(id, expand, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of rounds for a specific TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify what additional information to include with the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdRoundsGet(id: number, expand?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesIdRoundsGet(id, expand, options)(fetch, basePath);
        },
        /**
         * Get Standing for a TournamentSeasonStage Resource
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [expand] Specify additional information to include with the response
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesIdStandingGet(id, expand, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Get a list of Teams, which are participating in a given TournamentSeasonStage
         * @param {number} id Unique identifier of the TournamentSeasonStage resource
         * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
            return TournamentsApiFp(configuration).tournamentsSeasonsStagesIdTeamsGet(id, acceptLanguage, options)(fetch, basePath);
        },
    };
};

/**
 * TournamentsApi - object-oriented interface
 * @export
 * @class TournamentsApi
 * @extends {BaseAPI}
 */
export class TournamentsApi extends BaseAPI {
    /**
     * Get a list of available Tournament resources
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {number} [countryId] Get Tournaments from a specific Country.id
     * @param {string} [clientOrder] Get Tournaments ordered for a specific client
     * @param {string} [expandClientSortorder] Include extra information with Tournament response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsGet(acceptLanguage?: string, countryId?: number, clientOrder?: string, expandClientSortorder?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsGet(acceptLanguage, countryId, clientOrder, expandClientSortorder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsIdGet(id: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsIdGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of seasons for a given Tournament id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsIdSeasonsGet(id: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsIdSeasonsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get information for the latest season for a given Tournament. This is an alias to whatever resource is first in /tournaments/{id}/seasons
     * @param {number} id Unique identifier of the Tournament resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsIdSeasonsLatestGet(id: number, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsIdSeasonsLatestGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a standing by red,yellow cards for a specific TournamentSeason resource.
     * @param {number} id Unique identifier of the TournamentSeason resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsIdCardlistGet(id: number, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsIdCardlistGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Events, for a given TournamentSeason
     * @param {number} id Unique identifier of the TournamentSeason resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {string} [groupBy] Whether to group events by date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsIdEventsGet(id: number, acceptLanguage?: string, groupBy?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsIdEventsGet(id, acceptLanguage, groupBy, options)(this.fetch, this.basePath);
    }

    /**
     * Get information for a given TournamentSeason resource id.
     * @param {number} id Unique identifier of the TournamentSeason resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsIdGet(id: number, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsIdGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Teams, which are participating in a given TournamentSeason
     * @param {number} id Unique identifier of the TournamentSeason resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsIdTeamsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of topscorers for a specific TournamentSeason resource.
     * @param {number} id Unique identifier of the TournamentSeason resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsIdTopscorerGet(id: number, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsIdTopscorerGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get all currently active tournament season stages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesActiveGet(options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesActiveGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get information for a StageGroup Resource
     * @param {number} id Unique identifier of the StageGroup resource
     * @param {string} [expand] Specify additional information to include with the response
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesGroupsIdGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesGroupsIdGet(id, expand, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get Standing for a StageGroup Resource
     * @param {number} id Unique identifier of the StageGroup resource
     * @param {string} [expand] Specify additional information to include with the response
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesGroupsIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesGroupsIdStandingGet(id, expand, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of events which are fixtures in a given TournamentSeasonStage resource
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [round] Filter the event list by a specific round
     * @param {string} [sortDirection] Sort results by date in ascending or descending order
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesIdEventsGet(id: number, round?: string, sortDirection?: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesIdEventsGet(id, round, sortDirection, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get information for a TournamentSeasonStage Resource
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [expand] Specify additional information to include with the response
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesIdGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesIdGet(id, expand, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of rounds for a specific TournamentSeasonStage
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [expand] Specify what additional information to include with the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesIdRoundsGet(id: number, expand?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesIdRoundsGet(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get Standing for a TournamentSeasonStage Resource
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [expand] Specify additional information to include with the response
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesIdStandingGet(id: number, expand?: string, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesIdStandingGet(id, expand, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of Teams, which are participating in a given TournamentSeasonStage
     * @param {number} id Unique identifier of the TournamentSeasonStage resource
     * @param {string} [acceptLanguage] List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public tournamentsSeasonsStagesIdTeamsGet(id: number, acceptLanguage?: string, options?: any) {
        return TournamentsApiFp(this.configuration).tournamentsSeasonsStagesIdTeamsGet(id, acceptLanguage, options)(this.fetch, this.basePath);
    }

}
/**
 * TranslationsApi - fetch parameter creator
 * @export
 */
export const TranslationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all possible translation entities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsEntitiesGet(options: any = {}): FetchArgs {
            const localVarPath = `/v2/translations/entities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk Upsert translations by primary key
         * @param {Array<TranslationDto>} [body] Array of translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsPost(body?: Array<TranslationDto>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/translations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TranslationDto&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk find in translations table and return matching entries by the unique translation key.
         * @param {Array<TranslationKeyDto>} [body] Array of translationKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsSearchPost(body?: Array<TranslationKeyDto>, options: any = {}): FetchArgs {
            const localVarPath = `/v2/translations/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TranslationKeyDto&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranslationsApi - functional programming interface
 * @export
 */
export const TranslationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all possible translation entities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsEntitiesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TranslationEntityDto>> {
            const localVarFetchArgs = TranslationsApiFetchParamCreator(configuration).v2TranslationsEntitiesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk Upsert translations by primary key
         * @param {Array<TranslationDto>} [body] Array of translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsPost(body?: Array<TranslationDto>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TranslationDto> {
            const localVarFetchArgs = TranslationsApiFetchParamCreator(configuration).v2TranslationsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk find in translations table and return matching entries by the unique translation key.
         * @param {Array<TranslationKeyDto>} [body] Array of translationKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsSearchPost(body?: Array<TranslationKeyDto>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TranslationDto>> {
            const localVarFetchArgs = TranslationsApiFetchParamCreator(configuration).v2TranslationsSearchPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TranslationsApi - factory interface
 * @export
 */
export const TranslationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get all possible translation entities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsEntitiesGet(options?: any) {
            return TranslationsApiFp(configuration).v2TranslationsEntitiesGet(options)(fetch, basePath);
        },
        /**
         * Bulk Upsert translations by primary key
         * @param {Array<TranslationDto>} [body] Array of translations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsPost(body?: Array<TranslationDto>, options?: any) {
            return TranslationsApiFp(configuration).v2TranslationsPost(body, options)(fetch, basePath);
        },
        /**
         * Bulk find in translations table and return matching entries by the unique translation key.
         * @param {Array<TranslationKeyDto>} [body] Array of translationKeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2TranslationsSearchPost(body?: Array<TranslationKeyDto>, options?: any) {
            return TranslationsApiFp(configuration).v2TranslationsSearchPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * TranslationsApi - object-oriented interface
 * @export
 * @class TranslationsApi
 * @extends {BaseAPI}
 */
export class TranslationsApi extends BaseAPI {
    /**
     * Get all possible translation entities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public v2TranslationsEntitiesGet(options?: any) {
        return TranslationsApiFp(this.configuration).v2TranslationsEntitiesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Bulk Upsert translations by primary key
     * @param {Array<TranslationDto>} [body] Array of translations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public v2TranslationsPost(body?: Array<TranslationDto>, options?: any) {
        return TranslationsApiFp(this.configuration).v2TranslationsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk find in translations table and return matching entries by the unique translation key.
     * @param {Array<TranslationKeyDto>} [body] Array of translationKeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public v2TranslationsSearchPost(body?: Array<TranslationKeyDto>, options?: any) {
        return TranslationsApiFp(this.configuration).v2TranslationsSearchPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * VenuesApi - fetch parameter creator
 * @export
 */
export const VenuesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List venues with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [seasonIds] Filter venues which have hosted matches in the specified CSV season_ids
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling v2VenuesGet.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling v2VenuesGet.');
            }
            const localVarPath = `/v2/venues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (seasonIds !== undefined) {
                localVarQueryParameter['season_ids'] = seasonIds;
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get venue by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesIdGet(id: string, languageCode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2VenuesIdGet.');
            }
            const localVarPath = `/v2/venues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (languageCode !== undefined) {
                localVarQueryParameter['language_code'] = languageCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update venue information
         * @param {string} id Unique identifier of the resource.
         * @param {V2PutVenues} [body] Venue information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesIdPut(id: string, body?: V2PutVenues, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v2VenuesIdPut.');
            }
            const localVarPath = `/v2/venues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2PutVenues" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a newly created venue in storage
         * @param {V2PostVenues} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesPost(body?: V2PostVenues, options: any = {}): FetchArgs {
            const localVarPath = `/v2/venues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2PostVenues" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VenuesApi - functional programming interface
 * @export
 */
export const VenuesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List venues with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [seasonIds] Filter venues which have hosted matches in the specified CSV season_ids
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2VenuesList> {
            const localVarFetchArgs = VenuesApiFetchParamCreator(configuration).v2VenuesGet(offset, limit, seasonIds, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get venue by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesIdGet(id: string, languageCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2VenuesGetId> {
            const localVarFetchArgs = VenuesApiFetchParamCreator(configuration).v2VenuesIdGet(id, languageCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update venue information
         * @param {string} id Unique identifier of the resource.
         * @param {V2PutVenues} [body] Venue information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesIdPut(id: string, body?: V2PutVenues, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2VenuesPut> {
            const localVarFetchArgs = VenuesApiFetchParamCreator(configuration).v2VenuesIdPut(id, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store a newly created venue in storage
         * @param {V2PostVenues} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesPost(body?: V2PostVenues, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2Venues> {
            const localVarFetchArgs = VenuesApiFetchParamCreator(configuration).v2VenuesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VenuesApi - factory interface
 * @export
 */
export const VenuesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List venues with offset and limit parameters
         * @param {number} offset The number of items to skip before starting to collect the result set
         * @param {number} limit Limit the number of results returned
         * @param {string} [seasonIds] Filter venues which have hosted matches in the specified CSV season_ids
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options?: any) {
            return VenuesApiFp(configuration).v2VenuesGet(offset, limit, seasonIds, languageCode, options)(fetch, basePath);
        },
        /**
         * Get venue by id
         * @param {string} id Unique identifier of the resource.
         * @param {string} [languageCode] Returns translated response based on the language code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesIdGet(id: string, languageCode?: string, options?: any) {
            return VenuesApiFp(configuration).v2VenuesIdGet(id, languageCode, options)(fetch, basePath);
        },
        /**
         * Update venue information
         * @param {string} id Unique identifier of the resource.
         * @param {V2PutVenues} [body] Venue information to save in persistance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesIdPut(id: string, body?: V2PutVenues, options?: any) {
            return VenuesApiFp(configuration).v2VenuesIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * Store a newly created venue in storage
         * @param {V2PostVenues} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2VenuesPost(body?: V2PostVenues, options?: any) {
            return VenuesApiFp(configuration).v2VenuesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * VenuesApi - object-oriented interface
 * @export
 * @class VenuesApi
 * @extends {BaseAPI}
 */
export class VenuesApi extends BaseAPI {
    /**
     * List venues with offset and limit parameters
     * @param {number} offset The number of items to skip before starting to collect the result set
     * @param {number} limit Limit the number of results returned
     * @param {string} [seasonIds] Filter venues which have hosted matches in the specified CSV season_ids
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public v2VenuesGet(offset: number, limit: number, seasonIds?: string, languageCode?: string, options?: any) {
        return VenuesApiFp(this.configuration).v2VenuesGet(offset, limit, seasonIds, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get venue by id
     * @param {string} id Unique identifier of the resource.
     * @param {string} [languageCode] Returns translated response based on the language code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public v2VenuesIdGet(id: string, languageCode?: string, options?: any) {
        return VenuesApiFp(this.configuration).v2VenuesIdGet(id, languageCode, options)(this.fetch, this.basePath);
    }

    /**
     * Update venue information
     * @param {string} id Unique identifier of the resource.
     * @param {V2PutVenues} [body] Venue information to save in persistance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public v2VenuesIdPut(id: string, body?: V2PutVenues, options?: any) {
        return VenuesApiFp(this.configuration).v2VenuesIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Store a newly created venue in storage
     * @param {V2PostVenues} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VenuesApi
     */
    public v2VenuesPost(body?: V2PostVenues, options?: any) {
        return VenuesApiFp(this.configuration).v2VenuesPost(body, options)(this.fetch, this.basePath);
    }

}
