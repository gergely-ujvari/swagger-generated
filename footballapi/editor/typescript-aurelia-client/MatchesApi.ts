/**
 * Football API
 * API for accessing various kinds of football data, updated in real time.
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { autoinject } from 'aurelia-framework';
import { HttpClient } from 'aurelia-http-client';
import { Api } from './Api';
import { AuthStorage } from './AuthStorage';
import {
  LiveCommentaryOutputDto,
  V2Match,
  V2MatchInput,
} from './models';

/**
 * matchesIdCommentaryGet - parameters interface
 */
export interface IMatchesIdCommentaryGetParams {
  id: string;
  languageCode: string;
}

/**
 * v2MatchesGet - parameters interface
 */
export interface IV2MatchesGetParams {
  limit: number;
  offset: number;
  tournamentIds?: Array<number>;
  seasonIds?: Array<number>;
  stageIds?: Array<number>;
  groupIds?: Array<number>;
  roundIds?: Array<string>;
  roundFilter?: Array<string>;
  fromKickoffTime?: Date;
  toKickoffTime?: Date;
  teamIds?: Array<number>;
  statusTypes?: Array<string>;
  statusCodes?: Array<string>;
  refereeId?: number;
  venueId?: string;
  sortDirection?: string;
}

/**
 * v2MatchesIdGet - parameters interface
 */
export interface IV2MatchesIdGetParams {
  id: string;
  languageCode?: string;
}

/**
 * v2MatchesIdPut - parameters interface
 */
export interface IV2MatchesIdPutParams {
  id: string;
  match: V2MatchInput;
}

/**
 * v2MatchesLivescoreGet - parameters interface
 */
export interface IV2MatchesLivescoreGetParams {
  matchIds?: Array<number>;
  date?: string;
  utcOffset?: number;
  tournamentGroup?: string;
  statusTypes?: Array<'FINISHED' | 'NOT_STARTED' | 'LIVE' | 'INTERRUPTED' | 'CANCELLED' | 'UNKNOWN'>;
  selectionFilter?: 'ENABLED' | 'DISABLED';
}

/**
 * v2MatchesPost - parameters interface
 */
export interface IV2MatchesPostParams {
  match: V2MatchInput;
}

/**
 * MatchesApi - API class
 */
@autoinject()
export class MatchesApi extends Api {

  /**
   * Creates a new MatchesApi class.
   *
   * @param httpClient The Aurelia HTTP client to be injected.
   * @param authStorage A storage for authentication data.
   */
  constructor(httpClient: HttpClient, authStorage: AuthStorage) {
    super(httpClient, authStorage);
  }

  /**
   * Get a list of live commentaries with specified match id and language
   * @param params.id Unique identifier of the resource.
   * @param params.languageCode Return translations depending on language code
   */
  async matchesIdCommentaryGet(params: IMatchesIdCommentaryGetParams): Promise<Array<LiveCommentaryOutputDto>> {
    // Verify required parameters are set
    this.ensureParamIsSet('matchesIdCommentaryGet', params, 'id');
    this.ensureParamIsSet('matchesIdCommentaryGet', params, 'languageCode');

    // Create URL to call
    const url = `${this.basePath}/matches/{id}/commentary`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'language_code': params['languageCode'],
      })

      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of matches
   * @param params.limit Select an upper limit for the matches that would be returned
   * @param params.offset Select an offset for the matches that would be returned
   * @param params.tournamentIds Filter matches, which have been played as part of the listed tournaments
   * @param params.seasonIds Filter matches, which have been played as part of the listed tournament seasons
   * @param params.stageIds Filter matches, which have been played as part of the listed tournament stages
   * @param params.groupIds Filter matches, which have been played as part of the listed tournament groups
   * @param params.roundIds Filter matches, which have been played as part of the listed tournament rounds
   * @param params.roundFilter Filter matches by combinations of stage_id and round_id. Format: {stage_id}:{round_id}
   * @param params.fromKickoffTime Filter matches, which have a start_time after the specified date, format is ISO 8601
   * @param params.toKickoffTime Filter matches, which have a start_time before the specified date, format is ISO 8601
   * @param params.teamIds Filter matches by teams which have taken part in them
   * @param params.statusTypes Filter matches by their status types
   * @param params.statusCodes Filter matches by their status codes
   * @param params.refereeId Filter matches by the referee who has taken part in them
   * @param params.venueId Filter matches by the venue that has hosted them
   * @param params.sortDirection Sort matches in asc|desc order by start_time
   */
  async v2MatchesGet(params: IV2MatchesGetParams): Promise<Array<V2Match>> {
    // Verify required parameters are set
    this.ensureParamIsSet('v2MatchesGet', params, 'limit');
    this.ensureParamIsSet('v2MatchesGet', params, 'offset');

    // Create URL to call
    const url = `${this.basePath}/v2/matches`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'tournament_ids': params['tournamentIds'],
        'season_ids': params['seasonIds'],
        'stage_ids': params['stageIds'],
        'group_ids': params['groupIds'],
        'round_ids': params['roundIds'],
        'round_filter': params['roundFilter'],
        'from_kickoff_time': params['fromKickoffTime'],
        'to_kickoff_time': params['toKickoffTime'],
        'team_ids': params['teamIds'],
        'status_types': params['statusTypes'],
        'status_codes': params['statusCodes'],
        'referee_id': params['refereeId'],
        'venue_id': params['venueId'],
        'sort_direction': params['sortDirection'],
        'limit': params['limit'],
        'offset': params['offset'],
      })

      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.id Unique identifier of the resource.
   * @param params.languageCode Returns translated response based on the language code
   */
  async v2MatchesIdGet(params: IV2MatchesIdGetParams): Promise<V2Match> {
    // Verify required parameters are set
    this.ensureParamIsSet('v2MatchesIdGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/v2/matches/{id}`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'language_code': params['languageCode'],
      })

      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.id Unique identifier of the resource.
   * @param params.match Match information to save
   */
  async v2MatchesIdPut(params: IV2MatchesIdPutParams): Promise<V2Match> {
    // Verify required parameters are set
    this.ensureParamIsSet('v2MatchesIdPut', params, 'id');
    this.ensureParamIsSet('v2MatchesIdPut', params, 'match');

    // Create URL to call
    const url = `${this.basePath}/v2/matches/{id}`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPut()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['match'] || {}))

      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of matches
   * @param params.matchIds Filter matches by their IDs
   * @param params.date Filter matches by the date when they were played, format is ISO 8601
   * @param params.utcOffset Filter matches by date and UTC offset, allowed value range: [-12,14]
   * @param params.tournamentGroup Filter matches by a tournament group code
   * @param params.statusTypes Filter matches by status types
   * @param params.selectionFilter Fetch selected matches for specific date and tournament_group
   */
  async v2MatchesLivescoreGet(params: IV2MatchesLivescoreGetParams): Promise<Array<V2Match>> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/v2/matches/livescore`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'match_ids': params['matchIds'],
        'date': params['date'],
        'utc_offset': params['utcOffset'],
        'tournament_group': params['tournamentGroup'],
        'status_types': params['statusTypes'],
        'selection_filter': params['selectionFilter'],
      })

      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.match Match information to save
   */
  async v2MatchesPost(params: IV2MatchesPostParams): Promise<V2Match> {
    // Verify required parameters are set
    this.ensureParamIsSet('v2MatchesPost', params, 'match');

    // Create URL to call
    const url = `${this.basePath}/v2/matches`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['match'] || {}))

      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

}

