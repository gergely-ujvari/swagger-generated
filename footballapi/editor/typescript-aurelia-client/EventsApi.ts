/**
 * Football API
 * API for accessing various kinds of football data, updated in real time.
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { autoinject } from 'aurelia-framework';
import { HttpClient } from 'aurelia-http-client';
import { Api } from './Api';
import { AuthStorage } from './AuthStorage';
import {
  EventIncident,
  Lineup,
  EventsByDate,
  Event,
  EventPlayer,
  Odd,
} from './models';

/**
 * eventsByTeamsGet - parameters interface
 */
export interface IEventsByTeamsGetParams {
  homeId: number;
  awayId: number;
  acceptLanguage?: string;
}

/**
 * eventsGet - parameters interface
 */
export interface IEventsGetParams {
  acceptLanguage?: string;
  fromTime?: Date;
  toTime?: Date;
  groupBy?: '' | 'tournament_season_stage';
  clientOrder?: 'sportalios';
}

/**
 * eventsIdGet - parameters interface
 */
export interface IEventsIdGetParams {
  id: string;
  acceptLanguage?: string;
  expand?: 'form' | 'form.events';
}

/**
 * eventsIdIncidentsGet - parameters interface
 */
export interface IEventsIdIncidentsGetParams {
  id: string;
  acceptLanguage?: string;
  groupBy?: 'team';
  direction?: 'asc' | 'desc';
}

/**
 * eventsIdLineupsGet - parameters interface
 */
export interface IEventsIdLineupsGetParams {
  id: number;
  acceptLanguage?: string;
}

/**
 * eventsIdPlayersGet - parameters interface
 */
export interface IEventsIdPlayersGetParams {
  id: string;
  acceptLanguage?: string;
  groupBy?: 'team';
}

/**
 * eventsIdPregameoddsGet - parameters interface
 */
export interface IEventsIdPregameoddsGetParams {
  id: string;
  xOddClient: string;
}

/**
 * eventsLiveGet - parameters interface
 */
export interface IEventsLiveGetParams {
  acceptLanguage?: string;
  groupBy?: 'tournament_season_stage';
}

/**
 * eventsSinceGet - parameters interface
 */
export interface IEventsSinceGetParams {
  acceptLanguage?: string;
  lastUpdate?: Date;
}

/**
 * matchesGet - parameters interface
 */
export interface IMatchesGetParams {
  acceptLanguage?: string;
  fromStartTime?: Date;
  toStartTime?: Date;
  teamIds?: string;
  matchIds?: string;
  tournamentIds?: string;
  stageIds?: string;
  rounds?: string;
  seasonIds?: string;
  statusTypes?: 'finished' | 'notstarted' | 'inprogress' | 'interrupted' | 'cancelled';
  offset?: number;
  limit?: number;
  tournamentOrder?: string;
  refereeId?: string;
  venueId?: string;
  statusCode?: string;
  sortDirection?: 'asc' | 'desc';
}

/**
 * tournamentsSeasonsStagesIdEventsGet - parameters interface
 */
export interface ITournamentsSeasonsStagesIdEventsGetParams {
  id: number;
  round?: string;
  sortDirection?: 'asc' | 'desc';
  acceptLanguage?: string;
}

/**
 * EventsApi - API class
 */
@autoinject()
export class EventsApi extends Api {

  /**
   * Creates a new EventsApi class.
   *
   * @param httpClient The Aurelia HTTP client to be injected.
   * @param authStorage A storage for authentication data.
   */
  constructor(httpClient: HttpClient, authStorage: AuthStorage) {
    super(httpClient, authStorage);
  }

  /**
   * Get a list of events by home and away team id
   * @param params.homeId Filter events with home team id
   * @param params.awayId Filter events with away team id
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   */
  async eventsByTeamsGet(params: IEventsByTeamsGetParams): Promise<Event> {
    // Verify required parameters are set
    this.ensureParamIsSet('eventsByTeamsGet', params, 'homeId');
    this.ensureParamIsSet('eventsByTeamsGet', params, 'awayId');

    // Create URL to call
    const url = `${this.basePath}/events/by_teams`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'home_id': params['homeId'],
        'away_id': params['awayId'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of Events
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.fromTime Filter events, which have a start_time after the specified date, format is RFC 3339
   * @param params.toTime Filter events, which have a start_time before the specified date, format is RFC 3339
   * @param params.groupBy Group events by a specified property. Event models are returned as an &#39;items&#39; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
   * @param params.clientOrder Order matching events for a specific client
   */
  async eventsGet(params: IEventsGetParams): Promise<Array<Event>> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/events`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'from_time': params['fromTime'],
        'to_time': params['toTime'],
        'group_by': params['groupBy'],
        'client_order': params['clientOrder'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.id Unique identifier of the resource.
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.expand Specifies additional information to include with the standing response
   */
  async eventsIdGet(params: IEventsIdGetParams): Promise<Event> {
    // Verify required parameters are set
    this.ensureParamIsSet('eventsIdGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/events/{id}`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'expand': params['expand'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
   * @param params.id Unique identifier of the resource.
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.groupBy Group results by a property. If &#39;team&#39; is used the json object has &#39;home_team&#39; and &#39;away_team&#39;, each containing an array of EventIncident objects
   * @param params.direction Whether to sort the results by ascending or descending order
   */
  async eventsIdIncidentsGet(params: IEventsIdIncidentsGetParams): Promise<Array<EventIncident>> {
    // Verify required parameters are set
    this.ensureParamIsSet('eventsIdIncidentsGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/events/{id}/incidents`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'group_by': params['groupBy'],
        'direction': params['direction'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get lineup information for an event. Includes players, formation and coach
   * @param params.id Event.id for which lineups are requested
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   */
  async eventsIdLineupsGet(params: IEventsIdLineupsGetParams): Promise<Lineup> {
    // Verify required parameters are set
    this.ensureParamIsSet('eventsIdLineupsGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/events/{id}/lineups`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
   * @param params.id Unique identifier of the resource.
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.groupBy Group results by a property. If &#39;team&#39; is used the json object has &#39;home_team&#39; and &#39;away_team&#39;, each containing an array of EventPlayer objects
   */
  async eventsIdPlayersGet(params: IEventsIdPlayersGetParams): Promise<Array<EventPlayer>> {
    // Verify required parameters are set
    this.ensureParamIsSet('eventsIdPlayersGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/events/{id}/players`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'group_by': params['groupBy'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get available pre-game odds for an Event
   * @param params.id Unique identifier of the resource.
   * @param params.xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
   */
  async eventsIdPregameoddsGet(params: IEventsIdPregameoddsGetParams): Promise<Array<Odd>> {
    // Verify required parameters are set
    this.ensureParamIsSet('eventsIdPregameoddsGet', params, 'id');
    this.ensureParamIsSet('eventsIdPregameoddsGet', params, 'xOddClient');

    // Create URL to call
    const url = `${this.basePath}/events/{id}/pregameodds`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      .withHeader('X-Odd-Client', params['xOddClient'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of events which are currently live
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.groupBy Group events by a specified property. Event models are returned as an &#39;items&#39; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
   */
  async eventsLiveGet(params: IEventsLiveGetParams): Promise<Array<Event>> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/events/live`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'group_by': params['groupBy'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of events which have been updated since the specified timestamp
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.lastUpdate Filter events, have been updated after the specified date-time. By default will return updated Events during the last hour
   */
  async eventsSinceGet(params: IEventsSinceGetParams): Promise<Array<Event>> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/events/since`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'last_update': params['lastUpdate'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of matches for team/between teams
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   * @param params.fromStartTime Return matches with start_time &gt;&#x3D; from_start_time. RFC 3339 format
   * @param params.toStartTime Return matches with start_time &lt;&#x3D; from_start_time. RFC 3339 format
   * @param params.teamIds List for team IDs separated by commas. In case of one ID, it will return all matches for a selected team, in case of multiple - it will return matches between selected teams.
   * @param params.matchIds List for match IDs separated by commas.
   * @param params.tournamentIds List for tournament IDs separated by commas.
   * @param params.stageIds List for stage IDs separated by commas.
   * @param params.rounds List for rounds separated by commas.
   * @param params.seasonIds List for season IDs separated by commas.
   * @param params.statusTypes List of status types.
   * @param params.offset Results offset
   * @param params.limit Results limit
   * @param params.tournamentOrder Tournament filtering and ordering.
   * @param params.refereeId Filter matches by referee
   * @param params.venueId Filter matches by venue
   * @param params.statusCode Filter matches by event_status.code
   * @param params.sortDirection Result ordering - asc/desc
   */
  async matchesGet(params: IMatchesGetParams): Promise<Array<Event>> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/matches`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'from_start_time': params['fromStartTime'],
        'to_start_time': params['toStartTime'],
        'team_ids': params['teamIds'],
        'match_ids': params['matchIds'],
        'tournament_ids': params['tournamentIds'],
        'stage_ids': params['stageIds'],
        'rounds': params['rounds'],
        'season_ids': params['seasonIds'],
        'status_types': params['statusTypes'],
        'offset': params['offset'],
        'limit': params['limit'],
        'tournament_order': params['tournamentOrder'],
        'referee_id': params['refereeId'],
        'venue_id': params['venueId'],
        'status_code': params['statusCode'],
        'sort_direction': params['sortDirection'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * Get a list of events which are fixtures in a given TournamentSeasonStage resource
   * @param params.id Unique identifier of the TournamentSeasonStage resource
   * @param params.round Filter the event list by a specific round
   * @param params.sortDirection Sort results by date in ascending or descending order
   * @param params.acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
   */
  async tournamentsSeasonsStagesIdEventsGet(params: ITournamentsSeasonsStagesIdEventsGetParams): Promise<Array<EventsByDate>> {
    // Verify required parameters are set
    this.ensureParamIsSet('tournamentsSeasonsStagesIdEventsGet', params, 'id');

    // Create URL to call
    const url = `${this.basePath}/tournaments/seasons/stages/{id}/events`
      .replace(`{${'id'}}`, encodeURIComponent(`${params['id']}`));

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'round': params['round'],
        'sort_direction': params['sortDirection'],
      })
      .withHeader('Accept-Language', params['acceptLanguage'])
      // Authentication 'basicAuth' required
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

}

