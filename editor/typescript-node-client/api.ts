/**
 * Football API
 * API for accessing various kinds of football data, updated in real time.
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://false';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class BasicPlayerStats extends PlayerStatsExtended {
    /**
    * Player information
    */
    'player': Player;
    /**
    * Player's shirt number during the season
    */
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "Player"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BasicPlayerStats.attributeTypeMap);
    }
}

export class BlacklistDto {
    'id'?: string;
    'key'?: BlacklistKeyDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "BlacklistKeyDto"
        }    ];

    static getAttributeTypeMap() {
        return BlacklistDto.attributeTypeMap;
    }
}

export class BlacklistKeyDto {
    'type'?: BlacklistKeyDto.TypeEnum;
    'entity'?: BlacklistKeyDto.EntityEnum;
    'entityId'?: string;
    'context'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "BlacklistKeyDto.TypeEnum"
        },
        {
            "name": "entity",
            "baseName": "entity",
            "type": "BlacklistKeyDto.EntityEnum"
        },
        {
            "name": "entityId",
            "baseName": "entity_id",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BlacklistKeyDto.attributeTypeMap;
    }
}

export namespace BlacklistKeyDto {
    export enum TypeEnum {
        TRANSLATION = <any> 'TRANSLATION',
        ASSET = <any> 'ASSET',
        RELATION = <any> 'RELATION',
        ENTITY = <any> 'ENTITY'
    }
    export enum EntityEnum {
        TEAM = <any> 'TEAM',
        TOURNAMENT = <any> 'TOURNAMENT',
        SEASON = <any> 'SEASON',
        GROUP = <any> 'GROUP',
        STAGE = <any> 'STAGE',
        COUNTRY = <any> 'COUNTRY',
        PLAYER = <any> 'PLAYER',
        COACH = <any> 'COACH',
        LINEUPPLAYERTYPE = <any> 'LINEUP_PLAYER_TYPE',
        MATCHSTATUS = <any> 'MATCH_STATUS',
        VENUE = <any> 'VENUE',
        REFEREE = <any> 'REFEREE',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        LINEUP = <any> 'LINEUP',
        MATCH = <any> 'MATCH',
        ASSET = <any> 'ASSET',
        STANDINGRULE = <any> 'STANDING_RULE',
        ROUNDTYPE = <any> 'ROUND_TYPE'
    }
}
export class CardlistStandingData extends StandingData {
    /**
    * Information about the Player
    */
    'player': PartialPerson;
    /**
    * Number of red cards
    */
    'redCards': number;
    /**
    * Total number of cards received
    */
    'totalCards': number;
    /**
    * Total number of yellow cards
    */
    'yellowCards': number;
    /**
    * Number of times the Player has been booked, with a first yellow card
    */
    'firstYellowCards': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "PartialPerson"
        },
        {
            "name": "redCards",
            "baseName": "red_cards",
            "type": "number"
        },
        {
            "name": "totalCards",
            "baseName": "total_cards",
            "type": "number"
        },
        {
            "name": "yellowCards",
            "baseName": "yellow_cards",
            "type": "number"
        },
        {
            "name": "firstYellowCards",
            "baseName": "first_yellow_cards",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CardlistStandingData.attributeTypeMap);
    }
}

export class CityDto {
    'id'?: string;
    'name'?: string;
    'country'?: CountryDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "CountryDto"
        }    ];

    static getAttributeTypeMap() {
        return CityDto.attributeTypeMap;
    }
}

export class CityEditDto {
    'name'?: string;
    'countryId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CityEditDto.attributeTypeMap;
    }
}

export class Coach {
    /**
    * 277x338 full body image of Person
    */
    'urlImage'?: string;
    /**
    * Person's nationality
    */
    'country'?: Country;
    /**
    * Date when the person was born
    */
    'birthdate'?: string;
    /**
    * Human readable first(given) name
    */
    'firstName'?: string;
    /**
    * Human readable last(family) name
    */
    'lastName'?: string;
    /**
    * True if currently active, false if retired
    */
    'active'?: boolean;
    /**
    * Person's gender
    */
    'gender'?: Coach.GenderEnum;
    /**
    * Unique identifier within the system
    */
    'id'?: number;
    /**
    * Human readable name of the Person
    */
    'name': string;
    /**
    * 150x150 face image of Person
    */
    'urlThumb'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "urlImage",
            "baseName": "url_image",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "Coach.GenderEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "urlThumb",
            "baseName": "url_thumb",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Coach.attributeTypeMap;
    }
}

export namespace Coach {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class CoachDto {
    'id'?: number;
    'name'?: string;
    'country'?: CountryDto;
    'birthdate'?: string;
    'gender'?: CoachDto.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "CountryDto"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "CoachDto.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return CoachDto.attributeTypeMap;
    }
}

export namespace CoachDto {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class CoachEditDto {
    'name'?: string;
    'countryId'?: string;
    'birthdate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoachEditDto.attributeTypeMap;
    }
}

export class CoachPageDto {
    'coaches'?: Array<CoachDto>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "coaches",
            "baseName": "coaches",
            "type": "Array<CoachDto>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return CoachPageDto.attributeTypeMap;
    }
}

export class Country {
    /**
    * Unique identifier of the object within the system
    */
    'id': number;
    /**
    * Human known name of the Country
    */
    'name': string;
    /**
    * 2 letter country code if available
    */
    'code'?: string;
    /**
    * Image of the flag for the Country
    */
    'urlFlag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "urlFlag",
            "baseName": "url_flag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Country.attributeTypeMap;
    }
}

export class CountryDto {
    'id'?: string;
    'name'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CountryDto.attributeTypeMap;
    }
}

export class Dto {
    'code'?: string;
    'name'?: string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dto.attributeTypeMap;
    }
}

export class Event {
    /**
    * Number of spectators at the event
    */
    'spectators'?: number;
    /**
    * TournamentSeasonStage in which the Event is part of. Should be used for Standing unless the Event is part of a StageGroup
    */
    'tournamentSeasonStage': PartialTournamentSeasonStage;
    /**
    * Live minute ticker. Only available if the event_status.type is 'inprogress'
    */
    'minute'?: number;
    /**
    * Describes the group in which the Event is part of. Available if the Event is from a TournamentSeasonStage which has groups. Example: Champions League Group Stage -> Group A
    */
    'stageGroup'?: StageGroup;
    'referee'?: PartialPerson;
    'venue'?: Venue;
    /**
    * Number of incidents which have occured in the Event (goals, red cards, yellow cards, etc).
    */
    'incidents'?: number;
    /**
    * Indicates whether player lineup information is available or not
    */
    'lineupAvailable'?: boolean;
    /**
    * Indicates whether the event has livescore updates. If false the event will be updated after FT.
    */
    'liveUpdates'?: boolean;
    /**
    * Indicates whether teamstats are available for this event
    */
    'teamstatsAvailable'?: boolean;
    /**
    * Score information at various stages of the Event for Home Team
    */
    'homeScore'?: TeamScore;
    /**
    * Score information at various stages of the Event for Home Team
    */
    'awayScore'?: TeamScore;
    /**
    * timestamp when the current phase (1st_half, 2nd_half, et, etc) has started. Can be used for calculating the minute ticker
    */
    'startedAt'?: Date;
    /**
    * Unique identifier
    */
    'id': number;
    /**
    * Description of the event's current status
    */
    'eventStatus': EventStatus;
    /**
    * Timestamp when the event is scheduled to start
    */
    'startTime': Date;
    /**
    * Goals scored by the home team
    */
    'goalHome'?: number;
    /**
    * Goals scored by the away team
    */
    'goalAway'?: number;
    /**
    * Penalties scored by the home team. Available only if the game goes to penalty shootouts
    */
    'penaltyHome'?: number;
    /**
    * Penalties scored by the away team. Available only if the game goes to penalty shootouts
    */
    'penaltyAway'?: number;
    /**
    * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
    */
    'aggHome'?: number;
    /**
    * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
    */
    'aggAway'?: number;
    /**
    * Home Team
    */
    'homeTeam': PartialTeam;
    /**
    * Away Team
    */
    'awayTeam': PartialTeam;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "spectators",
            "baseName": "spectators",
            "type": "number"
        },
        {
            "name": "tournamentSeasonStage",
            "baseName": "tournament_season_stage",
            "type": "PartialTournamentSeasonStage"
        },
        {
            "name": "minute",
            "baseName": "minute",
            "type": "number"
        },
        {
            "name": "stageGroup",
            "baseName": "stage_group",
            "type": "StageGroup"
        },
        {
            "name": "referee",
            "baseName": "referee",
            "type": "PartialPerson"
        },
        {
            "name": "venue",
            "baseName": "venue",
            "type": "Venue"
        },
        {
            "name": "incidents",
            "baseName": "incidents",
            "type": "number"
        },
        {
            "name": "lineupAvailable",
            "baseName": "lineup_available",
            "type": "boolean"
        },
        {
            "name": "liveUpdates",
            "baseName": "live_updates",
            "type": "boolean"
        },
        {
            "name": "teamstatsAvailable",
            "baseName": "teamstats_available",
            "type": "boolean"
        },
        {
            "name": "homeScore",
            "baseName": "home_score",
            "type": "TeamScore"
        },
        {
            "name": "awayScore",
            "baseName": "away_score",
            "type": "TeamScore"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "eventStatus",
            "baseName": "event_status",
            "type": "EventStatus"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "Date"
        },
        {
            "name": "goalHome",
            "baseName": "goal_home",
            "type": "number"
        },
        {
            "name": "goalAway",
            "baseName": "goal_away",
            "type": "number"
        },
        {
            "name": "penaltyHome",
            "baseName": "penalty_home",
            "type": "number"
        },
        {
            "name": "penaltyAway",
            "baseName": "penalty_away",
            "type": "number"
        },
        {
            "name": "aggHome",
            "baseName": "agg_home",
            "type": "number"
        },
        {
            "name": "aggAway",
            "baseName": "agg_away",
            "type": "number"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "PartialTeam"
        },
        {
            "name": "awayTeam",
            "baseName": "away_team",
            "type": "PartialTeam"
        }    ];

    static getAttributeTypeMap() {
        return Event.attributeTypeMap;
    }
}

export class EventIncident {
    /**
    * Unique identifier
    */
    'id': number;
    /**
    * Identifier of the event during which the incident occurred
    */
    'eventId': number;
    /**
    * The type of incident
    */
    'type': EventIncident.TypeEnum;
    /**
    * Whether the incident is related to the home or away team. true if home team
    */
    'homeTeam': boolean;
    /**
    * The minute when the incident occured
    */
    'minute': number;
    /**
    * Id of the team for which the incident is related
    */
    'teamId'?: number;
    /**
    * Updated home team score if the incident changes the scoreline (penalty, goal, own_goal, etc)
    */
    'goalHome'?: number;
    /**
    * Updated away team score  if the incident changes the scoreline (penalty, goal, own_goal, etc)
    */
    'goalAway'?: number;
    /**
    * Player who is the main actor in the incident: Goal Scorer, player who received yellow card. If type == 'substitution' this is the player coming off
    */
    'player'?: PartialPerson;
    /**
    * Player who is of secondary importance to the incident: Player who assisted a goal. If type == 'substitution' this is the player coming on
    */
    'relPlayer'?: PartialPerson;
    /**
    * Whether the incident has been deleted or not - a disallowed goal for example
    */
    'deleted'?: boolean;
    /**
    * If there are multiple incidents with the same minute, this indicates how they are sorted
    */
    'sortorder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "EventIncident.TypeEnum"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "boolean"
        },
        {
            "name": "minute",
            "baseName": "minute",
            "type": "number"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        },
        {
            "name": "goalHome",
            "baseName": "goal_home",
            "type": "number"
        },
        {
            "name": "goalAway",
            "baseName": "goal_away",
            "type": "number"
        },
        {
            "name": "player",
            "baseName": "player",
            "type": "PartialPerson"
        },
        {
            "name": "relPlayer",
            "baseName": "rel_player",
            "type": "PartialPerson"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "sortorder",
            "baseName": "sortorder",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EventIncident.attributeTypeMap;
    }
}

export namespace EventIncident {
    export enum TypeEnum {
        PenaltyShootoutScored = <any> 'penalty_shootout_scored',
        YellowCardRed = <any> 'yellow_card_red',
        PenaltyShootoutMissed = <any> 'penalty_shootout_missed',
        Substitution = <any> 'substitution',
        Goal = <any> 'goal',
        RedCard = <any> 'red_card',
        PenaltyMiss = <any> 'penalty_miss',
        YellowCard = <any> 'yellow_card',
        PenaltyGoal = <any> 'penalty_goal',
        OwnGoal = <any> 'own_goal'
    }
}
export class EventPlayer {
    /**
    * Unique identifier
    */
    'id': number;
    /**
    * Object describing the player in the lineup
    */
    'player': PartialPerson;
    /**
    * Object describing the type of lineup
    */
    'eventPlayerType': EventPlayerType;
    /**
    * Whether the player is from the home or the away team
    */
    'homeTeam': boolean;
    /**
    * Number indicating the player's vertical position on the field. 1 = Goalkeeper, 2-5 = Defender, 6-9 = Midfielder, 10-11 = Forward, where 5 is an offensive defender, 9 is an offensive midfielder, etc.
    */
    'positionX'?: number;
    /**
    * Number indicating the player's horizontal position on the field. Ranges from 1-9, where 1 = furthest right, 9 = furthest left.
    */
    'positionY'?: number;
    /**
    * Number 1-11 indicating the player's position in the lineup. 1 = goalkeeper, 2 = defender furthest right.
    */
    'positionNumber'?: number;
    /**
    * The shirt number the player is wearing
    */
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "player",
            "baseName": "player",
            "type": "PartialPerson"
        },
        {
            "name": "eventPlayerType",
            "baseName": "event_player_type",
            "type": "EventPlayerType"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "boolean"
        },
        {
            "name": "positionX",
            "baseName": "position_x",
            "type": "number"
        },
        {
            "name": "positionY",
            "baseName": "position_y",
            "type": "number"
        },
        {
            "name": "positionNumber",
            "baseName": "position_number",
            "type": "number"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EventPlayer.attributeTypeMap;
    }
}

export class EventPlayerSubOn {
    /**
    * Id of the player that comes on
    */
    'playerId'?: number;
    /**
    * Name of the player that comes on
    */
    'playerName': string;
    /**
    * The minute when the substitued occured
    */
    'elapsed': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "playerId",
            "baseName": "player_id",
            "type": "number"
        },
        {
            "name": "playerName",
            "baseName": "player_name",
            "type": "string"
        },
        {
            "name": "elapsed",
            "baseName": "elapsed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EventPlayerSubOn.attributeTypeMap;
    }
}

export class EventPlayerType {
    /**
    * Indicates what part of the lineup the player belongs to
    */
    'category': EventPlayerType.CategoryEnum;
    /**
    * Human readable name of the type
    */
    'name': string;
    /**
    * Internal unique code to identify the type
    */
    'code': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "EventPlayerType.CategoryEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventPlayerType.attributeTypeMap;
    }
}

export namespace EventPlayerType {
    export enum CategoryEnum {
        Miss = <any> 'miss',
        Sub = <any> 'sub',
        Start = <any> 'start',
        Unknown = <any> 'unknown'
    }
}
export class EventStatus {
    /**
    * Status classification
    */
    'type': EventStatus.TypeEnum;
    /**
    * Human readable name describing the status, can be translated
    */
    'name': string;
    /**
    * Human readable short name describing the status, can be translated
    */
    'shortName'?: string;
    /**
    * Unique string used to identify the status
    */
    'code': EventStatus.CodeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "EventStatus.TypeEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "EventStatus.CodeEnum"
        }    ];

    static getAttributeTypeMap() {
        return EventStatus.attributeTypeMap;
    }
}

export namespace EventStatus {
    export enum TypeEnum {
        Finished = <any> 'finished',
        Cancelled = <any> 'cancelled',
        Notstarted = <any> 'notstarted',
        Interrupted = <any> 'interrupted',
        Inprogress = <any> 'inprogress'
    }
    export enum CodeEnum {
        Finished = <any> 'finished',
        NotStarted = <any> 'not_started',
        _1stHalf = <any> '1st_half',
        _2ndHalf = <any> '2nd_half'
    }
}
export class EventTeamStats {
    /**
    * The Team whose stats are represented in the object
    */
    'team': PartialTeam;
    /**
    * Whether the stats are for the home or the away team
    */
    'homeTeam': boolean;
    /**
    * Object containing the team statistics
    */
    'statistics': TeamStatistics;
    /**
    * Identifier of the event the stat is related to
    */
    'eventId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "team",
            "baseName": "team",
            "type": "PartialTeam"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "boolean"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "TeamStatistics"
        },
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EventTeamStats.attributeTypeMap;
    }
}

export class EventsByDate {
    'date': string;
    'items': Array<Event>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Event>"
        }    ];

    static getAttributeTypeMap() {
        return EventsByDate.attributeTypeMap;
    }
}

export class LanguageDto {
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LanguageDto.attributeTypeMap;
    }
}

export class LeagueStandingData extends StandingData {
    /**
    * Information about the Team (and TeamForm) in the current rank
    */
    'team'?: PartialTeamWithForm;
    /**
    * Games won
    */
    'wins': number;
    /**
    * Games drawn
    */
    'draws': number;
    /**
    * Total games played
    */
    'played': number;
    /**
    * Number of points
    */
    'points': number;
    /**
    * Games lost
    */
    'defeits': number;
    /**
    * Total number of goals scored
    */
    'goalsFor': number;
    /**
    * Total number of goals conceded
    */
    'goalsAgainst': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "team",
            "baseName": "team",
            "type": "PartialTeamWithForm"
        },
        {
            "name": "wins",
            "baseName": "wins",
            "type": "number"
        },
        {
            "name": "draws",
            "baseName": "draws",
            "type": "number"
        },
        {
            "name": "played",
            "baseName": "played",
            "type": "number"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "defeits",
            "baseName": "defeits",
            "type": "number"
        },
        {
            "name": "goalsFor",
            "baseName": "goals_for",
            "type": "number"
        },
        {
            "name": "goalsAgainst",
            "baseName": "goals_against",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LeagueStandingData.attributeTypeMap);
    }
}

export class Lineup {
    /**
    * Id of the event for which the lineup is for
    */
    'eventId': number;
    /**
    * Whether the lineup is officially confirmed. Should be considered probable if != true
    */
    'confirmed'?: boolean;
    /**
    * Lineup information for home team
    */
    'homeTeam': TeamLineup;
    /**
    * Lineup information for away team
    */
    'awayTeam': TeamLineup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventId",
            "baseName": "event_id",
            "type": "number"
        },
        {
            "name": "confirmed",
            "baseName": "confirmed",
            "type": "boolean"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "TeamLineup"
        },
        {
            "name": "awayTeam",
            "baseName": "away_team",
            "type": "TeamLineup"
        }    ];

    static getAttributeTypeMap() {
        return Lineup.attributeTypeMap;
    }
}

export class ListVenueDto {
    'id'?: string;
    'name'?: string;
    'country'?: CountryDto;
    'city'?: CityDto;
    'profile'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "CountryDto"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "CityDto"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ListVenueDto.attributeTypeMap;
    }
}

export class LiveCommentaryOutputDto {
    'type'?: string;
    'templateText'?: string;
    'autoText'?: string;
    'elapsed'?: number;
    'details'?: Array<any>;
    'incidentTimestamp'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "templateText",
            "baseName": "template_text",
            "type": "string"
        },
        {
            "name": "autoText",
            "baseName": "auto_text",
            "type": "string"
        },
        {
            "name": "elapsed",
            "baseName": "elapsed",
            "type": "number"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<any>"
        },
        {
            "name": "incidentTimestamp",
            "baseName": "incident_timestamp",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return LiveCommentaryOutputDto.attributeTypeMap;
    }
}

export class NotFoundError {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotFoundError.attributeTypeMap;
    }
}

export class Odd {
    /**
    * Reference to the OddProvider which provides the betting offers
    */
    'oddProvider'?: OddProvider;
    /**
    * Id of the event for which odds are provided
    */
    'eventId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oddProvider",
            "baseName": "oddProvider",
            "type": "OddProvider"
        },
        {
            "name": "eventId",
            "baseName": "eventId",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Odd.attributeTypeMap;
    }
}

export class OddProvider {
    /**
    * Resource identifier
    */
    'id': number;
    /**
    * Human readable name of the OddProvider
    */
    'name': string;
    /**
    * Homepage of the OddProvider
    */
    'url'?: string;
    /**
    * Counrty where the OddProvider is based
    */
    'country'?: Country;
    'urlLogo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "urlLogo",
            "baseName": "url_logo",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OddProvider.attributeTypeMap;
    }
}

export class OutputDto {
    'player': PartialPerson;
    'team': PartialTeam;
    'season': TournamentSeason;
    'tournament': Tournament;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "PartialPerson"
        },
        {
            "name": "team",
            "baseName": "team",
            "type": "PartialTeam"
        },
        {
            "name": "season",
            "baseName": "season",
            "type": "TournamentSeason"
        },
        {
            "name": "tournament",
            "baseName": "tournament",
            "type": "Tournament"
        }    ];

    static getAttributeTypeMap() {
        return OutputDto.attributeTypeMap;
    }
}

export class PageMetaDto {
    'total'?: number;
    'offset'?: number;
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PageMetaDto.attributeTypeMap;
    }
}

export class PartialEvent {
    /**
    * Unique identifier
    */
    'id': number;
    /**
    * Description of the event's current status
    */
    'eventStatus': EventStatus;
    /**
    * Timestamp when the event is scheduled to start
    */
    'startTime': Date;
    /**
    * Goals scored by the home team
    */
    'goalHome': number;
    /**
    * Goals scored by the away team
    */
    'goalAway': number;
    /**
    * Penalties scored by the home team. Available only if the game goes to penalty shootouts
    */
    'penaltyHome'?: number;
    /**
    * Penalties scored by the away team. Available only if the game goes to penalty shootouts
    */
    'penaltyAway'?: number;
    /**
    * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
    */
    'aggHome'?: number;
    /**
    * Goals scored by home team over 1 or more legs. Available only if the tie has mutliple legs
    */
    'aggAway'?: number;
    /**
    * Home Team
    */
    'homeTeam': PartialTeam;
    /**
    * Away Team
    */
    'awayTeam': PartialTeam;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "eventStatus",
            "baseName": "event_status",
            "type": "EventStatus"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "Date"
        },
        {
            "name": "goalHome",
            "baseName": "goal_home",
            "type": "number"
        },
        {
            "name": "goalAway",
            "baseName": "goal_away",
            "type": "number"
        },
        {
            "name": "penaltyHome",
            "baseName": "penalty_home",
            "type": "number"
        },
        {
            "name": "penaltyAway",
            "baseName": "penalty_away",
            "type": "number"
        },
        {
            "name": "aggHome",
            "baseName": "agg_home",
            "type": "number"
        },
        {
            "name": "aggAway",
            "baseName": "agg_away",
            "type": "number"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "PartialTeam"
        },
        {
            "name": "awayTeam",
            "baseName": "away_team",
            "type": "PartialTeam"
        }    ];

    static getAttributeTypeMap() {
        return PartialEvent.attributeTypeMap;
    }
}

export class PartialPerson {
    /**
    * Unique identifier within the system
    */
    'id': number;
    /**
    * Human readable name of the Person
    */
    'name': string;
    /**
    * 150x150 face image of Person
    */
    'urlThumb'?: string;
    /**
    * 277x338 full body image of Person
    */
    'urlImage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "urlThumb",
            "baseName": "url_thumb",
            "type": "string"
        },
        {
            "name": "urlImage",
            "baseName": "url_image",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PartialPerson.attributeTypeMap;
    }
}

export class PartialTeam {
    /**
    * Whether the team is a football club(Barcelona) or national team(Spain)
    */
    'national'?: boolean;
    /**
    * Unique identifier of the Team within the system
    */
    'id': number;
    /**
    * Human readable name of the team
    */
    'name': string;
    /**
    * 3 character name of team
    */
    'threeLetterCode'?: string;
    /**
    * Manually inserted short name of team
    */
    'shortName'?: string;
    /**
    * If present and = true, the team can be one of two teams. This occurs in cup competitions when some games are still not played
    */
    'undecided'?: boolean;
    /**
    * Team gender, MALE, FEMALE or null
    */
    'gender'?: PartialTeam.GenderEnum;
    'urlLogo'?: string;
    'type'?: PartialTeam.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "national",
            "baseName": "national",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "threeLetterCode",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "shortName",
            "type": "string"
        },
        {
            "name": "undecided",
            "baseName": "undecided",
            "type": "boolean"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "PartialTeam.GenderEnum"
        },
        {
            "name": "urlLogo",
            "baseName": "url_logo",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "PartialTeam.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return PartialTeam.attributeTypeMap;
    }
}

export namespace PartialTeam {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
    export enum TypeEnum {
        Placeholder = <any> 'placeholder',
        Club = <any> 'club',
        National = <any> 'national'
    }
}
export class PartialTeamWithForm extends PartialTeam {
    /**
    * Form guide for the Team if available and requested as an option
    */
    'form'?: Array<TeamForm>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "form",
            "baseName": "form",
            "type": "Array<TeamForm>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PartialTeamWithForm.attributeTypeMap);
    }
}

export namespace PartialTeamWithForm {
}
export class PartialTournamentSeasonStage {
    /**
    * Unique identifier
    */
    'id': number;
    /**
    * Human readable name of the TournamentSeasonStage
    */
    'name': string;
    /**
    * Whether the stage is a cup such as Champions League Knockout stage, World Cup Final stages, etc
    */
    'cup': boolean;
    /**
    * Id of the TournamentSeason in which the stage is part of
    */
    'tournamentSeasonId': number;
    /**
    * Id of the Tournament in whicth the stage is part of
    */
    'tournamentId': number;
    /**
    * Reference to the Country where the TournamentSeasonStage is held
    */
    'country': Country;
    /**
    * Indicates which confederation the stage is part of (for World Cup qualif.)
    */
    'confederation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "cup",
            "baseName": "cup",
            "type": "boolean"
        },
        {
            "name": "tournamentSeasonId",
            "baseName": "tournament_season_id",
            "type": "number"
        },
        {
            "name": "tournamentId",
            "baseName": "tournament_id",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "confederation",
            "baseName": "confederation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PartialTournamentSeasonStage.attributeTypeMap;
    }
}

export class Player {
    /**
    * Playing position of the player
    */
    'position'?: Player.PositionEnum;
    /**
    * Person's nationality
    */
    'country': Country;
    /**
    * Date when the person was born
    */
    'birthdate'?: string;
    /**
    * Human readable first(given) name
    */
    'firstName'?: string;
    /**
    * Human readable last(family) name
    */
    'lastName'?: string;
    /**
    * True if currently active, false if retired
    */
    'active'?: boolean;
    /**
    * Person's gender
    */
    'gender'?: Player.GenderEnum;
    /**
    * Unique identifier within the system
    */
    'id': number;
    /**
    * Human readable name of the Person
    */
    'name': string;
    /**
    * 150x150 face image of Person
    */
    'urlThumb'?: string;
    /**
    * 277x338 full body image of Person
    */
    'urlImage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "position",
            "baseName": "position",
            "type": "Player.PositionEnum"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "Player.GenderEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "urlThumb",
            "baseName": "url_thumb",
            "type": "string"
        },
        {
            "name": "urlImage",
            "baseName": "url_image",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Player.attributeTypeMap;
    }
}

export namespace Player {
    export enum PositionEnum {
        Keeper = <any> 'keeper',
        Defender = <any> 'defender',
        Midfielder = <any> 'midfielder',
        Forward = <any> 'forward'
    }
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class PlayerDto {
    'id'?: string;
    'name'?: string;
    'country'?: CountryDto;
    'active'?: boolean;
    'birthdate'?: string;
    'birthCity'?: CityDto;
    'profile'?: PlayerProfileDto;
    'social'?: PlayerEditSocialDto;
    'position'?: string;
    'gender'?: PlayerDto.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "CountryDto"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "birthCity",
            "baseName": "birth_city",
            "type": "CityDto"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "PlayerProfileDto"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "PlayerEditSocialDto"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "PlayerDto.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return PlayerDto.attributeTypeMap;
    }
}

export namespace PlayerDto {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class PlayerEditDto {
    'name'?: string;
    'countryId'?: string;
    'active'?: boolean;
    'birthdate'?: string;
    'birthCityId'?: string;
    'profile'?: PlayerProfileDto;
    'social'?: PlayerEditSocialDto;
    'position'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "birthCityId",
            "baseName": "birth_city_id",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "PlayerProfileDto"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "PlayerEditSocialDto"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PlayerEditDto.attributeTypeMap;
    }
}

export class PlayerEditSocialDto {
    'web'?: string;
    'twitterId'?: string;
    'facebookId'?: string;
    'instagramId'?: string;
    'wikipediaId'?: string;
    'youtubeChannelId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "web",
            "baseName": "web",
            "type": "string"
        },
        {
            "name": "twitterId",
            "baseName": "twitter_id",
            "type": "string"
        },
        {
            "name": "facebookId",
            "baseName": "facebook_id",
            "type": "string"
        },
        {
            "name": "instagramId",
            "baseName": "instagram_id",
            "type": "string"
        },
        {
            "name": "wikipediaId",
            "baseName": "wikipedia_id",
            "type": "string"
        },
        {
            "name": "youtubeChannelId",
            "baseName": "youtube_channel_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PlayerEditSocialDto.attributeTypeMap;
    }
}

export class PlayerPageDto {
    'players'?: Array<PlayerDto>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<PlayerDto>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return PlayerPageDto.attributeTypeMap;
    }
}

export class PlayerProfile extends Player {
    /**
    * Information about the current league the player is in
    */
    'currentLeague'?: TournamentSeasonWithTournament;
    /**
    * Information about the club the Player is currently playing in
    */
    'club'?: PlayerTeam;
    /**
    * Information about the national team the Player is currently playing in
    */
    'nationalTeam'?: PlayerTeam;
    /**
    * Display name of the player position
    */
    'positionDisplay'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currentLeague",
            "baseName": "current_league",
            "type": "TournamentSeasonWithTournament"
        },
        {
            "name": "club",
            "baseName": "club",
            "type": "PlayerTeam"
        },
        {
            "name": "nationalTeam",
            "baseName": "nationalTeam",
            "type": "PlayerTeam"
        },
        {
            "name": "positionDisplay",
            "baseName": "position_display",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlayerProfile.attributeTypeMap);
    }
}

export namespace PlayerProfile {
}
export class PlayerProfileDto {
    'height'?: string;
    'weight'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PlayerProfileDto.attributeTypeMap;
    }
}

export class PlayerStatisticItem {
    'name'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PlayerStatisticItem.attributeTypeMap;
    }
}

export class PlayerStatistics extends PlayerStatsExtended {
    'tournamentSeason': TournamentSeasonWithTournament;
    /**
    * Player Information
    */
    'player': PartialPerson;
    /**
    * Team for which the Player competes
    */
    'team': PartialTeam;
    /**
    * Shirt number of the player during the TournamentSeason
    */
    'shirtNumber'?: number;
    /**
    * Position of the player during the TournamentSeason
    */
    'position'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tournamentSeason",
            "baseName": "tournament_season",
            "type": "TournamentSeasonWithTournament"
        },
        {
            "name": "player",
            "baseName": "player",
            "type": "PartialPerson"
        },
        {
            "name": "team",
            "baseName": "team",
            "type": "PartialTeam"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirtNumber",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlayerStatistics.attributeTypeMap);
    }
}

export class PlayerStatsBasic {
    /**
    * Total goals scored
    */
    'goals': number;
    /**
    * Total games played
    */
    'played': number;
    /**
    * Total minutes played
    */
    'minutes': number;
    /**
    * Number of red cards
    */
    'redCards': number;
    /**
    * Number of yellow cards
    */
    'yellowCards': number;
    /**
    * Number of assists
    */
    'assists'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "goals",
            "baseName": "goals",
            "type": "number"
        },
        {
            "name": "played",
            "baseName": "played",
            "type": "number"
        },
        {
            "name": "minutes",
            "baseName": "minutes",
            "type": "number"
        },
        {
            "name": "redCards",
            "baseName": "red_cards",
            "type": "number"
        },
        {
            "name": "yellowCards",
            "baseName": "yellow_cards",
            "type": "number"
        },
        {
            "name": "assists",
            "baseName": "assists",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PlayerStatsBasic.attributeTypeMap;
    }
}

export class PlayerStatsExtended extends PlayerStatsBasic {
    /**
    * Goals conceded (Goalkeeper)
    */
    'conceded'?: number;
    /**
    * Games started as a substitute
    */
    'substitute'?: number;
    /**
    * Games without allowing a goal (Goalkeeper)
    */
    'cleansheets'?: number;
    /**
    * Games where the player has come on
    */
    'substituteIn'?: number;
    /**
    * Games where the player has come off
    */
    'substituteOut'?: number;
    /**
    * Minutes played after coming on as a substitute
    */
    'minutesSubstitute'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "conceded",
            "baseName": "conceded",
            "type": "number"
        },
        {
            "name": "substitute",
            "baseName": "substitute",
            "type": "number"
        },
        {
            "name": "cleansheets",
            "baseName": "cleansheets",
            "type": "number"
        },
        {
            "name": "substituteIn",
            "baseName": "substitute_in",
            "type": "number"
        },
        {
            "name": "substituteOut",
            "baseName": "substitute_out",
            "type": "number"
        },
        {
            "name": "minutesSubstitute",
            "baseName": "minutes_substitute",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlayerStatsExtended.attributeTypeMap);
    }
}

export class PlayerTeam extends TeamPlayerData {
    /**
    * Whether the person is currently part of the Team
    */
    'active'?: boolean;
    /**
    * Date when the Person joined the team
    */
    'startDate'?: string;
    /**
    * Date when the Person left the team (if any)
    */
    'endDate'?: string;
    /**
    * Reference to the Team the player participates in
    */
    'team': PartialTeam;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "team",
            "baseName": "team",
            "type": "PartialTeam"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlayerTeam.attributeTypeMap);
    }
}

export class RefereeDto {
    'id'?: string;
    'name'?: string;
    'country'?: CountryDto;
    'birthdate'?: string;
    'active'?: boolean;
    'gender'?: RefereeDto.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "CountryDto"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "RefereeDto.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return RefereeDto.attributeTypeMap;
    }
}

export namespace RefereeDto {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class RefereeEditDto {
    'name'?: string;
    'countryId'?: string;
    'birthdate'?: Date;
    'active'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "Date"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RefereeEditDto.attributeTypeMap;
    }
}

export class RefereePageDto {
    'referees'?: Array<RefereeDto>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "referees",
            "baseName": "referees",
            "type": "Array<RefereeDto>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return RefereePageDto.attributeTypeMap;
    }
}

export class Round {
    'round': string;
    'startTime': Date;
    'endTime': Date;
    'events'?: Array<PartialEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "round",
            "baseName": "round",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "Date"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<PartialEvent>"
        }    ];

    static getAttributeTypeMap() {
        return Round.attributeTypeMap;
    }
}

export class SeasonDto {
    'id': number;
    'name': string;
    'active': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SeasonDto.attributeTypeMap;
    }
}

export class StageDto {
    'id': number;
    'name': string;
    'cup': boolean;
    'season': SeasonDto;
    'tournament': TournamentDto;
    'startDate'?: string;
    'endDate'?: string;
    'live'?: boolean;
    'stageGroups'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "cup",
            "baseName": "cup",
            "type": "boolean"
        },
        {
            "name": "season",
            "baseName": "season",
            "type": "SeasonDto"
        },
        {
            "name": "tournament",
            "baseName": "tournament",
            "type": "TournamentDto"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "live",
            "baseName": "live",
            "type": "boolean"
        },
        {
            "name": "stageGroups",
            "baseName": "stage_groups",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StageDto.attributeTypeMap;
    }
}

export class StageGroup {
    /**
    * Unique resource identifier
    */
    'id': number;
    /**
    * Human readable name of the Group
    */
    'name': string;
    /**
    * The order in the stage of the group
    */
    'orderInStage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orderInStage",
            "baseName": "order_in_stage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StageGroup.attributeTypeMap;
    }
}

export class StageGroupWithStanding extends StageGroup {
    /**
    * League Standing for the StageGroup if available and requested
    */
    'standing'?: Array<LeagueStandingData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "standing",
            "baseName": "standing",
            "type": "Array<LeagueStandingData>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StageGroupWithStanding.attributeTypeMap);
    }
}

export class StageGroupWithStandingTournamentSeasonStage extends StageGroupWithStanding {
    /**
    * Reference to the TournamentSeasonStage the group is a part of
    */
    'tournamentSeasonStage': TournamentSeasonStage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tournamentSeasonStage",
            "baseName": "tournament_season_stage",
            "type": "TournamentSeasonStage"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StageGroupWithStandingTournamentSeasonStage.attributeTypeMap);
    }
}

export class StandingData {
    /**
    * Position of the team/player in the standing
    */
    'rank': number;
    /**
    * Reference to the team in the Standing (for league) or the Team for which the Player competes (topscorer, cardlist)
    */
    'team': PartialTeam;
    /**
    * List of applicable rules to the current standing rank
    */
    'rules'?: Array<StandingRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        },
        {
            "name": "team",
            "baseName": "team",
            "type": "PartialTeam"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<StandingRule>"
        }    ];

    static getAttributeTypeMap() {
        return StandingData.attributeTypeMap;
    }
}

export class StandingRule {
    /**
    * Human readable name describing the standing rule
    */
    'name': string;
    /**
    * Unique code identifying the standing rule
    */
    'code': string;
    /**
    * Type classification of the standing rule
    */
    'type': StandingRule.TypeEnum;
    /**
    * Detailed description of the standing rule
    */
    'description'?: string;
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "StandingRule.TypeEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StandingRule.attributeTypeMap;
    }
}

export namespace StandingRule {
    export enum TypeEnum {
        Promotion = <any> 'promotion',
        PromotionPlayoff = <any> 'promotion_playoff',
        Relegation = <any> 'relegation',
        RelegationPlayoff = <any> 'relegation_playoff',
        Tiertwo = <any> 'tiertwo',
        TiertwoPlayoff = <any> 'tiertwo_playoff'
    }
}
export class Team {
    /**
    * Reference to the Country where the team is based.
    */
    'country': Country;
    /**
    * Name of the president of the club
    */
    'president'?: string;
    /**
    * Year the club was founded
    */
    'founded'?: number;
    'venue'?: Venue;
    'coach'?: Coach;
    /**
    * Information about the League the team currently participates in
    */
    'currentLeague'?: TournamentSeasonWithTournament;
    /**
    * The next event the team is playing in
    */
    'nextEvent'?: Event;
    /**
    * Various social links for the team
    */
    'social'?: any;
    'urlHomeKit'?: string;
    'urlAwayKit'?: string;
    /**
    * Image of the team squad
    */
    'urlSquadImage'?: string;
    /**
    * Whether the team is a football club(Barcelona) or national team(Spain)
    */
    'national': boolean;
    /**
    * Unique identifier of the Team within the system
    */
    'id': number;
    /**
    * Human readable name of the team
    */
    'name': string;
    /**
    * 3 character name of team
    */
    'threeLetterCode'?: string;
    /**
    * Manually inserted short name of team
    */
    'shortName'?: string;
    /**
    * If present and = true, the team can be one of two teams. This occurs in cup competitions when some games are still not played
    */
    'undecided'?: boolean;
    /**
    * Team gender, MALE, FEMALE or null
    */
    'gender'?: Team.GenderEnum;
    /**
    * Form guide for the Team if available and requested as an option
    */
    'form'?: Array<TeamForm>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "president",
            "baseName": "president",
            "type": "string"
        },
        {
            "name": "founded",
            "baseName": "founded",
            "type": "number"
        },
        {
            "name": "venue",
            "baseName": "venue",
            "type": "Venue"
        },
        {
            "name": "coach",
            "baseName": "coach",
            "type": "Coach"
        },
        {
            "name": "currentLeague",
            "baseName": "current_league",
            "type": "TournamentSeasonWithTournament"
        },
        {
            "name": "nextEvent",
            "baseName": "next_event",
            "type": "Event"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "any"
        },
        {
            "name": "urlHomeKit",
            "baseName": "url_home_kit",
            "type": "string"
        },
        {
            "name": "urlAwayKit",
            "baseName": "url_away_kit",
            "type": "string"
        },
        {
            "name": "urlSquadImage",
            "baseName": "url_squad_image",
            "type": "string"
        },
        {
            "name": "national",
            "baseName": "national",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "threeLetterCode",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "shortName",
            "type": "string"
        },
        {
            "name": "undecided",
            "baseName": "undecided",
            "type": "boolean"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "Team.GenderEnum"
        },
        {
            "name": "form",
            "baseName": "form",
            "type": "Array<TeamForm>"
        }    ];

    static getAttributeTypeMap() {
        return Team.attributeTypeMap;
    }
}

export namespace Team {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class TeamEditDto {
    'name': string;
    'threeLetterCode'?: string;
    'shortName'?: string;
    'type': string;
    'countryId': string;
    'venueId'?: string;
    'presidentId'?: string;
    'coachId'?: string;
    'social'?: TeamSocialDto;
    'founded'?: number;
    'gender'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "three_letter_code",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "venueId",
            "baseName": "venue_id",
            "type": "string"
        },
        {
            "name": "presidentId",
            "baseName": "president_id",
            "type": "string"
        },
        {
            "name": "coachId",
            "baseName": "coach_id",
            "type": "string"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "TeamSocialDto"
        },
        {
            "name": "founded",
            "baseName": "founded",
            "type": "number"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamEditDto.attributeTypeMap;
    }
}

export class TeamForm {
    /**
    * Information about the Event in the Form guide
    */
    'event'?: PartialEvent;
    /**
    * Indicates outcome of the event for the given team
    */
    'outcome': TeamForm.OutcomeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "event",
            "baseName": "event",
            "type": "PartialEvent"
        },
        {
            "name": "outcome",
            "baseName": "outcome",
            "type": "TeamForm.OutcomeEnum"
        }    ];

    static getAttributeTypeMap() {
        return TeamForm.attributeTypeMap;
    }
}

export namespace TeamForm {
    export enum OutcomeEnum {
        W = <any> 'W',
        D = <any> 'D',
        L = <any> 'L'
    }
}
export class TeamLineup {
    /**
    * resource id of the team
    */
    'teamId'?: number;
    /**
    * List of players involved for the team
    */
    'players'?: Array<EventPlayer>;
    /**
    * Information about the team's Coach
    */
    'coach'?: PartialPerson;
    /**
    * Lineup formation
    */
    'formation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        },
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<EventPlayer>"
        },
        {
            "name": "coach",
            "baseName": "coach",
            "type": "PartialPerson"
        },
        {
            "name": "formation",
            "baseName": "formation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamLineup.attributeTypeMap;
    }
}

export class TeamPageDto {
    'teams'?: Array<V2Team>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teams",
            "baseName": "teams",
            "type": "Array<V2Team>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return TeamPageDto.attributeTypeMap;
    }
}

export class TeamPlayer extends TeamPlayerData {
    /**
    * Whether the person is currently part of the Team
    */
    'active'?: boolean;
    /**
    * Date when the Person joined the team
    */
    'startDate'?: string;
    /**
    * Date when the Person left the team (if any)
    */
    'endDate'?: string;
    /**
    * Information for the Player
    */
    'player': Player;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "player",
            "baseName": "player",
            "type": "Player"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TeamPlayer.attributeTypeMap);
    }
}

export class TeamPlayerData {
    /**
    * Shirt number which the player wears for the team
    */
    'shirtNumber'?: number;
    /**
    * Whether the player is on loan with the team
    */
    'loan'?: boolean;
    /**
    * Whether the person is currently part of the Team
    */
    'active': boolean;
    /**
    * Date when the Person joined the team
    */
    'startDate'?: string;
    /**
    * Date when the Person left the team (if any)
    */
    'endDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        },
        {
            "name": "loan",
            "baseName": "loan",
            "type": "boolean"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamPlayerData.attributeTypeMap;
    }
}

export class TeamPlayerSeasonStatistics extends TournamentSeasonWithTournament {
    'items'?: Array<TeamPlayerStatistics>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<TeamPlayerStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TeamPlayerSeasonStatistics.attributeTypeMap);
    }
}

export class TeamPlayerStatistics extends PlayerStatsExtended {
    'player': Player;
    'team'?: Team;
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "Player"
        },
        {
            "name": "team",
            "baseName": "team",
            "type": "Team"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TeamPlayerStatistics.attributeTypeMap);
    }
}

export class TeamScore {
    /**
    * Score at the halftime break
    */
    'halfTime'?: number;
    /**
    * Score in regular time + injury time
    */
    'ordinaryTime'?: number;
    /**
    * Score in extra time, does not include the score for ordinary time
    */
    'extraTime'?: number;
    /**
    * Score in penalty shootout, does not include ordinarytime or extratime
    */
    'penaltyShootout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "halfTime",
            "baseName": "half_time",
            "type": "number"
        },
        {
            "name": "ordinaryTime",
            "baseName": "ordinary_time",
            "type": "number"
        },
        {
            "name": "extraTime",
            "baseName": "extra_time",
            "type": "number"
        },
        {
            "name": "penaltyShootout",
            "baseName": "penalty_shootout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TeamScore.attributeTypeMap;
    }
}

export class TeamSeasonStatistics {
    'teamId'?: number;
    /**
    * Latest league stage during the TournamentSeason
    */
    'latestLeagueStage'?: TournamentSeasonStage;
    /**
    * Player statistics for the TournamentSeason
    */
    'playerStatistics'?: Array<BasicPlayerStats>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        },
        {
            "name": "latestLeagueStage",
            "baseName": "latest_league_stage",
            "type": "TournamentSeasonStage"
        },
        {
            "name": "playerStatistics",
            "baseName": "player_statistics",
            "type": "Array<BasicPlayerStats>"
        }    ];

    static getAttributeTypeMap() {
        return TeamSeasonStatistics.attributeTypeMap;
    }
}

export class TeamSocialDto {
    'web'?: string;
    'twitterId'?: string;
    'facebookId'?: string;
    'instagramId'?: string;
    'wikipediaId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "web",
            "baseName": "web",
            "type": "string"
        },
        {
            "name": "twitterId",
            "baseName": "twitter_id",
            "type": "string"
        },
        {
            "name": "facebookId",
            "baseName": "facebook_id",
            "type": "string"
        },
        {
            "name": "instagramId",
            "baseName": "instagram_id",
            "type": "string"
        },
        {
            "name": "wikipediaId",
            "baseName": "wikipedia_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamSocialDto.attributeTypeMap;
    }
}

export class TeamStatistics {
    /**
    * Number of keys passes completed
    */
    'pass'?: number;
    /**
    * Percentage of time the team possess the ball
    */
    'possession': number;
    /**
    * Number of goals scored
    */
    'goals': number;
    /**
    * Number of corners
    */
    'corners': number;
    /**
    * Number of crosses
    */
    'crosses'?: number;
    /**
    * Number of offsides
    */
    'offside': number;
    /**
    * Shots on that have hit target
    */
    'shotsOn': number;
    /**
    * Number of shots that have been blocked by an opposition player
    */
    'shotsBlocked': number;
    /**
    * Shots outside the target
    */
    'shotsOff': number;
    /**
    * Number of throw ins taken
    */
    'throwIn'?: number;
    /**
    * Number of goal kicks taken
    */
    'goalKicks'?: number;
    /**
    * Number of treatments to injuries
    */
    'treatments'?: number;
    /**
    * Total numer of yellow cards
    */
    'yellowCards'?: number;
    /**
    * Number of substitutions
    */
    'substitutions'?: number;
    /**
    * Number of counter attacks
    */
    'counterAttacks'?: number;
    /**
    * Total number of fouls committed by the Team
    */
    'foulsCommitted': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pass",
            "baseName": "pass",
            "type": "number"
        },
        {
            "name": "possession",
            "baseName": "possession",
            "type": "number"
        },
        {
            "name": "goals",
            "baseName": "goals",
            "type": "number"
        },
        {
            "name": "corners",
            "baseName": "corners",
            "type": "number"
        },
        {
            "name": "crosses",
            "baseName": "crosses",
            "type": "number"
        },
        {
            "name": "offside",
            "baseName": "offside",
            "type": "number"
        },
        {
            "name": "shotsOn",
            "baseName": "shots_on",
            "type": "number"
        },
        {
            "name": "shotsBlocked",
            "baseName": "shots_blocked",
            "type": "number"
        },
        {
            "name": "shotsOff",
            "baseName": "shots_off",
            "type": "number"
        },
        {
            "name": "throwIn",
            "baseName": "throw_in",
            "type": "number"
        },
        {
            "name": "goalKicks",
            "baseName": "goal_kicks",
            "type": "number"
        },
        {
            "name": "treatments",
            "baseName": "treatments",
            "type": "number"
        },
        {
            "name": "yellowCards",
            "baseName": "yellow_cards",
            "type": "number"
        },
        {
            "name": "substitutions",
            "baseName": "substitutions",
            "type": "number"
        },
        {
            "name": "counterAttacks",
            "baseName": "counter_attacks",
            "type": "number"
        },
        {
            "name": "foulsCommitted",
            "baseName": "fouls_committed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TeamStatistics.attributeTypeMap;
    }
}

export class TopscorerStandingData extends StandingData {
    /**
    * Information about the Player
    */
    'player': PartialPerson;
    /**
    * Number of goals scored
    */
    'goals': number;
    /**
    * Total games played
    */
    'played'?: number;
    /**
    * Number of assists
    */
    'assists'?: number;
    /**
    * Total number of minutes played
    */
    'minutes'?: number;
    /**
    * Number of goals scored from the penalty spot
    */
    'penalties'?: number;
    /**
    * Number of red cards
    */
    'redCards'?: number;
    /**
    * Number of times the player scored first for the team
    */
    'scoredFirst'?: number;
    /**
    * Number of yellow cards
    */
    'yellowCards'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "PartialPerson"
        },
        {
            "name": "goals",
            "baseName": "goals",
            "type": "number"
        },
        {
            "name": "played",
            "baseName": "played",
            "type": "number"
        },
        {
            "name": "assists",
            "baseName": "assists",
            "type": "number"
        },
        {
            "name": "minutes",
            "baseName": "minutes",
            "type": "number"
        },
        {
            "name": "penalties",
            "baseName": "penalties",
            "type": "number"
        },
        {
            "name": "redCards",
            "baseName": "red_cards",
            "type": "number"
        },
        {
            "name": "scoredFirst",
            "baseName": "scored_first",
            "type": "number"
        },
        {
            "name": "yellowCards",
            "baseName": "yellow_cards",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TopscorerStandingData.attributeTypeMap);
    }
}

/**
* Resource representing a Football Tournament such as A Grupa, Premier League, Champions League, World Cup, etc. Does not represent a specific season such as Premier League 2015/2016.
*/
export class Tournament {
    /**
    * Unique Resource identifier of the Tournament
    */
    'id': number;
    /**
    * Human readable name of the Tournament
    */
    'name': string;
    /**
    * Country where the Tournament is held
    */
    'country': Country;
    /**
    * Whether or not the Tournament is a regional league such as the La Liga, A PFG, EPL.
    */
    'regionalLeague'?: boolean;
    /**
    * Represents the order position in a custom client based sorted list
    */
    'clientSortorder'?: number;
    'urlLogo'?: string;
    /**
    * Shows if the tournament is Cup or a League
    */
    'type'?: any;
    /**
    * Shows if the the teams in the tournament are Male or Female
    */
    'gender'?: any;
    /**
    * Shows if the tournament is Regional or International
    */
    'region'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "regionalLeague",
            "baseName": "regional_league",
            "type": "boolean"
        },
        {
            "name": "clientSortorder",
            "baseName": "client_sortorder",
            "type": "number"
        },
        {
            "name": "urlLogo",
            "baseName": "url_logo",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "any"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "any"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Tournament.attributeTypeMap;
    }
}

/**
* Resource representing a Football Tournament such as A Grupa, Premier League, Champions League, World Cup, etc. Does not represent a specific season such as Premier League 2015/2016.
*/
export class TournamentDto {
    'id': number;
    'name': string;
    'country': V1CountryDto;
    'regionalLeague'?: boolean;
    'urlLogo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V1CountryDto"
        },
        {
            "name": "regionalLeague",
            "baseName": "regional_league",
            "type": "boolean"
        },
        {
            "name": "urlLogo",
            "baseName": "url_logo",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TournamentDto.attributeTypeMap;
    }
}

export class TournamentItemDto {
    'tournamentId'?: string;
    'sortOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tournamentId",
            "baseName": "tournament_id",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TournamentItemDto.attributeTypeMap;
    }
}

export class TournamentSeason {
    /**
    * Unique identifier of the object
    */
    'id': number;
    /**
    * Human readable name of the TournamentSeason
    */
    'name': string;
    /**
    * Whether the season is currently running or whether it is finished
    */
    'active': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TournamentSeason.attributeTypeMap;
    }
}

export class TournamentSeasonStage {
    /**
    * Date when the first game of the stage is held
    */
    'startDate'?: string;
    /**
    * Date when the final game of the stage is held
    */
    'endDate'?: string;
    /**
    * Whether the stage is a qualification stage to a main Tournrament (Champions League Qualification)
    */
    'qualification'?: boolean;
    /**
    * Whether the API has live scores for the stage
    */
    'live'?: boolean;
    /**
    * Number of groups in the stage. Only available if the stage has groups (Champions League Group Stage)
    */
    'stageGroups'?: number;
    /**
    * League standing data if available and if cup = false
    */
    'standing'?: Array<LeagueStandingData>;
    /**
    * List of rounds in the Stage if cup = true
    */
    'rounds'?: Array<Round>;
    /**
    * Unique identifier
    */
    'id': number;
    /**
    * Human readable name of the TournamentSeasonStage
    */
    'name': string;
    /**
    * Whether the stage is a cup such as Champions League Knockout stage, World Cup Final stages, etc
    */
    'cup': boolean;
    /**
    * Id of the TournamentSeason in which the stage is part of
    */
    'tournamentSeasonId': number;
    /**
    * Id of the Tournament in whicth the stage is part of
    */
    'tournamentId': number;
    /**
    * Reference to the Country where the TournamentSeasonStage is held
    */
    'country': Country;
    /**
    * Indicates which confederation the stage is part of (for World Cup qualif.)
    */
    'confederation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "qualification",
            "baseName": "qualification",
            "type": "boolean"
        },
        {
            "name": "live",
            "baseName": "live",
            "type": "boolean"
        },
        {
            "name": "stageGroups",
            "baseName": "stage_groups",
            "type": "number"
        },
        {
            "name": "standing",
            "baseName": "standing",
            "type": "Array<LeagueStandingData>"
        },
        {
            "name": "rounds",
            "baseName": "rounds",
            "type": "Array<Round>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "cup",
            "baseName": "cup",
            "type": "boolean"
        },
        {
            "name": "tournamentSeasonId",
            "baseName": "tournament_season_id",
            "type": "number"
        },
        {
            "name": "tournamentId",
            "baseName": "tournament_id",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "confederation",
            "baseName": "confederation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TournamentSeasonStage.attributeTypeMap;
    }
}

export class TournamentSeasonStageWithStandingGroups extends TournamentSeasonStage {
    /**
    * Unique identifier
    */
    'id'?: number;
    /**
    * Human readable name of the TournamentSeasonStage
    */
    'name'?: string;
    /**
    * Whether the stage is a cup such as Champions League Knockout stage, World Cup Final stages, etc
    */
    'cup'?: boolean;
    /**
    * Id of the TournamentSeason in which the stage is part of
    */
    'tournamentSeasonId'?: number;
    /**
    * Id of the Tournament in whicth the stage is part of
    */
    'tournamentId'?: number;
    /**
    * Reference to the Country where the TournamentSeasonStage is held
    */
    'country'?: Country;
    /**
    * Indicates which confederation the stage is part of (for World Cup qualif.)
    */
    'confederation'?: string;
    /**
    * List of StageGroup objects in the TournamentSeasonStage. Available if the property stage_groups exists
    */
    'groups'?: Array<StageGroupWithStanding>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "cup",
            "baseName": "cup",
            "type": "boolean"
        },
        {
            "name": "tournamentSeasonId",
            "baseName": "tournament_season_id",
            "type": "number"
        },
        {
            "name": "tournamentId",
            "baseName": "tournament_id",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "confederation",
            "baseName": "confederation",
            "type": "string"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<StageGroupWithStanding>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TournamentSeasonStageWithStandingGroups.attributeTypeMap);
    }
}

export class TournamentSeasonWithStages extends TournamentSeasonWithTournament {
    /**
    * List of stages which take place during the TournamentSeason. If the parent Tournament has regional_league = true, this will usually be one stage with cup = false.
    */
    'stages': Array<TournamentSeasonStage>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stages",
            "baseName": "stages",
            "type": "Array<TournamentSeasonStage>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TournamentSeasonWithStages.attributeTypeMap);
    }
}

export class TournamentSeasonWithTournament extends TournamentSeason {
    /**
    * Reference to the parent Tournament
    */
    'tournament': Tournament;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tournament",
            "baseName": "tournament",
            "type": "Tournament"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TournamentSeasonWithTournament.attributeTypeMap);
    }
}

export class TournamentWithSeasons extends Tournament {
    /**
    * List of seasons available for the Tournament
    */
    'seasons': Array<TournamentSeason>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "seasons",
            "baseName": "seasons",
            "type": "Array<TournamentSeason>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TournamentWithSeasons.attributeTypeMap);
    }
}

export class TranslationContentDto {
    'name'?: string;
    'threeLetterCode'?: string;
    'shortName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "three_letter_code",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TranslationContentDto.attributeTypeMap;
    }
}

export class TranslationDto {
    'key'?: TranslationKeyDto;
    'content'?: TranslationContentDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "TranslationKeyDto"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "TranslationContentDto"
        }    ];

    static getAttributeTypeMap() {
        return TranslationDto.attributeTypeMap;
    }
}

export class TranslationEntityDto {
    'entity'?: TranslationEntityDto.EntityEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "entity",
            "type": "TranslationEntityDto.EntityEnum"
        }    ];

    static getAttributeTypeMap() {
        return TranslationEntityDto.attributeTypeMap;
    }
}

export namespace TranslationEntityDto {
    export enum EntityEnum {
        LINEUPPLAYERTYPE = <any> 'LINEUP_PLAYER_TYPE',
        COACH = <any> 'COACH',
        VENUE = <any> 'VENUE',
        TOURNAMENT = <any> 'TOURNAMENT',
        TEAM = <any> 'TEAM',
        COUNTRY = <any> 'COUNTRY',
        MATCHSTATUS = <any> 'MATCH_STATUS',
        STAGE = <any> 'STAGE',
        PLAYER = <any> 'PLAYER',
        REFEREE = <any> 'REFEREE',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STANDINGRULE = <any> 'STANDING_RULE',
        GROUP = <any> 'GROUP',
        SEASON = <any> 'SEASON',
        ROUNDTYPE = <any> 'ROUND_TYPE'
    }
}
export class TranslationKeyDto {
    'entity'?: TranslationKeyDto.EntityEnum;
    'entityId'?: string;
    'language'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "entity",
            "type": "TranslationKeyDto.EntityEnum"
        },
        {
            "name": "entityId",
            "baseName": "entity_id",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TranslationKeyDto.attributeTypeMap;
    }
}

export namespace TranslationKeyDto {
    export enum EntityEnum {
        LINEUPPLAYERTYPE = <any> 'LINEUP_PLAYER_TYPE',
        COACH = <any> 'COACH',
        VENUE = <any> 'VENUE',
        TOURNAMENT = <any> 'TOURNAMENT',
        TEAM = <any> 'TEAM',
        COUNTRY = <any> 'COUNTRY',
        MATCHSTATUS = <any> 'MATCH_STATUS',
        STAGE = <any> 'STAGE',
        PLAYER = <any> 'PLAYER',
        REFEREE = <any> 'REFEREE',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STANDINGRULE = <any> 'STANDING_RULE',
        GROUP = <any> 'GROUP',
        SEASON = <any> 'SEASON',
        ROUNDTYPE = <any> 'ROUND_TYPE'
    }
}
export class V1CountryDto {
    'id': number;
    'name': string;
    'urlFlag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "urlFlag",
            "baseName": "url_flag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1CountryDto.attributeTypeMap;
    }
}

export class V2ActiveClubsInput {
    'clubs'?: Array<V2ActiveTeamInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clubs",
            "baseName": "clubs",
            "type": "Array<V2ActiveTeamInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2ActiveClubsInput.attributeTypeMap;
    }
}

export class V2ActiveTeamInput {
    'teamId'?: string;
    'contractType'?: string;
    'startDate'?: string;
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "contractType",
            "baseName": "contract_type",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2ActiveTeamInput.attributeTypeMap;
    }
}

export class V2Asset {
    'entity'?: string;
    'entityId'?: string;
    'type'?: string;
    'path'?: string;
    'contextType'?: string;
    'contextId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "entity",
            "type": "string"
        },
        {
            "name": "entityId",
            "baseName": "entity_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "contextType",
            "baseName": "context_type",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2Asset.attributeTypeMap;
    }
}

export class V2AssetCollection {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return V2AssetCollection.attributeTypeMap;
    }
}

export class V2AssetDeleteInput {
    'entity'?: string;
    'entityId'?: string;
    'type'?: string;
    'contextType'?: string;
    'contextId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "entity",
            "type": "string"
        },
        {
            "name": "entityId",
            "baseName": "entity_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "contextType",
            "baseName": "context_type",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2AssetDeleteInput.attributeTypeMap;
    }
}

export class V2AssetInput {
    'entity'?: string;
    'entityId'?: string;
    'type'?: string;
    'path'?: string;
    'contextType'?: string;
    'contextId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "entity",
            "type": "string"
        },
        {
            "name": "entityId",
            "baseName": "entity_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "contextType",
            "baseName": "context_type",
            "type": "string"
        },
        {
            "name": "contextId",
            "baseName": "context_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2AssetInput.attributeTypeMap;
    }
}

export class V2City {
    'id'?: string;
    'name'?: string;
    'country'?: V2Country;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        }    ];

    static getAttributeTypeMap() {
        return V2City.attributeTypeMap;
    }
}

export class V2Coach {
    'id'?: string;
    'name'?: string;
    'country'?: V2Country;
    'birthdate'?: string;
    'gender'?: V2Coach.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2Coach.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2Coach.attributeTypeMap;
    }
}

export namespace V2Coach {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class V2Country {
    'id'?: string;
    'name'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2Country.attributeTypeMap;
    }
}

export class V2Group {
    'id'?: string;
    'name'?: string;
    'orderInStage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orderInStage",
            "baseName": "order_in_stage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2Group.attributeTypeMap;
    }
}

export class V2KnockoutEdgeRound {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2KnockoutEdgeRound.attributeTypeMap;
    }
}

export class V2KnockoutGroup {
    'id'?: string;
    'order'?: number;
    'teams'?: Array<V2KnockoutTeam>;
    'matches'?: Array<V2KnockoutMatch>;
    'childObjectId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "number"
        },
        {
            "name": "teams",
            "baseName": "teams",
            "type": "Array<V2KnockoutTeam>"
        },
        {
            "name": "matches",
            "baseName": "matches",
            "type": "Array<V2KnockoutMatch>"
        },
        {
            "name": "childObjectId",
            "baseName": "child_object_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2KnockoutGroup.attributeTypeMap;
    }
}

export class V2KnockoutMatch {
    'id'?: string;
    'kickoffTime'?: Date;
    'score'?: V2MatchScore;
    'homeTeamId'?: string;
    'awayTeamId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "kickoffTime",
            "baseName": "kickoff_time",
            "type": "Date"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "V2MatchScore"
        },
        {
            "name": "homeTeamId",
            "baseName": "home_team_id",
            "type": "string"
        },
        {
            "name": "awayTeamId",
            "baseName": "away_team_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2KnockoutMatch.attributeTypeMap;
    }
}

export class V2KnockoutRound {
    'name'?: string;
    'groups'?: Array<V2KnockoutGroup>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<V2KnockoutGroup>"
        }    ];

    static getAttributeTypeMap() {
        return V2KnockoutRound.attributeTypeMap;
    }
}

export class V2KnockoutScheme {
    'startRound'?: V2KnockoutEdgeRound;
    'endRound'?: V2KnockoutEdgeRound;
    'smallFinal'?: boolean;
    'stage'?: V2MatchStage;
    'rounds'?: Array<V2KnockoutRound>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startRound",
            "baseName": "start_round",
            "type": "V2KnockoutEdgeRound"
        },
        {
            "name": "endRound",
            "baseName": "end_round",
            "type": "V2KnockoutEdgeRound"
        },
        {
            "name": "smallFinal",
            "baseName": "small_final",
            "type": "boolean"
        },
        {
            "name": "stage",
            "baseName": "stage",
            "type": "V2MatchStage"
        },
        {
            "name": "rounds",
            "baseName": "rounds",
            "type": "Array<V2KnockoutRound>"
        }    ];

    static getAttributeTypeMap() {
        return V2KnockoutScheme.attributeTypeMap;
    }
}

export class V2KnockoutTeam {
    'id'?: string;
    'name'?: string;
    'threeLetterCode'?: string;
    'gender'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "three_letter_code",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2KnockoutTeam.attributeTypeMap;
    }
}

export class V2LeagueEntryInput {
    'rank'?: number;
    'teamId'?: string;
    'played'?: number;
    'wins'?: number;
    'draws'?: number;
    'losses'?: number;
    'points'?: number;
    'goalsFor'?: number;
    'goalsAgainst'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "played",
            "baseName": "played",
            "type": "number"
        },
        {
            "name": "wins",
            "baseName": "wins",
            "type": "number"
        },
        {
            "name": "draws",
            "baseName": "draws",
            "type": "number"
        },
        {
            "name": "losses",
            "baseName": "losses",
            "type": "number"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "goalsFor",
            "baseName": "goals_for",
            "type": "number"
        },
        {
            "name": "goalsAgainst",
            "baseName": "goals_against",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2LeagueEntryInput.attributeTypeMap;
    }
}

export class V2LeagueStandingInput {
    'entries'?: Array<V2LeagueEntryInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entries",
            "baseName": "entries",
            "type": "Array<V2LeagueEntryInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2LeagueStandingInput.attributeTypeMap;
    }
}

export class V2Lineup {
    'matchId'?: string;
    'status'?: V2Lineup.StatusEnum;
    'homeTeam'?: V2LineupTeamDto;
    'awayTeam'?: V2LineupTeamDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "V2Lineup.StatusEnum"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "V2LineupTeamDto"
        },
        {
            "name": "awayTeam",
            "baseName": "away_team",
            "type": "V2LineupTeamDto"
        }    ];

    static getAttributeTypeMap() {
        return V2Lineup.attributeTypeMap;
    }
}

export namespace V2Lineup {
    export enum StatusEnum {
        CONFIRMED = <any> 'CONFIRMED',
        UNCONFIRMED = <any> 'UNCONFIRMED',
        NOTAVAILABLE = <any> 'NOT_AVAILABLE'
    }
}
export class V2LineupInput {
    'status'?: V2LineupInput.StatusEnum;
    'homeTeam'?: V2LineupTeamInput;
    'awayTeam'?: V2LineupTeamInput;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "V2LineupInput.StatusEnum"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "V2LineupTeamInput"
        },
        {
            "name": "awayTeam",
            "baseName": "away_team",
            "type": "V2LineupTeamInput"
        }    ];

    static getAttributeTypeMap() {
        return V2LineupInput.attributeTypeMap;
    }
}

export namespace V2LineupInput {
    export enum StatusEnum {
        CONFIRMED = <any> 'CONFIRMED',
        UNCONFIRMED = <any> 'UNCONFIRMED'
    }
}
export class V2LineupPlayerDto {
    'type'?: any;
    'player'?: V2Player;
    'positionX'?: number;
    'positionY'?: number;
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "any"
        },
        {
            "name": "player",
            "baseName": "player",
            "type": "V2Player"
        },
        {
            "name": "positionX",
            "baseName": "position_x",
            "type": "number"
        },
        {
            "name": "positionY",
            "baseName": "position_y",
            "type": "number"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2LineupPlayerDto.attributeTypeMap;
    }
}

export class V2LineupPlayerInput {
    'typeId'?: string;
    'playerId'?: string;
    'positionX'?: number;
    'positionY'?: number;
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "typeId",
            "baseName": "type_id",
            "type": "string"
        },
        {
            "name": "playerId",
            "baseName": "player_id",
            "type": "string"
        },
        {
            "name": "positionX",
            "baseName": "position_x",
            "type": "number"
        },
        {
            "name": "positionY",
            "baseName": "position_y",
            "type": "number"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2LineupPlayerInput.attributeTypeMap;
    }
}

export class V2LineupTeamDto {
    'formation'?: string;
    'coach'?: V2Coach;
    'teamId'?: string;
    'players'?: Array<V2LineupPlayerDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "formation",
            "baseName": "formation",
            "type": "string"
        },
        {
            "name": "coach",
            "baseName": "coach",
            "type": "V2Coach"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<V2LineupPlayerDto>"
        }    ];

    static getAttributeTypeMap() {
        return V2LineupTeamDto.attributeTypeMap;
    }
}

export class V2LineupTeamInput {
    'formation'?: string;
    'coachId'?: string;
    'players'?: Array<V2LineupPlayerInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "formation",
            "baseName": "formation",
            "type": "string"
        },
        {
            "name": "coachId",
            "baseName": "coach_id",
            "type": "string"
        },
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<V2LineupPlayerInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2LineupTeamInput.attributeTypeMap;
    }
}

export class V2MappingDto {
    'provider'?: string;
    'entityType'?: V2MappingDto.EntityTypeEnum;
    'domainId'?: string;
    'providerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "entityType",
            "baseName": "entity_type",
            "type": "V2MappingDto.EntityTypeEnum"
        },
        {
            "name": "domainId",
            "baseName": "domain_id",
            "type": "string"
        },
        {
            "name": "providerId",
            "baseName": "provider_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2MappingDto.attributeTypeMap;
    }
}

export namespace V2MappingDto {
    export enum EntityTypeEnum {
        PLAYER = <any> 'PLAYER',
        TEAM = <any> 'TEAM',
        COACH = <any> 'COACH',
        MATCH = <any> 'MATCH',
        SEASON = <any> 'SEASON',
        VENUE = <any> 'VENUE',
        REFEREE = <any> 'REFEREE',
        TOURNAMENT = <any> 'TOURNAMENT',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STAGE = <any> 'STAGE',
        GROUP = <any> 'GROUP',
        COUNTRY = <any> 'COUNTRY',
        ODDPROVIDER = <any> 'ODD_PROVIDER'
    }
}
export class V2MappingRequestDto {
    'entityType': V2MappingRequestDto.EntityTypeEnum;
    'providerId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entityType",
            "baseName": "entity_type",
            "type": "V2MappingRequestDto.EntityTypeEnum"
        },
        {
            "name": "providerId",
            "baseName": "provider_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2MappingRequestDto.attributeTypeMap;
    }
}

export namespace V2MappingRequestDto {
    export enum EntityTypeEnum {
        PLAYER = <any> 'PLAYER',
        TEAM = <any> 'TEAM',
        COACH = <any> 'COACH',
        MATCH = <any> 'MATCH',
        SEASON = <any> 'SEASON',
        VENUE = <any> 'VENUE',
        REFEREE = <any> 'REFEREE',
        TOURNAMENT = <any> 'TOURNAMENT',
        CITY = <any> 'CITY',
        PRESIDENT = <any> 'PRESIDENT',
        STAGE = <any> 'STAGE',
        GROUP = <any> 'GROUP',
        COUNTRY = <any> 'COUNTRY',
        ODDPROVIDER = <any> 'ODD_PROVIDER'
    }
}
export class V2MappingRequestsDto {
    'provider'?: string;
    'mappingRequests': Array<V2MappingRequestDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "mappingRequests",
            "baseName": "mapping_requests",
            "type": "Array<V2MappingRequestDto>"
        }    ];

    static getAttributeTypeMap() {
        return V2MappingRequestsDto.attributeTypeMap;
    }
}

export class V2MappingsDto {
    'mappings'?: Array<V2MappingDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mappings",
            "baseName": "mappings",
            "type": "Array<V2MappingDto>"
        }    ];

    static getAttributeTypeMap() {
        return V2MappingsDto.attributeTypeMap;
    }
}

export class V2Match {
    'id'?: string;
    'status'?: V2MatchStatus;
    'kickoffTime'?: Date;
    'stage'?: V2MatchStage;
    'season'?: V2Season;
    'group'?: V2Group;
    'round'?: V2MatchRound;
    'homeTeam'?: V2MatchTeamDto;
    'awayTeam'?: V2MatchTeamDto;
    'referees'?: Array<V2MatchReferee>;
    'venue'?: V2MatchVenue;
    'spectators'?: number;
    'coverage'?: V2Match.CoverageEnum;
    'minute'?: V2MatchMinute;
    'phaseStartedAt'?: Date;
    'finishedAt'?: Date;
    'score'?: V2MatchScore;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "V2MatchStatus"
        },
        {
            "name": "kickoffTime",
            "baseName": "kickoff_time",
            "type": "Date"
        },
        {
            "name": "stage",
            "baseName": "stage",
            "type": "V2MatchStage"
        },
        {
            "name": "season",
            "baseName": "season",
            "type": "V2Season"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "V2Group"
        },
        {
            "name": "round",
            "baseName": "round",
            "type": "V2MatchRound"
        },
        {
            "name": "homeTeam",
            "baseName": "home_team",
            "type": "V2MatchTeamDto"
        },
        {
            "name": "awayTeam",
            "baseName": "away_team",
            "type": "V2MatchTeamDto"
        },
        {
            "name": "referees",
            "baseName": "referees",
            "type": "Array<V2MatchReferee>"
        },
        {
            "name": "venue",
            "baseName": "venue",
            "type": "V2MatchVenue"
        },
        {
            "name": "spectators",
            "baseName": "spectators",
            "type": "number"
        },
        {
            "name": "coverage",
            "baseName": "coverage",
            "type": "V2Match.CoverageEnum"
        },
        {
            "name": "minute",
            "baseName": "minute",
            "type": "V2MatchMinute"
        },
        {
            "name": "phaseStartedAt",
            "baseName": "phase_started_at",
            "type": "Date"
        },
        {
            "name": "finishedAt",
            "baseName": "finished_at",
            "type": "Date"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "V2MatchScore"
        }    ];

    static getAttributeTypeMap() {
        return V2Match.attributeTypeMap;
    }
}

export namespace V2Match {
    export enum CoverageEnum {
        LIVE = <any> 'LIVE',
        NOTLIVE = <any> 'NOT_LIVE',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
export class V2MatchEvent {
    'id'?: string;
    'matchId'?: string;
    'typeCode'?: V2MatchEvent.TypeCodeEnum;
    'teamPosition'?: V2MatchEvent.TeamPositionEnum;
    'minute'?: number;
    'teamId'?: string;
    'primaryPlayer'?: V2Player;
    'secondaryPlayer'?: V2Player;
    'score'?: V2TeamScore;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "string"
        },
        {
            "name": "typeCode",
            "baseName": "type_code",
            "type": "V2MatchEvent.TypeCodeEnum"
        },
        {
            "name": "teamPosition",
            "baseName": "team_position",
            "type": "V2MatchEvent.TeamPositionEnum"
        },
        {
            "name": "minute",
            "baseName": "minute",
            "type": "number"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "primaryPlayer",
            "baseName": "primary_player",
            "type": "V2Player"
        },
        {
            "name": "secondaryPlayer",
            "baseName": "secondary_player",
            "type": "V2Player"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "V2TeamScore"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchEvent.attributeTypeMap;
    }
}

export namespace V2MatchEvent {
    export enum TypeCodeEnum {
        YELLOWREDCARD = <any> 'YELLOW_RED_CARD',
        PENALTYSHOOTOUTMISSED = <any> 'PENALTY_SHOOTOUT_MISSED',
        PENALTYSHOOTOUTSCORED = <any> 'PENALTY_SHOOTOUT_SCORED',
        SUBSTITUTION = <any> 'SUBSTITUTION',
        GOAL = <any> 'GOAL',
        REDCARD = <any> 'RED_CARD',
        PENALTYMISS = <any> 'PENALTY_MISS',
        YELLOWCARD = <any> 'YELLOW_CARD',
        ASSIST = <any> 'ASSIST',
        PENALTYGOAL = <any> 'PENALTY_GOAL',
        OWNGOAL = <any> 'OWN_GOAL'
    }
    export enum TeamPositionEnum {
        HOME = <any> 'HOME',
        AWAY = <any> 'AWAY'
    }
}
export class V2MatchEventInput {
    'id'?: string;
    'typeCode'?: V2MatchEventInput.TypeCodeEnum;
    'teamPosition'?: V2MatchEventInput.TeamPositionEnum;
    'minute'?: number;
    'primaryPlayerId'?: string;
    'secondaryPlayerId'?: string;
    /**
    * Property is used to determine the order of events, if two or more events have the same minute
    */
    'sortOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "typeCode",
            "baseName": "type_code",
            "type": "V2MatchEventInput.TypeCodeEnum"
        },
        {
            "name": "teamPosition",
            "baseName": "team_position",
            "type": "V2MatchEventInput.TeamPositionEnum"
        },
        {
            "name": "minute",
            "baseName": "minute",
            "type": "number"
        },
        {
            "name": "primaryPlayerId",
            "baseName": "primary_player_id",
            "type": "string"
        },
        {
            "name": "secondaryPlayerId",
            "baseName": "secondary_player_id",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchEventInput.attributeTypeMap;
    }
}

export namespace V2MatchEventInput {
    export enum TypeCodeEnum {
        YELLOWREDCARD = <any> 'YELLOW_RED_CARD',
        PENALTYSHOOTOUTMISSED = <any> 'PENALTY_SHOOTOUT_MISSED',
        PENALTYSHOOTOUTSCORED = <any> 'PENALTY_SHOOTOUT_SCORED',
        SUBSTITUTION = <any> 'SUBSTITUTION',
        GOAL = <any> 'GOAL',
        REDCARD = <any> 'RED_CARD',
        PENALTYMISS = <any> 'PENALTY_MISS',
        YELLOWCARD = <any> 'YELLOW_CARD',
        ASSIST = <any> 'ASSIST',
        PENALTYGOAL = <any> 'PENALTY_GOAL',
        OWNGOAL = <any> 'OWN_GOAL'
    }
    export enum TeamPositionEnum {
        HOME = <any> 'HOME',
        AWAY = <any> 'AWAY'
    }
}
export class V2MatchEventInputWrapper {
    'events'?: Array<V2MatchEventInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<V2MatchEventInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchEventInputWrapper.attributeTypeMap;
    }
}

export class V2MatchEventProfile {
    'events'?: Array<V2MatchEvent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<V2MatchEvent>"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchEventProfile.attributeTypeMap;
    }
}

export class V2MatchInput {
    'statusId'?: string;
    'kickoffTime'?: Date;
    'stageId'?: string;
    'homeTeamId'?: string;
    'awayTeamId'?: string;
    'roundKey'?: string;
    'groupId'?: string;
    'venueId'?: string;
    'referees'?: Array<V2MatchRefereeInput>;
    'score'?: V2MatchScoreInput;
    'spectators'?: number;
    'coverage'?: V2MatchInput.CoverageEnum;
    'finishedAt'?: Date;
    'phaseStartedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "statusId",
            "baseName": "status_id",
            "type": "string"
        },
        {
            "name": "kickoffTime",
            "baseName": "kickoff_time",
            "type": "Date"
        },
        {
            "name": "stageId",
            "baseName": "stage_id",
            "type": "string"
        },
        {
            "name": "homeTeamId",
            "baseName": "home_team_id",
            "type": "string"
        },
        {
            "name": "awayTeamId",
            "baseName": "away_team_id",
            "type": "string"
        },
        {
            "name": "roundKey",
            "baseName": "round_key",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "string"
        },
        {
            "name": "venueId",
            "baseName": "venue_id",
            "type": "string"
        },
        {
            "name": "referees",
            "baseName": "referees",
            "type": "Array<V2MatchRefereeInput>"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "V2MatchScoreInput"
        },
        {
            "name": "spectators",
            "baseName": "spectators",
            "type": "number"
        },
        {
            "name": "coverage",
            "baseName": "coverage",
            "type": "V2MatchInput.CoverageEnum"
        },
        {
            "name": "finishedAt",
            "baseName": "finished_at",
            "type": "Date"
        },
        {
            "name": "phaseStartedAt",
            "baseName": "phase_started_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchInput.attributeTypeMap;
    }
}

export namespace V2MatchInput {
    export enum CoverageEnum {
        LIVE = <any> 'LIVE',
        NOTLIVE = <any> 'NOT_LIVE',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
export class V2MatchMinute {
    'regularTime'?: number;
    'injuryTime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "regularTime",
            "baseName": "regular_time",
            "type": "number"
        },
        {
            "name": "injuryTime",
            "baseName": "injury_time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchMinute.attributeTypeMap;
    }
}

export class V2MatchReferee {
    'id'?: string;
    'name'?: string;
    'role'?: V2MatchReferee.RoleEnum;
    'gender'?: V2MatchReferee.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V2MatchReferee.RoleEnum"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2MatchReferee.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchReferee.attributeTypeMap;
    }
}

export namespace V2MatchReferee {
    export enum RoleEnum {
        REFEREE = <any> 'REFEREE'
    }
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class V2MatchRefereeInput {
    'refereeId'?: string;
    'role'?: V2MatchRefereeInput.RoleEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "refereeId",
            "baseName": "referee_id",
            "type": "string"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "V2MatchRefereeInput.RoleEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchRefereeInput.attributeTypeMap;
    }
}

export namespace V2MatchRefereeInput {
    export enum RoleEnum {
        REFEREE = <any> 'REFEREE'
    }
}
export class V2MatchRound {
    'key'?: string;
    'name'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchRound.attributeTypeMap;
    }
}

export class V2MatchScore {
    'total'?: V2TeamScore;
    'halfTime'?: V2TeamScore;
    'regularTime'?: V2TeamScore;
    'extraTime'?: V2TeamScore;
    'penaltyShootout'?: V2TeamScore;
    'aggregate'?: V2TeamScore;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "total",
            "baseName": "total",
            "type": "V2TeamScore"
        },
        {
            "name": "halfTime",
            "baseName": "half_time",
            "type": "V2TeamScore"
        },
        {
            "name": "regularTime",
            "baseName": "regular_time",
            "type": "V2TeamScore"
        },
        {
            "name": "extraTime",
            "baseName": "extra_time",
            "type": "V2TeamScore"
        },
        {
            "name": "penaltyShootout",
            "baseName": "penalty_shootout",
            "type": "V2TeamScore"
        },
        {
            "name": "aggregate",
            "baseName": "aggregate",
            "type": "V2TeamScore"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchScore.attributeTypeMap;
    }
}

export class V2MatchScoreInput {
    'total'?: V2TeamScoreInput;
    'halfTime'?: V2TeamScoreInput;
    'regularTime'?: V2TeamScoreInput;
    'extraTime'?: V2TeamScoreInput;
    'penaltyShootout'?: V2TeamScoreInput;
    'aggregate'?: V2TeamScoreInput;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "total",
            "baseName": "total",
            "type": "V2TeamScoreInput"
        },
        {
            "name": "halfTime",
            "baseName": "half_time",
            "type": "V2TeamScoreInput"
        },
        {
            "name": "regularTime",
            "baseName": "regular_time",
            "type": "V2TeamScoreInput"
        },
        {
            "name": "extraTime",
            "baseName": "extra_time",
            "type": "V2TeamScoreInput"
        },
        {
            "name": "penaltyShootout",
            "baseName": "penalty_shootout",
            "type": "V2TeamScoreInput"
        },
        {
            "name": "aggregate",
            "baseName": "aggregate",
            "type": "V2TeamScoreInput"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchScoreInput.attributeTypeMap;
    }
}

export class V2MatchStage {
    'id'?: string;
    'name'?: string;
    'type'?: V2MatchStage.TypeEnum;
    'startDate'?: string;
    'endDate'?: string;
    'orderInSeason'?: number;
    'coverage'?: string;
    /**
    * Available only for /v2/seasons/{id}/stages
    */
    'status'?: V2MatchStage.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "V2MatchStage.TypeEnum"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "orderInSeason",
            "baseName": "order_in_season",
            "type": "number"
        },
        {
            "name": "coverage",
            "baseName": "coverage",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "V2MatchStage.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchStage.attributeTypeMap;
    }
}

export namespace V2MatchStage {
    export enum TypeEnum {
        GROUP = <any> 'GROUP',
        LEAGUE = <any> 'LEAGUE',
        KNOCKOUT = <any> 'KNOCK_OUT'
    }
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
export class V2MatchStatus {
    'id'?: string;
    'name'?: string;
    'shortName'?: string;
    'type'?: V2MatchStatus.TypeEnum;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "V2MatchStatus.TypeEnum"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchStatus.attributeTypeMap;
    }
}

export namespace V2MatchStatus {
    export enum TypeEnum {
        FINISHED = <any> 'FINISHED',
        NOTSTARTED = <any> 'NOT_STARTED',
        LIVE = <any> 'LIVE',
        INTERRUPTED = <any> 'INTERRUPTED',
        CANCELLED = <any> 'CANCELLED',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
export class V2MatchTeamDto {
    'id'?: string;
    'name'?: string;
    'threeLetterCode'?: string;
    'gender'?: string;
    'shortName'?: string;
    'type'?: V2MatchTeamDto.TypeEnum;
    'shirtColor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "three_letter_code",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "V2MatchTeamDto.TypeEnum"
        },
        {
            "name": "shirtColor",
            "baseName": "$shirt_color",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchTeamDto.attributeTypeMap;
    }
}

export namespace V2MatchTeamDto {
    export enum TypeEnum {
        PLACEHOLDER = <any> 'PLACEHOLDER',
        NATIONAL = <any> 'NATIONAL',
        CLUB = <any> 'CLUB'
    }
}
export class V2MatchVenue {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchVenue.attributeTypeMap;
    }
}

export class V2Matches {
    'matches'?: Array<V2Match>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matches",
            "baseName": "matches",
            "type": "Array<V2Match>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return V2Matches.attributeTypeMap;
    }
}

export class V2MatchesLivescore {
    'matches'?: Array<V2Match>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matches",
            "baseName": "matches",
            "type": "Array<V2Match>"
        }    ];

    static getAttributeTypeMap() {
        return V2MatchesLivescore.attributeTypeMap;
    }
}

export class V2Player {
    'id': string;
    'name': string;
    'country': V2Country;
    'active'?: boolean;
    'birthdate'?: string;
    'birthCity'?: V2City;
    'profile'?: PlayerProfileDto;
    'social'?: PlayerEditSocialDto;
    'position'?: string;
    'gender'?: V2Player.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "birthCity",
            "baseName": "birth_city",
            "type": "V2City"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "PlayerProfileDto"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "PlayerEditSocialDto"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2Player.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2Player.attributeTypeMap;
    }
}

export namespace V2Player {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class V2PlayerActiveClub {
    'team'?: V2Team;
    'contractType'?: string;
    'startDate'?: string;
    'shirtNumber'?: string;
    'status'?: V2PlayerActiveClub.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "team",
            "baseName": "team",
            "type": "V2Team"
        },
        {
            "name": "contractType",
            "baseName": "contract_type",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "V2PlayerActiveClub.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2PlayerActiveClub.attributeTypeMap;
    }
}

export namespace V2PlayerActiveClub {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
export class V2PlayerProfile {
    'id'?: string;
    'name'?: string;
    'country'?: V2Country;
    'active'?: boolean;
    'birthdate'?: string;
    'birthCity'?: V2City;
    'profile'?: PlayerProfileDto;
    'social'?: PlayerEditSocialDto;
    'position'?: string;
    'teams'?: Array<V2PlayerActiveClub>;
    'gender'?: V2PlayerProfile.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "birthdate",
            "baseName": "birthdate",
            "type": "string"
        },
        {
            "name": "birthCity",
            "baseName": "birth_city",
            "type": "V2City"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "PlayerProfileDto"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "PlayerEditSocialDto"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "string"
        },
        {
            "name": "teams",
            "baseName": "teams",
            "type": "Array<V2PlayerActiveClub>"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2PlayerProfile.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2PlayerProfile.attributeTypeMap;
    }
}

export namespace V2PlayerProfile {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class V2PlayerSeasonStatisticOutput {
    'player'?: V2Player;
    'teams'?: Array<V2Team>;
    'season'?: V2Season;
    'statistics'?: Array<V2StatisticItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "V2Player"
        },
        {
            "name": "teams",
            "baseName": "teams",
            "type": "Array<V2Team>"
        },
        {
            "name": "season",
            "baseName": "season",
            "type": "V2Season"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "Array<V2StatisticItem>"
        }    ];

    static getAttributeTypeMap() {
        return V2PlayerSeasonStatisticOutput.attributeTypeMap;
    }
}

export class V2PlayerSeasonStatisticOutputCollection {
    'statistics'?: Array<V2PlayerSeasonStatisticOutput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "Array<V2PlayerSeasonStatisticOutput>"
        }    ];

    static getAttributeTypeMap() {
        return V2PlayerSeasonStatisticOutputCollection.attributeTypeMap;
    }
}

export class V2PlayerStatisticInput {
    'playerId'?: string;
    'matchId'?: string;
    'teamId'?: string;
    'statistics'?: Array<PlayerStatisticItem>;
    'origin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "playerId",
            "baseName": "player_id",
            "type": "string"
        },
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "string"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "Array<PlayerStatisticItem>"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2PlayerStatisticInput.attributeTypeMap;
    }
}

export class V2PlayerStatisticOutput {
    'playerId'?: string;
    'matchId'?: string;
    'teamId'?: string;
    'statistics'?: any;
    'origin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "playerId",
            "baseName": "player_id",
            "type": "string"
        },
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "string"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "any"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2PlayerStatisticOutput.attributeTypeMap;
    }
}

export class V2PostVenues {
    'name': string;
    'countryId': string;
    'cityId'?: string;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "cityId",
            "baseName": "city_id",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return V2PostVenues.attributeTypeMap;
    }
}

export class V2President {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2President.attributeTypeMap;
    }
}

export class V2PresidentInput {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2PresidentInput.attributeTypeMap;
    }
}

export class V2PresidentUpdate {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2PresidentUpdate.attributeTypeMap;
    }
}

export class V2PutVenues {
    'id'?: string;
    'name': string;
    'countryId': string;
    'cityId'?: string;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "cityId",
            "baseName": "city_id",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return V2PutVenues.attributeTypeMap;
    }
}

export class V2RoundTypes {
    'rounds'?: Array<V2RoundWithStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rounds",
            "baseName": "rounds",
            "type": "Array<V2RoundWithStatus>"
        }    ];

    static getAttributeTypeMap() {
        return V2RoundTypes.attributeTypeMap;
    }
}

export class V2RoundWithStatus {
    'startDate'?: string;
    'endDate'?: string;
    /**
    * Not available at endpoint /v2/rounds
    */
    'status'?: string;
    'id'?: string;
    'key'?: string;
    'name'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2RoundWithStatus.attributeTypeMap;
    }
}

export class V2Season {
    'id'?: string;
    'name'?: string;
    'tournament'?: V2Tournament;
    'status'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tournament",
            "baseName": "tournament",
            "type": "V2Tournament"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return V2Season.attributeTypeMap;
    }
}

export class V2SeasonDetails {
    'season'?: V2Season;
    'stages'?: Array<V2StageDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "season",
            "baseName": "season",
            "type": "V2Season"
        },
        {
            "name": "stages",
            "baseName": "stages",
            "type": "Array<V2StageDetails>"
        }    ];

    static getAttributeTypeMap() {
        return V2SeasonDetails.attributeTypeMap;
    }
}

export class V2SeasonList {
    'seasons': Array<V2Season>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "seasons",
            "baseName": "seasons",
            "type": "Array<V2Season>"
        }    ];

    static getAttributeTypeMap() {
        return V2SeasonList.attributeTypeMap;
    }
}

export class V2SeasonStage {
    'id'?: string;
    'name'?: string;
    'type'?: V2SeasonStage.TypeEnum;
    'startDate'?: string;
    'endDate'?: string;
    'orderInSeason'?: number;
    'coverage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "V2SeasonStage.TypeEnum"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "orderInSeason",
            "baseName": "order_in_season",
            "type": "number"
        },
        {
            "name": "coverage",
            "baseName": "coverage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2SeasonStage.attributeTypeMap;
    }
}

export namespace V2SeasonStage {
    export enum TypeEnum {
        GROUP = <any> 'GROUP',
        LEAGUE = <any> 'LEAGUE',
        KNOCKOUT = <any> 'KNOCK_OUT'
    }
}
export class V2SeasonStageCollection {
    'stages'?: Array<V2MatchStage>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stages",
            "baseName": "stages",
            "type": "Array<V2MatchStage>"
        }    ];

    static getAttributeTypeMap() {
        return V2SeasonStageCollection.attributeTypeMap;
    }
}

export class V2SquadPlayer {
    'player': V2Player;
    'status': V2SquadPlayer.StatusEnum;
    'contractType'?: V2SquadPlayer.ContractTypeEnum;
    'startDate'?: string;
    'endDate'?: string;
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "player",
            "baseName": "player",
            "type": "V2Player"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "V2SquadPlayer.StatusEnum"
        },
        {
            "name": "contractType",
            "baseName": "contract_type",
            "type": "V2SquadPlayer.ContractTypeEnum"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2SquadPlayer.attributeTypeMap;
    }
}

export namespace V2SquadPlayer {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
    export enum ContractTypeEnum {
        PERMANENT = <any> 'PERMANENT',
        LOAN = <any> 'LOAN',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
export class V2SquadPlayerInput {
    'playerId'?: string;
    'status'?: V2SquadPlayerInput.StatusEnum;
    'contractType'?: V2SquadPlayerInput.ContractTypeEnum;
    'startDate'?: string;
    'endDate'?: string;
    'shirtNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "playerId",
            "baseName": "player_id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "V2SquadPlayerInput.StatusEnum"
        },
        {
            "name": "contractType",
            "baseName": "contract_type",
            "type": "V2SquadPlayerInput.ContractTypeEnum"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "end_date",
            "type": "string"
        },
        {
            "name": "shirtNumber",
            "baseName": "shirt_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2SquadPlayerInput.attributeTypeMap;
    }
}

export namespace V2SquadPlayerInput {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
    export enum ContractTypeEnum {
        PERMANENT = <any> 'PERMANENT',
        LOAN = <any> 'LOAN',
        UNKNOWN = <any> 'UNKNOWN'
    }
}
export class V2StageDetails {
    'stage'?: V2MatchStage;
    'rounds'?: Array<V2RoundWithStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stage",
            "baseName": "stage",
            "type": "V2MatchStage"
        },
        {
            "name": "rounds",
            "baseName": "rounds",
            "type": "Array<V2RoundWithStatus>"
        }    ];

    static getAttributeTypeMap() {
        return V2StageDetails.attributeTypeMap;
    }
}

export class V2StageGroup {
    'id'?: string;
    'name'?: string;
    'orderInStage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orderInStage",
            "baseName": "order_in_stage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2StageGroup.attributeTypeMap;
    }
}

export class V2StageGroupCollection {
    'groups'?: Array<V2Group>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<V2Group>"
        }    ];

    static getAttributeTypeMap() {
        return V2StageGroupCollection.attributeTypeMap;
    }
}

export class V2StageTeamInput {
    'teamId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2StageTeamInput.attributeTypeMap;
    }
}

export class V2StandingEntryRuleInput {
    'standingRuleId'?: string;
    'rank'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "standingRuleId",
            "baseName": "standing_rule_id",
            "type": "string"
        },
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2StandingEntryRuleInput.attributeTypeMap;
    }
}

export class V2StandingEntryRuleWrapper {
    'rules'?: Array<V2StandingEntryRuleInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<V2StandingEntryRuleInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2StandingEntryRuleWrapper.attributeTypeMap;
    }
}

export class V2StatisticItem {
    'name'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2StatisticItem.attributeTypeMap;
    }
}

export class V2Team {
    'id': string;
    'name': string;
    'threeLetterCode'?: string;
    'shortName'?: string;
    'type': V2Team.TypeEnum;
    'country': V2Country;
    'venue'?: V2VenuesGetId;
    'social'?: TeamSocialDto;
    'founded'?: number;
    'gender'?: V2Team.GenderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "three_letter_code",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "V2Team.TypeEnum"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "venue",
            "baseName": "venue",
            "type": "V2VenuesGetId"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "TeamSocialDto"
        },
        {
            "name": "founded",
            "baseName": "founded",
            "type": "number"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2Team.GenderEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2Team.attributeTypeMap;
    }
}

export namespace V2Team {
    export enum TypeEnum {
        PLACEHOLDER = <any> 'PLACEHOLDER',
        NATIONAL = <any> 'NATIONAL',
        CLUB = <any> 'CLUB'
    }
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class V2TeamColors {
    'entityType': string;
    'entityId': string;
    'colors': Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entityType",
            "baseName": "entity_type",
            "type": "string"
        },
        {
            "name": "entityId",
            "baseName": "entity_id",
            "type": "string"
        },
        {
            "name": "colors",
            "baseName": "colors",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return V2TeamColors.attributeTypeMap;
    }
}

export class V2TeamProfile {
    'id'?: string;
    'name'?: string;
    'threeLetterCode'?: string;
    'shortName'?: string;
    'type'?: string;
    'founded'?: number;
    'country'?: V2Country;
    'venue'?: V2VenuesGetId;
    'social'?: TeamSocialDto;
    'coach'?: V2Coach;
    'president'?: V2President;
    'gender'?: V2TeamProfile.GenderEnum;
    'activeSeasons'?: Array<V2Season>;
    'shirtColors'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "threeLetterCode",
            "baseName": "three_letter_code",
            "type": "string"
        },
        {
            "name": "shortName",
            "baseName": "short_name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "founded",
            "baseName": "founded",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "venue",
            "baseName": "venue",
            "type": "V2VenuesGetId"
        },
        {
            "name": "social",
            "baseName": "social",
            "type": "TeamSocialDto"
        },
        {
            "name": "coach",
            "baseName": "coach",
            "type": "V2Coach"
        },
        {
            "name": "president",
            "baseName": "president",
            "type": "V2President"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2TeamProfile.GenderEnum"
        },
        {
            "name": "activeSeasons",
            "baseName": "active_seasons",
            "type": "Array<V2Season>"
        },
        {
            "name": "shirtColors",
            "baseName": "shirt_colors",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return V2TeamProfile.attributeTypeMap;
    }
}

export namespace V2TeamProfile {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
}
export class V2TeamScore {
    'home'?: number;
    'away'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "home",
            "baseName": "home",
            "type": "number"
        },
        {
            "name": "away",
            "baseName": "away",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2TeamScore.attributeTypeMap;
    }
}

export class V2TeamScoreInput {
    'home'?: number;
    'away'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "home",
            "baseName": "home",
            "type": "number"
        },
        {
            "name": "away",
            "baseName": "away",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2TeamScoreInput.attributeTypeMap;
    }
}

export class V2TeamSquad {
    'team': V2Team;
    'players': Array<V2SquadPlayer>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "team",
            "baseName": "team",
            "type": "V2Team"
        },
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<V2SquadPlayer>"
        }    ];

    static getAttributeTypeMap() {
        return V2TeamSquad.attributeTypeMap;
    }
}

export class V2TeamSquadInput {
    'players'?: Array<V2SquadPlayerInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "players",
            "baseName": "players",
            "type": "Array<V2SquadPlayerInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2TeamSquadInput.attributeTypeMap;
    }
}

export class V2TopScorerEntryInput {
    'teamId'?: string;
    'playerId'?: string;
    'rank'?: number;
    'goals'?: number;
    'played'?: number;
    'assists'?: number;
    'scoredFirst'?: number;
    'minutes'?: number;
    'penalties'?: number;
    'yellowCards'?: number;
    'redCards'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "string"
        },
        {
            "name": "playerId",
            "baseName": "player_id",
            "type": "string"
        },
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        },
        {
            "name": "goals",
            "baseName": "goals",
            "type": "number"
        },
        {
            "name": "played",
            "baseName": "played",
            "type": "number"
        },
        {
            "name": "assists",
            "baseName": "assists",
            "type": "number"
        },
        {
            "name": "scoredFirst",
            "baseName": "scored_first",
            "type": "number"
        },
        {
            "name": "minutes",
            "baseName": "minutes",
            "type": "number"
        },
        {
            "name": "penalties",
            "baseName": "penalties",
            "type": "number"
        },
        {
            "name": "yellowCards",
            "baseName": "yellow_cards",
            "type": "number"
        },
        {
            "name": "redCards",
            "baseName": "red_cards",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2TopScorerEntryInput.attributeTypeMap;
    }
}

export class V2TopScorerStandingInput {
    'entries'?: Array<V2TopScorerEntryInput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entries",
            "baseName": "entries",
            "type": "Array<V2TopScorerEntryInput>"
        }    ];

    static getAttributeTypeMap() {
        return V2TopScorerStandingInput.attributeTypeMap;
    }
}

export class V2Tournament {
    'id'?: string;
    'name'?: string;
    'country'?: V2Country;
    'gender'?: V2Tournament.GenderEnum;
    'type'?: V2Tournament.TypeEnum;
    'region'?: V2Tournament.RegionEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "V2Tournament.GenderEnum"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "V2Tournament.TypeEnum"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "V2Tournament.RegionEnum"
        }    ];

    static getAttributeTypeMap() {
        return V2Tournament.attributeTypeMap;
    }
}

export namespace V2Tournament {
    export enum GenderEnum {
        MALE = <any> 'MALE',
        FEMALE = <any> 'FEMALE'
    }
    export enum TypeEnum {
        CUP = <any> 'CUP',
        LEAGUE = <any> 'LEAGUE'
    }
    export enum RegionEnum {
        DOMESTIC = <any> 'DOMESTIC',
        INTERNATIONAL = <any> 'INTERNATIONAL'
    }
}
export class V2TournamentGroupCollection {
    'groups'?: Array<Dto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<Dto>"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentGroupCollection.attributeTypeMap;
    }
}

export class V2TournamentGroupGetOutput {
    'code'?: string;
    'name'?: string;
    'description'?: string;
    'tournaments'?: Array<V2TournamentItemOutput>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tournaments",
            "baseName": "tournaments",
            "type": "Array<V2TournamentItemOutput>"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentGroupGetOutput.attributeTypeMap;
    }
}

export class V2TournamentGroupInsertInput {
    'code'?: string;
    'name'?: string;
    'description'?: string;
    'tournaments'?: Array<TournamentItemDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tournaments",
            "baseName": "tournaments",
            "type": "Array<TournamentItemDto>"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentGroupInsertInput.attributeTypeMap;
    }
}

export class V2TournamentGroupSelection {
    'matchId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matchId",
            "baseName": "match_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentGroupSelection.attributeTypeMap;
    }
}

export class V2TournamentGroupUpdateInput {
    'name'?: string;
    'description'?: string;
    'tournaments'?: Array<TournamentItemDto>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tournaments",
            "baseName": "tournaments",
            "type": "Array<TournamentItemDto>"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentGroupUpdateInput.attributeTypeMap;
    }
}

export class V2TournamentItemOutput {
    'tournament'?: V2Tournament;
    'sortOrder'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tournament",
            "baseName": "tournament",
            "type": "V2Tournament"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentItemOutput.attributeTypeMap;
    }
}

export class V2TournamentSeasonInsertInput {
    'tournamentId'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tournamentId",
            "baseName": "tournament_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentSeasonInsertInput.attributeTypeMap;
    }
}

export class V2TournamentSeasonStatusInput {
    'seasonId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "seasonId",
            "baseName": "season_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentSeasonStatusInput.attributeTypeMap;
    }
}

export class V2TournamentSeasonUpdateInput {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V2TournamentSeasonUpdateInput.attributeTypeMap;
    }
}

export class V2Venues {
    'id'?: string;
    'name': string;
    'country': V2Country;
    'city'?: V2City;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "V2City"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return V2Venues.attributeTypeMap;
    }
}

export class V2VenuesGetId {
    'id'?: string;
    'name'?: string;
    'country'?: V2Country;
    'city'?: V2City;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "V2City"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return V2VenuesGetId.attributeTypeMap;
    }
}

export class V2VenuesList {
    'venues'?: Array<ListVenueDto>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "venues",
            "baseName": "venues",
            "type": "Array<ListVenueDto>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return V2VenuesList.attributeTypeMap;
    }
}

export class V2VenuesPut {
    'id'?: string;
    'name': string;
    'country': V2Country;
    'city'?: V2City;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "V2Country"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "V2City"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return V2VenuesPut.attributeTypeMap;
    }
}

export class Venue {
    /**
    * Unique identifier in the system
    */
    'id': number;
    /**
    * Human readable name of the Venue
    */
    'name': string;
    /**
    * Country where the stadium is located
    */
    'country'?: Country;
    'city'?: string;
    /**
    * 600x450 image of the Venue
    */
    'urlImage'?: string;
    /**
    * Total capacity of the stadium
    */
    'capacity'?: number;
    /**
    * Latitude coordinate of the stadium's location
    */
    'lat'?: number;
    /**
    * Longitude coordinate of the stadium's location
    */
    'lng'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "Country"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "urlImage",
            "baseName": "url_image",
            "type": "string"
        },
        {
            "name": "capacity",
            "baseName": "capacity",
            "type": "number"
        },
        {
            "name": "lat",
            "baseName": "lat",
            "type": "number"
        },
        {
            "name": "lng",
            "baseName": "lng",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Venue.attributeTypeMap;
    }
}

export class VenueDto {
    'id'?: string;
    'name'?: string;
    'country'?: CountryDto;
    'city'?: CityDto;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "CountryDto"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "CityDto"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return VenueDto.attributeTypeMap;
    }
}

export class VenueEditDto {
    'name': string;
    'countryId': string;
    'cityId'?: string;
    'profile'?: VenueProfileDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "countryId",
            "baseName": "country_id",
            "type": "string"
        },
        {
            "name": "cityId",
            "baseName": "city_id",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "VenueProfileDto"
        }    ];

    static getAttributeTypeMap() {
        return VenueEditDto.attributeTypeMap;
    }
}

export class VenuePageDto {
    'venues'?: Array<VenueDto>;
    'pageMeta'?: PageMetaDto;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "venues",
            "baseName": "venues",
            "type": "Array<VenueDto>"
        },
        {
            "name": "pageMeta",
            "baseName": "page_meta",
            "type": "PageMetaDto"
        }    ];

    static getAttributeTypeMap() {
        return VenuePageDto.attributeTypeMap;
    }
}

export class VenueProfileDto {
    'lat'?: number;
    'lng'?: number;
    'capacity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lat",
            "baseName": "lat",
            "type": "number"
        },
        {
            "name": "lng",
            "baseName": "lng",
            "type": "number"
        },
        {
            "name": "capacity",
            "baseName": "capacity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return VenueProfileDto.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "BlacklistKeyDto.TypeEnum": BlacklistKeyDto.TypeEnum,
        "BlacklistKeyDto.EntityEnum": BlacklistKeyDto.EntityEnum,
        "Coach.GenderEnum": Coach.GenderEnum,
        "CoachDto.GenderEnum": CoachDto.GenderEnum,
        "EventIncident.TypeEnum": EventIncident.TypeEnum,
        "EventPlayerType.CategoryEnum": EventPlayerType.CategoryEnum,
        "EventStatus.TypeEnum": EventStatus.TypeEnum,
        "EventStatus.CodeEnum": EventStatus.CodeEnum,
        "PartialTeam.GenderEnum": PartialTeam.GenderEnum,
        "PartialTeam.TypeEnum": PartialTeam.TypeEnum,
        "Player.PositionEnum": Player.PositionEnum,
        "Player.GenderEnum": Player.GenderEnum,
        "PlayerDto.GenderEnum": PlayerDto.GenderEnum,
        "RefereeDto.GenderEnum": RefereeDto.GenderEnum,
        "StandingRule.TypeEnum": StandingRule.TypeEnum,
        "Team.GenderEnum": Team.GenderEnum,
        "TeamForm.OutcomeEnum": TeamForm.OutcomeEnum,
        "TranslationEntityDto.EntityEnum": TranslationEntityDto.EntityEnum,
        "TranslationKeyDto.EntityEnum": TranslationKeyDto.EntityEnum,
        "V2Coach.GenderEnum": V2Coach.GenderEnum,
        "V2Lineup.StatusEnum": V2Lineup.StatusEnum,
        "V2LineupInput.StatusEnum": V2LineupInput.StatusEnum,
        "V2MappingDto.EntityTypeEnum": V2MappingDto.EntityTypeEnum,
        "V2MappingRequestDto.EntityTypeEnum": V2MappingRequestDto.EntityTypeEnum,
        "V2Match.CoverageEnum": V2Match.CoverageEnum,
        "V2MatchEvent.TypeCodeEnum": V2MatchEvent.TypeCodeEnum,
        "V2MatchEvent.TeamPositionEnum": V2MatchEvent.TeamPositionEnum,
        "V2MatchEventInput.TypeCodeEnum": V2MatchEventInput.TypeCodeEnum,
        "V2MatchEventInput.TeamPositionEnum": V2MatchEventInput.TeamPositionEnum,
        "V2MatchInput.CoverageEnum": V2MatchInput.CoverageEnum,
        "V2MatchReferee.RoleEnum": V2MatchReferee.RoleEnum,
        "V2MatchReferee.GenderEnum": V2MatchReferee.GenderEnum,
        "V2MatchRefereeInput.RoleEnum": V2MatchRefereeInput.RoleEnum,
        "V2MatchStage.TypeEnum": V2MatchStage.TypeEnum,
        "V2MatchStage.StatusEnum": V2MatchStage.StatusEnum,
        "V2MatchStatus.TypeEnum": V2MatchStatus.TypeEnum,
        "V2MatchTeamDto.TypeEnum": V2MatchTeamDto.TypeEnum,
        "V2Player.GenderEnum": V2Player.GenderEnum,
        "V2PlayerActiveClub.StatusEnum": V2PlayerActiveClub.StatusEnum,
        "V2PlayerProfile.GenderEnum": V2PlayerProfile.GenderEnum,
        "V2SeasonStage.TypeEnum": V2SeasonStage.TypeEnum,
        "V2SquadPlayer.StatusEnum": V2SquadPlayer.StatusEnum,
        "V2SquadPlayer.ContractTypeEnum": V2SquadPlayer.ContractTypeEnum,
        "V2SquadPlayerInput.StatusEnum": V2SquadPlayerInput.StatusEnum,
        "V2SquadPlayerInput.ContractTypeEnum": V2SquadPlayerInput.ContractTypeEnum,
        "V2Team.TypeEnum": V2Team.TypeEnum,
        "V2Team.GenderEnum": V2Team.GenderEnum,
        "V2TeamProfile.GenderEnum": V2TeamProfile.GenderEnum,
        "V2Tournament.GenderEnum": V2Tournament.GenderEnum,
        "V2Tournament.TypeEnum": V2Tournament.TypeEnum,
        "V2Tournament.RegionEnum": V2Tournament.RegionEnum,
}

let typeMap: {[index: string]: any} = {
    "BasicPlayerStats": BasicPlayerStats,
    "BlacklistDto": BlacklistDto,
    "BlacklistKeyDto": BlacklistKeyDto,
    "CardlistStandingData": CardlistStandingData,
    "CityDto": CityDto,
    "CityEditDto": CityEditDto,
    "Coach": Coach,
    "CoachDto": CoachDto,
    "CoachEditDto": CoachEditDto,
    "CoachPageDto": CoachPageDto,
    "Country": Country,
    "CountryDto": CountryDto,
    "Dto": Dto,
    "Event": Event,
    "EventIncident": EventIncident,
    "EventPlayer": EventPlayer,
    "EventPlayerSubOn": EventPlayerSubOn,
    "EventPlayerType": EventPlayerType,
    "EventStatus": EventStatus,
    "EventTeamStats": EventTeamStats,
    "EventsByDate": EventsByDate,
    "LanguageDto": LanguageDto,
    "LeagueStandingData": LeagueStandingData,
    "Lineup": Lineup,
    "ListVenueDto": ListVenueDto,
    "LiveCommentaryOutputDto": LiveCommentaryOutputDto,
    "NotFoundError": NotFoundError,
    "Odd": Odd,
    "OddProvider": OddProvider,
    "OutputDto": OutputDto,
    "PageMetaDto": PageMetaDto,
    "PartialEvent": PartialEvent,
    "PartialPerson": PartialPerson,
    "PartialTeam": PartialTeam,
    "PartialTeamWithForm": PartialTeamWithForm,
    "PartialTournamentSeasonStage": PartialTournamentSeasonStage,
    "Player": Player,
    "PlayerDto": PlayerDto,
    "PlayerEditDto": PlayerEditDto,
    "PlayerEditSocialDto": PlayerEditSocialDto,
    "PlayerPageDto": PlayerPageDto,
    "PlayerProfile": PlayerProfile,
    "PlayerProfileDto": PlayerProfileDto,
    "PlayerStatisticItem": PlayerStatisticItem,
    "PlayerStatistics": PlayerStatistics,
    "PlayerStatsBasic": PlayerStatsBasic,
    "PlayerStatsExtended": PlayerStatsExtended,
    "PlayerTeam": PlayerTeam,
    "RefereeDto": RefereeDto,
    "RefereeEditDto": RefereeEditDto,
    "RefereePageDto": RefereePageDto,
    "Round": Round,
    "SeasonDto": SeasonDto,
    "StageDto": StageDto,
    "StageGroup": StageGroup,
    "StageGroupWithStanding": StageGroupWithStanding,
    "StageGroupWithStandingTournamentSeasonStage": StageGroupWithStandingTournamentSeasonStage,
    "StandingData": StandingData,
    "StandingRule": StandingRule,
    "Team": Team,
    "TeamEditDto": TeamEditDto,
    "TeamForm": TeamForm,
    "TeamLineup": TeamLineup,
    "TeamPageDto": TeamPageDto,
    "TeamPlayer": TeamPlayer,
    "TeamPlayerData": TeamPlayerData,
    "TeamPlayerSeasonStatistics": TeamPlayerSeasonStatistics,
    "TeamPlayerStatistics": TeamPlayerStatistics,
    "TeamScore": TeamScore,
    "TeamSeasonStatistics": TeamSeasonStatistics,
    "TeamSocialDto": TeamSocialDto,
    "TeamStatistics": TeamStatistics,
    "TopscorerStandingData": TopscorerStandingData,
    "Tournament": Tournament,
    "TournamentDto": TournamentDto,
    "TournamentItemDto": TournamentItemDto,
    "TournamentSeason": TournamentSeason,
    "TournamentSeasonStage": TournamentSeasonStage,
    "TournamentSeasonStageWithStandingGroups": TournamentSeasonStageWithStandingGroups,
    "TournamentSeasonWithStages": TournamentSeasonWithStages,
    "TournamentSeasonWithTournament": TournamentSeasonWithTournament,
    "TournamentWithSeasons": TournamentWithSeasons,
    "TranslationContentDto": TranslationContentDto,
    "TranslationDto": TranslationDto,
    "TranslationEntityDto": TranslationEntityDto,
    "TranslationKeyDto": TranslationKeyDto,
    "V1CountryDto": V1CountryDto,
    "V2ActiveClubsInput": V2ActiveClubsInput,
    "V2ActiveTeamInput": V2ActiveTeamInput,
    "V2Asset": V2Asset,
    "V2AssetCollection": V2AssetCollection,
    "V2AssetDeleteInput": V2AssetDeleteInput,
    "V2AssetInput": V2AssetInput,
    "V2City": V2City,
    "V2Coach": V2Coach,
    "V2Country": V2Country,
    "V2Group": V2Group,
    "V2KnockoutEdgeRound": V2KnockoutEdgeRound,
    "V2KnockoutGroup": V2KnockoutGroup,
    "V2KnockoutMatch": V2KnockoutMatch,
    "V2KnockoutRound": V2KnockoutRound,
    "V2KnockoutScheme": V2KnockoutScheme,
    "V2KnockoutTeam": V2KnockoutTeam,
    "V2LeagueEntryInput": V2LeagueEntryInput,
    "V2LeagueStandingInput": V2LeagueStandingInput,
    "V2Lineup": V2Lineup,
    "V2LineupInput": V2LineupInput,
    "V2LineupPlayerDto": V2LineupPlayerDto,
    "V2LineupPlayerInput": V2LineupPlayerInput,
    "V2LineupTeamDto": V2LineupTeamDto,
    "V2LineupTeamInput": V2LineupTeamInput,
    "V2MappingDto": V2MappingDto,
    "V2MappingRequestDto": V2MappingRequestDto,
    "V2MappingRequestsDto": V2MappingRequestsDto,
    "V2MappingsDto": V2MappingsDto,
    "V2Match": V2Match,
    "V2MatchEvent": V2MatchEvent,
    "V2MatchEventInput": V2MatchEventInput,
    "V2MatchEventInputWrapper": V2MatchEventInputWrapper,
    "V2MatchEventProfile": V2MatchEventProfile,
    "V2MatchInput": V2MatchInput,
    "V2MatchMinute": V2MatchMinute,
    "V2MatchReferee": V2MatchReferee,
    "V2MatchRefereeInput": V2MatchRefereeInput,
    "V2MatchRound": V2MatchRound,
    "V2MatchScore": V2MatchScore,
    "V2MatchScoreInput": V2MatchScoreInput,
    "V2MatchStage": V2MatchStage,
    "V2MatchStatus": V2MatchStatus,
    "V2MatchTeamDto": V2MatchTeamDto,
    "V2MatchVenue": V2MatchVenue,
    "V2Matches": V2Matches,
    "V2MatchesLivescore": V2MatchesLivescore,
    "V2Player": V2Player,
    "V2PlayerActiveClub": V2PlayerActiveClub,
    "V2PlayerProfile": V2PlayerProfile,
    "V2PlayerSeasonStatisticOutput": V2PlayerSeasonStatisticOutput,
    "V2PlayerSeasonStatisticOutputCollection": V2PlayerSeasonStatisticOutputCollection,
    "V2PlayerStatisticInput": V2PlayerStatisticInput,
    "V2PlayerStatisticOutput": V2PlayerStatisticOutput,
    "V2PostVenues": V2PostVenues,
    "V2President": V2President,
    "V2PresidentInput": V2PresidentInput,
    "V2PresidentUpdate": V2PresidentUpdate,
    "V2PutVenues": V2PutVenues,
    "V2RoundTypes": V2RoundTypes,
    "V2RoundWithStatus": V2RoundWithStatus,
    "V2Season": V2Season,
    "V2SeasonDetails": V2SeasonDetails,
    "V2SeasonList": V2SeasonList,
    "V2SeasonStage": V2SeasonStage,
    "V2SeasonStageCollection": V2SeasonStageCollection,
    "V2SquadPlayer": V2SquadPlayer,
    "V2SquadPlayerInput": V2SquadPlayerInput,
    "V2StageDetails": V2StageDetails,
    "V2StageGroup": V2StageGroup,
    "V2StageGroupCollection": V2StageGroupCollection,
    "V2StageTeamInput": V2StageTeamInput,
    "V2StandingEntryRuleInput": V2StandingEntryRuleInput,
    "V2StandingEntryRuleWrapper": V2StandingEntryRuleWrapper,
    "V2StatisticItem": V2StatisticItem,
    "V2Team": V2Team,
    "V2TeamColors": V2TeamColors,
    "V2TeamProfile": V2TeamProfile,
    "V2TeamScore": V2TeamScore,
    "V2TeamScoreInput": V2TeamScoreInput,
    "V2TeamSquad": V2TeamSquad,
    "V2TeamSquadInput": V2TeamSquadInput,
    "V2TopScorerEntryInput": V2TopScorerEntryInput,
    "V2TopScorerStandingInput": V2TopScorerStandingInput,
    "V2Tournament": V2Tournament,
    "V2TournamentGroupCollection": V2TournamentGroupCollection,
    "V2TournamentGroupGetOutput": V2TournamentGroupGetOutput,
    "V2TournamentGroupInsertInput": V2TournamentGroupInsertInput,
    "V2TournamentGroupSelection": V2TournamentGroupSelection,
    "V2TournamentGroupUpdateInput": V2TournamentGroupUpdateInput,
    "V2TournamentItemOutput": V2TournamentItemOutput,
    "V2TournamentSeasonInsertInput": V2TournamentSeasonInsertInput,
    "V2TournamentSeasonStatusInput": V2TournamentSeasonStatusInput,
    "V2TournamentSeasonUpdateInput": V2TournamentSeasonUpdateInput,
    "V2Venues": V2Venues,
    "V2VenuesGetId": V2VenuesGetId,
    "V2VenuesList": V2VenuesList,
    "V2VenuesPut": V2VenuesPut,
    "Venue": Venue,
    "VenueDto": VenueDto,
    "VenueEditDto": VenueEditDto,
    "VenuePageDto": VenuePageDto,
    "VenueProfileDto": VenueProfileDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AssetsApiApiKeys {
}

export class AssetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AssetsApiApiKeys, value: string) {
        (this.authentications as any)[AssetsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Bulk delete assets
     * @param assets Array of assets
     * @param {*} [options] Override http request options.
     */
    public v2AssetsDelete (assets?: Array<V2AssetInput>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/assets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(assets, "Array<V2AssetInput>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk Upsert assets
     * @param assets Array of assets
     * @param {*} [options] Override http request options.
     */
    public v2AssetsPost (assets?: Array<V2AssetInput>, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Asset;  }> {
        const localVarPath = this.basePath + '/v2/assets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(assets, "Array<V2AssetInput>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Asset;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Asset");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BlacklistApiApiKeys {
}

export class BlacklistApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BlacklistApiApiKeys, value: string) {
        (this.authentications as any)[BlacklistApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Remove blacklist record by id.
     * @summary Remove the specified resource from storage.
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2BlacklistIdDelete (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/blacklist/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2BlacklistIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk find in blacklist table and return matching entries by the unique blacklist key.
     * @param blacklistKeys Array of blacklistsKeys
     * @param {*} [options] Override http request options.
     */
    public v2BlacklistSearchPost (blacklistKeys?: Array<BlacklistKeyDto>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<BlacklistDto>;  }> {
        const localVarPath = this.basePath + '/v2/blacklist/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(blacklistKeys, "Array<BlacklistKeyDto>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<BlacklistDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BlacklistDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CitiesApiApiKeys {
}

export class CitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CitiesApiApiKeys, value: string) {
        (this.authentications as any)[CitiesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Update city information
     * @param id Unique identifier of the resource.
     * @param city City information to save in persistance
     * @param {*} [options] Override http request options.
     */
    public v2CitiesIdPut (id: string, city?: CityEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: CityDto;  }> {
        const localVarPath = this.basePath + '/v2/cities/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2CitiesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(city, "CityEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CityDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CityDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store a newly created city in storage
     * @param city 
     * @param {*} [options] Override http request options.
     */
    public v2CitiesPost (city?: CityEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: CityDto;  }> {
        const localVarPath = this.basePath + '/v2/cities';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(city, "CityEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CityDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CityDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CoachesApiApiKeys {
}

export class CoachesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CoachesApiApiKeys, value: string) {
        (this.authentications as any)[CoachesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * List coaches with offset and limit parameters
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit Limit the number of results returned
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2CoachesGet (offset: number, limit: number, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CoachPageDto;  }> {
        const localVarPath = this.basePath + '/v2/coaches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling v2CoachesGet.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling v2CoachesGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CoachPageDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoachPageDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Find coach by id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2CoachesIdGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<CoachDto>;  }> {
        const localVarPath = this.basePath + '/v2/coaches/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2CoachesIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CoachDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CoachDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update coach information
     * @param id Unique identifier of the resource.
     * @param coach Coach information to save in persistance
     * @param {*} [options] Override http request options.
     */
    public v2CoachesIdPut (id: string, coach?: CoachEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: CoachDto;  }> {
        const localVarPath = this.basePath + '/v2/coaches/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2CoachesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coach, "CoachEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CoachDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoachDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store a newly created coach in storage
     * @param coach 
     * @param {*} [options] Override http request options.
     */
    public v2CoachesPost (coach?: CoachEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: CoachDto;  }> {
        const localVarPath = this.basePath + '/v2/coaches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coach, "CoachEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CoachDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoachDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CountriesApiApiKeys {
}

export class CountriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CountriesApiApiKeys, value: string) {
        (this.authentications as any)[CountriesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of available Country resources
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public countriesGet (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Country>;  }> {
        const localVarPath = this.basePath + '/countries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Country>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Country>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventIncidentsApiApiKeys {
}

export class EventIncidentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventIncidentsApiApiKeys, value: string) {
        (this.authentications as any)[EventIncidentsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param lastUpdate Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
     * @param {*} [options] Override http request options.
     */
    public eventIncidentsGet (acceptLanguage?: string, lastUpdate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventIncident>;  }> {
        const localVarPath = this.basePath + '/event_incidents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lastUpdate !== undefined) {
            localVarQueryParameters['last_update'] = ObjectSerializer.serialize(lastUpdate, "Date");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventIncident>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventIncident>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventPlayerTypeApiApiKeys {
}

export class EventPlayerTypeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventPlayerTypeApiApiKeys, value: string) {
        (this.authentications as any)[EventPlayerTypeApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of available EventPlayerType objects in the system
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public eventPlayerTypesGet (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EventPlayerType;  }> {
        const localVarPath = this.basePath + '/event_player_types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EventPlayerType;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventPlayerType");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventStatusApiApiKeys {
}

export class EventStatusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventStatusApiApiKeys, value: string) {
        (this.authentications as any)[EventStatusApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of available EventStatus objects in the system
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public eventStatusGet (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EventStatus;  }> {
        const localVarPath = this.basePath + '/event_status';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EventStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of events by home and away team id
     * @param homeId Filter events with home team id
     * @param awayId Filter events with away team id
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public eventsByTeamsGet (homeId: number, awayId: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Event;  }> {
        const localVarPath = this.basePath + '/events/by_teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'homeId' is not null or undefined
        if (homeId === null || homeId === undefined) {
            throw new Error('Required parameter homeId was null or undefined when calling eventsByTeamsGet.');
        }

        // verify required parameter 'awayId' is not null or undefined
        if (awayId === null || awayId === undefined) {
            throw new Error('Required parameter awayId was null or undefined when calling eventsByTeamsGet.');
        }

        if (homeId !== undefined) {
            localVarQueryParameters['home_id'] = ObjectSerializer.serialize(homeId, "number");
        }

        if (awayId !== undefined) {
            localVarQueryParameters['away_id'] = ObjectSerializer.serialize(awayId, "number");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Event;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Event");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Events
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param fromTime Filter events, which have a start_time after the specified date, format is RFC 3339
     * @param toTime Filter events, which have a start_time before the specified date, format is RFC 3339
     * @param groupBy Group events by a specified property. Event models are returned as an &#39;items&#39; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
     * @param clientOrder Order matching events for a specific client
     * @param {*} [options] Override http request options.
     */
    public eventsGet (acceptLanguage?: string, fromTime?: Date, toTime?: Date, groupBy?: '' | 'tournament_season_stage', clientOrder?: 'sportalios', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Event>;  }> {
        const localVarPath = this.basePath + '/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (fromTime !== undefined) {
            localVarQueryParameters['from_time'] = ObjectSerializer.serialize(fromTime, "Date");
        }

        if (toTime !== undefined) {
            localVarQueryParameters['to_time'] = ObjectSerializer.serialize(toTime, "Date");
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'' | 'tournament_season_stage'");
        }

        if (clientOrder !== undefined) {
            localVarQueryParameters['client_order'] = ObjectSerializer.serialize(clientOrder, "'sportalios'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Event>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Event>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param expand Specifies additional information to include with the standing response
     * @param {*} [options] Override http request options.
     */
    public eventsIdGet (id: string, acceptLanguage?: string, expand?: 'form' | 'form.events', options: any = {}) : Promise<{ response: http.ClientResponse; body: Event;  }> {
        const localVarPath = this.basePath + '/events/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'form' | 'form.events'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Event;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Event");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Group results by a property. If &#39;team&#39; is used the json object has &#39;home_team&#39; and &#39;away_team&#39;, each containing an array of EventIncident objects
     * @param direction Whether to sort the results by ascending or descending order
     * @param {*} [options] Override http request options.
     */
    public eventsIdIncidentsGet (id: string, acceptLanguage?: string, groupBy?: 'team', direction?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventIncident>;  }> {
        const localVarPath = this.basePath + '/events/{id}/incidents'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdIncidentsGet.');
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'team'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventIncident>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventIncident>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get lineup information for an event. Includes players, formation and coach
     * @param id Event.id for which lineups are requested
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public eventsIdLineupsGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Lineup;  }> {
        const localVarPath = this.basePath + '/events/{id}/lineups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdLineupsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Lineup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Lineup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Group results by a property. If &#39;team&#39; is used the json object has &#39;home_team&#39; and &#39;away_team&#39;, each containing an array of EventPlayer objects
     * @param {*} [options] Override http request options.
     */
    public eventsIdPlayersGet (id: string, acceptLanguage?: string, groupBy?: 'team', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventPlayer>;  }> {
        const localVarPath = this.basePath + '/events/{id}/players'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdPlayersGet.');
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'team'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventPlayer>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventPlayer>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get available pre-game odds for an Event
     * @param id Unique identifier of the resource.
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param {*} [options] Override http request options.
     */
    public eventsIdPregameoddsGet (id: string, xOddClient: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/events/{id}/pregameodds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdPregameoddsGet.');
        }

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling eventsIdPregameoddsGet.');
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of events which are currently live
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Group events by a specified property. Event models are returned as an &#39;items&#39; array inside the property object. Can be used to return events in a more convenient format for displaying. NOTE: when using this parameter the response schema changes.
     * @param {*} [options] Override http request options.
     */
    public eventsLiveGet (acceptLanguage?: string, groupBy?: 'tournament_season_stage', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Event>;  }> {
        const localVarPath = this.basePath + '/events/live';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'tournament_season_stage'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Event>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Event>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of events which have been updated since the specified timestamp
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param lastUpdate Filter events, have been updated after the specified date-time. By default will return updated Events during the last hour
     * @param {*} [options] Override http request options.
     */
    public eventsSinceGet (acceptLanguage?: string, lastUpdate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Event>;  }> {
        const localVarPath = this.basePath + '/events/since';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lastUpdate !== undefined) {
            localVarQueryParameters['last_update'] = ObjectSerializer.serialize(lastUpdate, "Date");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Event>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Event>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of matches for team/between teams
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param fromStartTime Return matches with start_time &gt;&#x3D; from_start_time. RFC 3339 format
     * @param toStartTime Return matches with start_time &lt;&#x3D; from_start_time. RFC 3339 format
     * @param teamIds List for team IDs separated by commas. In case of one ID, it will return all matches for a selected team, in case of multiple - it will return matches between selected teams.
     * @param matchIds List for match IDs separated by commas.
     * @param tournamentIds List for tournament IDs separated by commas.
     * @param stageIds List for stage IDs separated by commas.
     * @param rounds List for rounds separated by commas.
     * @param seasonIds List for season IDs separated by commas.
     * @param statusTypes List of status types.
     * @param offset Results offset
     * @param limit Results limit
     * @param tournamentOrder Tournament filtering and ordering.
     * @param refereeId Filter matches by referee
     * @param venueId Filter matches by venue
     * @param statusCode Filter matches by event_status.code
     * @param sortDirection Result ordering - asc/desc
     * @param {*} [options] Override http request options.
     */
    public matchesGet (acceptLanguage?: string, fromStartTime?: Date, toStartTime?: Date, teamIds?: string, matchIds?: string, tournamentIds?: string, stageIds?: string, rounds?: string, seasonIds?: string, statusTypes?: 'finished' | 'notstarted' | 'inprogress' | 'interrupted' | 'cancelled', offset?: number, limit?: number, tournamentOrder?: string, refereeId?: string, venueId?: string, statusCode?: string, sortDirection?: 'asc' | 'desc', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Event>;  }> {
        const localVarPath = this.basePath + '/matches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (fromStartTime !== undefined) {
            localVarQueryParameters['from_start_time'] = ObjectSerializer.serialize(fromStartTime, "Date");
        }

        if (toStartTime !== undefined) {
            localVarQueryParameters['to_start_time'] = ObjectSerializer.serialize(toStartTime, "Date");
        }

        if (teamIds !== undefined) {
            localVarQueryParameters['team_ids'] = ObjectSerializer.serialize(teamIds, "string");
        }

        if (matchIds !== undefined) {
            localVarQueryParameters['match_ids'] = ObjectSerializer.serialize(matchIds, "string");
        }

        if (tournamentIds !== undefined) {
            localVarQueryParameters['tournament_ids'] = ObjectSerializer.serialize(tournamentIds, "string");
        }

        if (stageIds !== undefined) {
            localVarQueryParameters['stage_ids'] = ObjectSerializer.serialize(stageIds, "string");
        }

        if (rounds !== undefined) {
            localVarQueryParameters['rounds'] = ObjectSerializer.serialize(rounds, "string");
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "string");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status_types'] = ObjectSerializer.serialize(statusTypes, "'finished' | 'notstarted' | 'inprogress' | 'interrupted' | 'cancelled'");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (tournamentOrder !== undefined) {
            localVarQueryParameters['tournament_order'] = ObjectSerializer.serialize(tournamentOrder, "string");
        }

        if (refereeId !== undefined) {
            localVarQueryParameters['referee_id'] = ObjectSerializer.serialize(refereeId, "string");
        }

        if (venueId !== undefined) {
            localVarQueryParameters['venue_id'] = ObjectSerializer.serialize(venueId, "string");
        }

        if (statusCode !== undefined) {
            localVarQueryParameters['status_code'] = ObjectSerializer.serialize(statusCode, "string");
        }

        if (sortDirection !== undefined) {
            localVarQueryParameters['sort_direction'] = ObjectSerializer.serialize(sortDirection, "'asc' | 'desc'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Event>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Event>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of events which are fixtures in a given TournamentSeasonStage resource
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param round Filter the event list by a specific round
     * @param sortDirection Sort results by date in ascending or descending order
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdEventsGet (id: number, round?: string, sortDirection?: 'asc' | 'desc', acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventsByDate>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}/events'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdEventsGet.');
        }

        if (round !== undefined) {
            localVarQueryParameters['round'] = ObjectSerializer.serialize(round, "string");
        }

        if (sortDirection !== undefined) {
            localVarQueryParameters['sort_direction'] = ObjectSerializer.serialize(sortDirection, "'asc' | 'desc'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventsByDate>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventsByDate>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum KnockoutSchemeApiApiKeys {
}

export class KnockoutSchemeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: KnockoutSchemeApiApiKeys, value: string) {
        (this.authentications as any)[KnockoutSchemeApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * 
     * @param stageId Get knockout schemes for given stage id
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2KnockoutSchemesStageIdGet (stageId: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2KnockoutScheme>;  }> {
        const localVarPath = this.basePath + '/v2/knockout-schemes/{stage_id}'
            .replace('{' + 'stage_id' + '}', encodeURIComponent(String(stageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stageId' is not null or undefined
        if (stageId === null || stageId === undefined) {
            throw new Error('Required parameter stageId was null or undefined when calling v2KnockoutSchemesStageIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2KnockoutScheme>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2KnockoutScheme>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LanguagesApiApiKeys {
}

export class LanguagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LanguagesApiApiKeys, value: string) {
        (this.authentications as any)[LanguagesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get all possible languages.
     * @param {*} [options] Override http request options.
     */
    public v2LanguagesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<LanguageDto>;  }> {
        const localVarPath = this.basePath + '/v2/languages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LanguageDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LanguageDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LineupsApiApiKeys {
}

export class LineupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LineupsApiApiKeys, value: string) {
        (this.authentications as any)[LineupsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get lineup information. Includes players, formation and coach
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param lastUpdate Filter lineups which have updates only after the specified time
     * @param {*} [options] Override http request options.
     */
    public lineupsGet (acceptLanguage?: string, lastUpdate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Lineup>;  }> {
        const localVarPath = this.basePath + '/lineups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lastUpdate !== undefined) {
            localVarQueryParameters['last_update'] = ObjectSerializer.serialize(lastUpdate, "Date");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Lineup>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Lineup>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get lineups by match id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2MatchesIdLineupsGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Lineup;  }> {
        const localVarPath = this.basePath + '/v2/matches/{id}/lineups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2MatchesIdLineupsGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Lineup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Lineup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Lineup information
     * @param lineup Lineup information to save in persistance
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2MatchesIdLineupsPut (lineup: V2LineupInput, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Lineup;  }> {
        const localVarPath = this.basePath + '/v2/matches/{id}/lineups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'lineup' is not null or undefined
        if (lineup === null || lineup === undefined) {
            throw new Error('Required parameter lineup was null or undefined when calling v2MatchesIdLineupsPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2MatchesIdLineupsPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lineup, "V2LineupInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Lineup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Lineup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MappingsApiApiKeys {
}

export class MappingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MappingsApiApiKeys, value: string) {
        (this.authentications as any)[MappingsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get FootballApi ID to Sportal ID maps for various types of objects
     * @param object Filter ID maps by a specific object type
     * @param id Return single Sportal ID for the specified FootballAPI &#39;id&#39;
     * @param {*} [options] Override http request options.
     */
    public mappingsSportalGet (object?: 'player' | 'team' | 'tournament' | 'tournament_season' | 'tournament_season_stage', id?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/mappings/sportal';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (object !== undefined) {
            localVarQueryParameters['object'] = ObjectSerializer.serialize(object, "'player' | 'team' | 'tournament' | 'tournament_season' | 'tournament_season_stage'");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Sportal to Football API ID maps for various types of objects
     * @param object Filter ID maps by a specific object type
     * @param id Return single FotballApi ID for the specified Sportal &#39;id&#39;
     * @param {*} [options] Override http request options.
     */
    public mappingsSportalReverseGet (object?: 'player' | 'team' | 'tournament' | 'tournament_season' | 'tournament_season_stage', id?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/mappings/sportal/reverse';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (object !== undefined) {
            localVarQueryParameters['object'] = ObjectSerializer.serialize(object, "'player' | 'team' | 'tournament' | 'tournament_season' | 'tournament_season_stage'");
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MatchEventsApiApiKeys {
}

export class MatchEventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MatchEventsApiApiKeys, value: string) {
        (this.authentications as any)[MatchEventsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get match events by match id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2MatchesIdEventsGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2MatchEventProfile;  }> {
        const localVarPath = this.basePath + '/v2/matches/{id}/events'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2MatchesIdEventsGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2MatchEventProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2MatchEventProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replaces all match events with the given input
     * @param id Unique identifier of the resource.
     * @param matchEvents Match event information to save
     * @param {*} [options] Override http request options.
     */
    public v2MatchesIdEventsPut (id: string, matchEvents: V2MatchEventInputWrapper, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2MatchEventProfile;  }> {
        const localVarPath = this.basePath + '/v2/matches/{id}/events'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2MatchesIdEventsPut.');
        }

        // verify required parameter 'matchEvents' is not null or undefined
        if (matchEvents === null || matchEvents === undefined) {
            throw new Error('Required parameter matchEvents was null or undefined when calling v2MatchesIdEventsPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(matchEvents, "V2MatchEventInputWrapper")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2MatchEventProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2MatchEventProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MatchesApiApiKeys {
}

export class MatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MatchesApiApiKeys, value: string) {
        (this.authentications as any)[MatchesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of live commentaries with specified match id and language
     * @param id Unique identifier of the resource.
     * @param languageCode Return translations depending on language code
     * @param {*} [options] Override http request options.
     */
    public matchesIdCommentaryGet (id: string, languageCode: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<LiveCommentaryOutputDto>;  }> {
        const localVarPath = this.basePath + '/matches/{id}/commentary'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling matchesIdCommentaryGet.');
        }

        // verify required parameter 'languageCode' is not null or undefined
        if (languageCode === null || languageCode === undefined) {
            throw new Error('Required parameter languageCode was null or undefined when calling matchesIdCommentaryGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LiveCommentaryOutputDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LiveCommentaryOutputDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of matches
     * @param limit Select an upper limit for the matches that would be returned
     * @param offset Select an offset for the matches that would be returned
     * @param tournamentIds Filter matches, which have been played as part of the listed tournaments
     * @param seasonIds Filter matches, which have been played as part of the listed tournament seasons
     * @param stageIds Filter matches, which have been played as part of the listed tournament stages
     * @param groupIds Filter matches, which have been played as part of the listed tournament groups
     * @param roundIds Filter matches, which have been played as part of the listed tournament rounds
     * @param roundFilter Filter matches by combinations of stage_id and round_id. Format: {stage_id}:{round_id}
     * @param fromKickoffTime Filter matches, which have a start_time after the specified date, format is ISO 8601
     * @param toKickoffTime Filter matches, which have a start_time before the specified date, format is ISO 8601
     * @param teamIds Filter matches by teams which have taken part in them
     * @param statusTypes Filter matches by their status types
     * @param statusCodes Filter matches by their status codes
     * @param refereeId Filter matches by the referee who has taken part in them
     * @param venueId Filter matches by the venue that has hosted them
     * @param sortDirection Sort matches in asc|desc order by start_time
     * @param {*} [options] Override http request options.
     */
    public v2MatchesGet (limit: number, offset: number, tournamentIds?: Array<number>, seasonIds?: Array<number>, stageIds?: Array<number>, groupIds?: Array<number>, roundIds?: Array<string>, roundFilter?: Array<string>, fromKickoffTime?: Date, toKickoffTime?: Date, teamIds?: Array<number>, statusTypes?: Array<string>, statusCodes?: Array<string>, refereeId?: number, venueId?: string, sortDirection?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2Match>;  }> {
        const localVarPath = this.basePath + '/v2/matches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling v2MatchesGet.');
        }

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling v2MatchesGet.');
        }

        if (tournamentIds !== undefined) {
            localVarQueryParameters['tournament_ids'] = ObjectSerializer.serialize(tournamentIds, "Array<number>");
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "Array<number>");
        }

        if (stageIds !== undefined) {
            localVarQueryParameters['stage_ids'] = ObjectSerializer.serialize(stageIds, "Array<number>");
        }

        if (groupIds !== undefined) {
            localVarQueryParameters['group_ids'] = ObjectSerializer.serialize(groupIds, "Array<number>");
        }

        if (roundIds !== undefined) {
            localVarQueryParameters['round_ids'] = ObjectSerializer.serialize(roundIds, "Array<string>");
        }

        if (roundFilter !== undefined) {
            localVarQueryParameters['round_filter'] = ObjectSerializer.serialize(roundFilter, "Array<string>");
        }

        if (fromKickoffTime !== undefined) {
            localVarQueryParameters['from_kickoff_time'] = ObjectSerializer.serialize(fromKickoffTime, "Date");
        }

        if (toKickoffTime !== undefined) {
            localVarQueryParameters['to_kickoff_time'] = ObjectSerializer.serialize(toKickoffTime, "Date");
        }

        if (teamIds !== undefined) {
            localVarQueryParameters['team_ids'] = ObjectSerializer.serialize(teamIds, "Array<number>");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status_types'] = ObjectSerializer.serialize(statusTypes, "Array<string>");
        }

        if (statusCodes !== undefined) {
            localVarQueryParameters['status_codes'] = ObjectSerializer.serialize(statusCodes, "Array<string>");
        }

        if (refereeId !== undefined) {
            localVarQueryParameters['referee_id'] = ObjectSerializer.serialize(refereeId, "number");
        }

        if (venueId !== undefined) {
            localVarQueryParameters['venue_id'] = ObjectSerializer.serialize(venueId, "string");
        }

        if (sortDirection !== undefined) {
            localVarQueryParameters['sort_direction'] = ObjectSerializer.serialize(sortDirection, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2Match>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2Match>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2MatchesIdGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Match;  }> {
        const localVarPath = this.basePath + '/v2/matches/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2MatchesIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Match;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Match");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id Unique identifier of the resource.
     * @param match Match information to save
     * @param {*} [options] Override http request options.
     */
    public v2MatchesIdPut (id: string, match: V2MatchInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Match;  }> {
        const localVarPath = this.basePath + '/v2/matches/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2MatchesIdPut.');
        }

        // verify required parameter 'match' is not null or undefined
        if (match === null || match === undefined) {
            throw new Error('Required parameter match was null or undefined when calling v2MatchesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(match, "V2MatchInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Match;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Match");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of matches
     * @param matchIds Filter matches by their IDs
     * @param date Filter matches by the date when they were played, format is ISO 8601
     * @param utcOffset Filter matches by date and UTC offset, allowed value range: [-12,14]
     * @param tournamentGroup Filter matches by a tournament group code
     * @param statusTypes Filter matches by status types
     * @param selectionFilter Fetch selected matches for specific date and tournament_group
     * @param {*} [options] Override http request options.
     */
    public v2MatchesLivescoreGet (matchIds?: Array<number>, date?: string, utcOffset?: number, tournamentGroup?: string, statusTypes?: Array<'FINISHED' | 'NOT_STARTED' | 'LIVE' | 'INTERRUPTED' | 'CANCELLED' | 'UNKNOWN'>, selectionFilter?: 'ENABLED' | 'DISABLED', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2Match>;  }> {
        const localVarPath = this.basePath + '/v2/matches/livescore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (matchIds !== undefined) {
            localVarQueryParameters['match_ids'] = ObjectSerializer.serialize(matchIds, "Array<number>");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        if (utcOffset !== undefined) {
            localVarQueryParameters['utc_offset'] = ObjectSerializer.serialize(utcOffset, "number");
        }

        if (tournamentGroup !== undefined) {
            localVarQueryParameters['tournament_group'] = ObjectSerializer.serialize(tournamentGroup, "string");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status_types'] = ObjectSerializer.serialize(statusTypes, "Array<'FINISHED' | 'NOT_STARTED' | 'LIVE' | 'INTERRUPTED' | 'CANCELLED' | 'UNKNOWN'>");
        }

        if (selectionFilter !== undefined) {
            localVarQueryParameters['selection_filter'] = ObjectSerializer.serialize(selectionFilter, "'ENABLED' | 'DISABLED'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2Match>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2Match>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param match Match information to save
     * @param {*} [options] Override http request options.
     */
    public v2MatchesPost (match: V2MatchInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Match;  }> {
        const localVarPath = this.basePath + '/v2/matches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'match' is not null or undefined
        if (match === null || match === undefined) {
            throw new Error('Required parameter match was null or undefined when calling v2MatchesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(match, "V2MatchInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Match;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Match");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OddsApiApiKeys {
}

export class OddsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OddsApiApiKeys, value: string) {
        (this.authentications as any)[OddsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get available liveodds for an event
     * @param id Unique identifier of the resource.
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param {*} [options] Override http request options.
     */
    public eventsIdLiveoddsGet (id: string, xOddClient: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/events/{id}/liveodds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdLiveoddsGet.');
        }

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling eventsIdLiveoddsGet.');
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of odds available in the system
     * @param id Unique identifier of the resource.
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param {*} [options] Override http request options.
     */
    public eventsIdOddsGet (id: string, xOddClient: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/events/{id}/odds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdOddsGet.');
        }

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling eventsIdOddsGet.');
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get available pre-game odds for an Event
     * @param id Unique identifier of the resource.
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param {*} [options] Override http request options.
     */
    public eventsIdPregameoddsGet (id: string, xOddClient: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/events/{id}/pregameodds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdPregameoddsGet.');
        }

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling eventsIdPregameoddsGet.');
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of liveodds available in the system
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param {*} [options] Override http request options.
     */
    public liveoddsGet (xOddClient: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/liveodds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling liveoddsGet.');
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Return a list of OddProviders available in the system. If X-Odd-Client is specified they will be filtered and ordered by the client configuration.
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param {*} [options] Override http request options.
     */
    public oddProvidersGet (xOddClient: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<OddProvider>;  }> {
        const localVarPath = this.basePath + '/odd_providers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling oddProvidersGet.');
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<OddProvider>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OddProvider>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of Odds
     * @param oddClient Odd client code
     * @param sportType Sport type filter
     * @param eventType Event type filter
     * @param fromEventStartTime Return odds for Events with start_time &gt;&#x3D; from_event_start_time. RFC 3339 format
     * @param toEventStartTime Return odds for Events with start_time &lt;&#x3D; to_event_start_time. RFC 3339 format
     * @param teamId Team ID
     * @param teamIds List for team IDs separated by commas.
     * @param eventOrder Order matching events for a specific client
     * @param matchIds List for match IDs separated by commas.
     * @param tournamentIds List for tournament IDs separated by commas.
     * @param seasonIds List for season IDs separated by commas.
     * @param oddsType Pregame or live odds selector.
     * @param {*} [options] Override http request options.
     */
    public oddsGet (oddClient: string, sportType: 'football', eventType: 'match', fromEventStartTime?: Date, toEventStartTime?: Date, teamId?: number, teamIds?: string, eventOrder?: string, matchIds?: string, tournamentIds?: string, seasonIds?: string, oddsType?: 'prematch' | 'live' | 'all', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/odds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oddClient' is not null or undefined
        if (oddClient === null || oddClient === undefined) {
            throw new Error('Required parameter oddClient was null or undefined when calling oddsGet.');
        }

        // verify required parameter 'sportType' is not null or undefined
        if (sportType === null || sportType === undefined) {
            throw new Error('Required parameter sportType was null or undefined when calling oddsGet.');
        }

        // verify required parameter 'eventType' is not null or undefined
        if (eventType === null || eventType === undefined) {
            throw new Error('Required parameter eventType was null or undefined when calling oddsGet.');
        }

        if (fromEventStartTime !== undefined) {
            localVarQueryParameters['from_event_start_time'] = ObjectSerializer.serialize(fromEventStartTime, "Date");
        }

        if (toEventStartTime !== undefined) {
            localVarQueryParameters['to_event_start_time'] = ObjectSerializer.serialize(toEventStartTime, "Date");
        }

        if (oddClient !== undefined) {
            localVarQueryParameters['odd_client'] = ObjectSerializer.serialize(oddClient, "string");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "number");
        }

        if (teamIds !== undefined) {
            localVarQueryParameters['team_ids'] = ObjectSerializer.serialize(teamIds, "string");
        }

        if (eventOrder !== undefined) {
            localVarQueryParameters['event_order'] = ObjectSerializer.serialize(eventOrder, "string");
        }

        if (sportType !== undefined) {
            localVarQueryParameters['sport_type'] = ObjectSerializer.serialize(sportType, "'football'");
        }

        if (matchIds !== undefined) {
            localVarQueryParameters['match_ids'] = ObjectSerializer.serialize(matchIds, "string");
        }

        if (tournamentIds !== undefined) {
            localVarQueryParameters['tournament_ids'] = ObjectSerializer.serialize(tournamentIds, "string");
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['event_type'] = ObjectSerializer.serialize(eventType, "'match'");
        }

        if (oddsType !== undefined) {
            localVarQueryParameters['odds_type'] = ObjectSerializer.serialize(oddsType, "'prematch' | 'live' | 'all'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of Odd Providers which have odds available for a given Event
     * @param xOddClient Identifies the client for which to return filtered bookmakers with affiliate URLs. Without the parameter can not sort odd_providers or provide affiliate links. Instead it will sometimes give a &#39;coupon&#39; key with the odds fo building URLs.
     * @param fromTime Return odds for Events with start_time &gt;&#x3D; from_time. RFC 3339 format
     * @param toTime Return odds for Events with start_time &lt;&#x3D; to_time. RFC 3339 format
     * @param {*} [options] Override http request options.
     */
    public pregameoddsGet (xOddClient: string, fromTime?: Date, toTime?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Odd>;  }> {
        const localVarPath = this.basePath + '/pregameodds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xOddClient' is not null or undefined
        if (xOddClient === null || xOddClient === undefined) {
            throw new Error('Required parameter xOddClient was null or undefined when calling pregameoddsGet.');
        }

        if (fromTime !== undefined) {
            localVarQueryParameters['from_time'] = ObjectSerializer.serialize(fromTime, "Date");
        }

        if (toTime !== undefined) {
            localVarQueryParameters['to_time'] = ObjectSerializer.serialize(toTime, "Date");
        }

        localVarHeaderParams['X-Odd-Client'] = ObjectSerializer.serialize(xOddClient, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Odd>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Odd>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlayerStatisticApiApiKeys {
}

export class PlayerStatisticApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlayerStatisticApiApiKeys, value: string) {
        (this.authentications as any)[PlayerStatisticApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * 
     * @param languageCode Return translations depending on language code
     * @param playerIds List for player IDs separated by commas.
     * @param seasonIds List for season IDs separated by commas.
     * @param teamId Return only statistics for players which are currently in the specified team&#39;s squad
     * @param {*} [options] Override http request options.
     */
    public statisticsPlayersGet (languageCode: string, playerIds?: string, seasonIds?: string, teamId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<OutputDto>;  }> {
        const localVarPath = this.basePath + '/statistics/players';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'languageCode' is not null or undefined
        if (languageCode === null || languageCode === undefined) {
            throw new Error('Required parameter languageCode was null or undefined when calling statisticsPlayersGet.');
        }

        if (playerIds !== undefined) {
            localVarQueryParameters['player_ids'] = ObjectSerializer.serialize(playerIds, "string");
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "string");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "number");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<OutputDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OutputDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk Upsert player statistics
     * @param playerStatistics Array of player match statistics
     * @param {*} [options] Override http request options.
     */
    public v2StatisticsPlayersMatchPut (playerStatistics?: Array<V2PlayerStatisticInput>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2PlayerStatisticOutput>;  }> {
        const localVarPath = this.basePath + '/v2/statistics/players/match';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(playerStatistics, "Array<V2PlayerStatisticInput>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2PlayerStatisticOutput>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2PlayerStatisticOutput>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve player statistics, grouped by player and season
     * @param playerIds CSV list of player id values
     * @param seasonIds CSV list of tournament season id values
     * @param teamId Team unique identifier
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2StatisticsPlayersSeasonGet (playerIds?: string, seasonIds?: string, teamId?: number, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2PlayerSeasonStatisticOutputCollection>;  }> {
        const localVarPath = this.basePath + '/v2/statistics/players/season';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (playerIds !== undefined) {
            localVarQueryParameters['player_ids'] = ObjectSerializer.serialize(playerIds, "string");
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "string");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "number");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2PlayerSeasonStatisticOutputCollection>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2PlayerSeasonStatisticOutputCollection>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlayersApiApiKeys {
}

export class PlayersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlayersApiApiKeys, value: string) {
        (this.authentications as any)[PlayersApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Search player list by parameters
     * @param name Filter players by names. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#39;Ronaldo&#39; it will match both &#39;Cristiono Ronaldo&#39; and &#39;Ronaldo&#39;
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param maxResults Limit the number of results returned
     * @param teamId Return only players which are currently in the specified team&#39;s squad
     * @param {*} [options] Override http request options.
     */
    public playersGet (name: string, acceptLanguage?: string, maxResults?: number, teamId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Player>;  }> {
        const localVarPath = this.basePath + '/players';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling playersGet.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (maxResults !== undefined) {
            localVarQueryParameters['max_results'] = ObjectSerializer.serialize(maxResults, "number");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "number");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Player>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Player>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information about a specific Player
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param expand Specify additional information to include in the response
     * @param {*} [options] Override http request options.
     */
    public playersIdGet (id: string, acceptLanguage?: string, expand?: 'club' | 'club,current_league', options: any = {}) : Promise<{ response: http.ClientResponse; body: PlayerProfile;  }> {
        const localVarPath = this.basePath + '/players/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling playersIdGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'club' | 'club,current_league'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PlayerProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PlayerProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns statistics throughout a Player's career
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param type Filter statistics for different types of team and competition
     * @param groupBy Group response by a given property
     * @param {*} [options] Override http request options.
     */
    public playersIdStatisticsGet (id: string, acceptLanguage?: string, type?: 'club' | 'national' | 'league', groupBy?: 'tournament' | 'team', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PlayerStatistics>;  }> {
        const localVarPath = this.basePath + '/players/{id}/statistics'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling playersIdStatisticsGet.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'club' | 'national' | 'league'");
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'tournament' | 'team'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PlayerStatistics>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PlayerStatistics>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the Teams in which a Player has participated during his career
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public playersIdTeamsGet (id: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PlayerTeam>;  }> {
        const localVarPath = this.basePath + '/players/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling playersIdTeamsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PlayerTeam>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PlayerTeam>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search player list by parameters
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit Limit the number of results returned
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2PlayersGet (offset: number, limit: number, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PlayerPageDto;  }> {
        const localVarPath = this.basePath + '/v2/players';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling v2PlayersGet.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling v2PlayersGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PlayerPageDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PlayerPageDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the active clubs of a player
     * @param id Unique identifier of the resource.
     * @param clubs Active clubs input
     * @param {*} [options] Override http request options.
     */
    public v2PlayersIdClubsActivePut (id: string, clubs?: V2ActiveClubsInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2PlayerActiveClub>;  }> {
        const localVarPath = this.basePath + '/v2/players/{id}/clubs/active'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2PlayersIdClubsActivePut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(clubs, "V2ActiveClubsInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2PlayerActiveClub>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2PlayerActiveClub>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get player by id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2PlayersIdGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2PlayerProfile;  }> {
        const localVarPath = this.basePath + '/v2/players/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2PlayersIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2PlayerProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2PlayerProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Player information
     * @param player Player information to save in persistance
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2PlayersIdPut (player: PlayerEditDto, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/players/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'player' is not null or undefined
        if (player === null || player === undefined) {
            throw new Error('Required parameter player was null or undefined when calling v2PlayersIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2PlayersIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(player, "PlayerEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store a newly created player in storage.
     * @param player PlayerEditDto object
     * @param {*} [options] Override http request options.
     */
    public v2PlayersPost (player?: PlayerEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: PlayerDto;  }> {
        const localVarPath = this.basePath + '/v2/players';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(player, "PlayerEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PlayerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PlayerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PresidentsApiApiKeys {
}

export class PresidentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PresidentsApiApiKeys, value: string) {
        (this.authentications as any)[PresidentsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Update president information
     * @param id Unique identifier of the resource.
     * @param president President information to save in persistance
     * @param {*} [options] Override http request options.
     */
    public v2PresidentsIdPut (id: string, president?: V2PresidentUpdate, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2President;  }> {
        const localVarPath = this.basePath + '/v2/presidents/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2PresidentsIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(president, "V2PresidentUpdate")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2President;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2President");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store a newly created president in storage
     * @param president 
     * @param {*} [options] Override http request options.
     */
    public v2PresidentsPost (president?: V2PresidentInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2President;  }> {
        const localVarPath = this.basePath + '/v2/presidents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(president, "V2PresidentInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2President;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2President");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProviderMappingsApiApiKeys {
}

export class ProviderMappingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProviderMappingsApiApiKeys, value: string) {
        (this.authentications as any)[ProviderMappingsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Bulk find provider to internal ID mappings by their provider ID and entity type.
     * @param mappingRequest Data entity provider name and array of mapping requests
     * @param {*} [options] Override http request options.
     */
    public v2MappingsSearchPost (mappingRequest?: MappingRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<V2MappingDto>;  }> {
        const localVarPath = this.basePath + '/v2/mappings/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mappingRequest, "MappingRequest")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<V2MappingDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<V2MappingDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RefereesApiApiKeys {
}

export class RefereesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RefereesApiApiKeys, value: string) {
        (this.authentications as any)[RefereesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * List referees with offset and limit parameters
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit Limit the number of results returned
     * @param seasonIds Filter referees which have refereed matches in the specified CSV season_ids
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2RefereesGet (offset: number, limit: number, seasonIds?: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RefereePageDto;  }> {
        const localVarPath = this.basePath + '/v2/referees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling v2RefereesGet.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling v2RefereesGet.');
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefereePageDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefereePageDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get referee by id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2RefereesIdGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RefereeDto;  }> {
        const localVarPath = this.basePath + '/v2/referees/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2RefereesIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefereeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefereeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update referee information
     * @param id Unique identifier of the resource.
     * @param referee Referee information to save in persistance
     * @param {*} [options] Override http request options.
     */
    public v2RefereesIdPut (id: string, referee?: RefereeEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: RefereeDto;  }> {
        const localVarPath = this.basePath + '/v2/referees/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2RefereesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(referee, "RefereeEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefereeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefereeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store a newly created referee in storage
     * @param referee 
     * @param {*} [options] Override http request options.
     */
    public v2RefereesPost (referee?: RefereeEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: RefereeDto;  }> {
        const localVarPath = this.basePath + '/v2/referees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(referee, "RefereeEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RefereeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefereeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RoundsApiApiKeys {
}

export class RoundsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RoundsApiApiKeys, value: string) {
        (this.authentications as any)[RoundsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of rounds per season
     * @param seasonId Filter round types per a season ID
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2RoundsGet (seasonId: number, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2RoundTypes;  }> {
        const localVarPath = this.basePath + '/v2/rounds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seasonId' is not null or undefined
        if (seasonId === null || seasonId === undefined) {
            throw new Error('Required parameter seasonId was null or undefined when calling v2RoundsGet.');
        }

        if (seasonId !== undefined) {
            localVarQueryParameters['season_id'] = ObjectSerializer.serialize(seasonId, "number");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2RoundTypes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2RoundTypes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of rounds per stage
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2StagesIdRoundsGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2RoundTypes;  }> {
        const localVarPath = this.basePath + '/v2/stages/{id}/rounds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StagesIdRoundsGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2RoundTypes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2RoundTypes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SeasonApiApiKeys {
}

export class SeasonApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SeasonApiApiKeys, value: string) {
        (this.authentications as any)[SeasonApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get the details of a season by season_id, or by tournament_id and active status
     * @param seasonId The ID of the season of interest
     * @param tournamentId The ID of the tournament whose active season is of interest
     * @param status Required only when the tournament_id parameter is provided
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2SeasonsDetailsGet (seasonId?: string, tournamentId?: string, status?: 'CURRENT', languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2SeasonDetails;  }> {
        const localVarPath = this.basePath + '/v2/seasons/details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (seasonId !== undefined) {
            localVarQueryParameters['season_id'] = ObjectSerializer.serialize(seasonId, "string");
        }

        if (tournamentId !== undefined) {
            localVarQueryParameters['tournament_id'] = ObjectSerializer.serialize(tournamentId, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'CURRENT'");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2SeasonDetails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2SeasonDetails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get seasons by tournament_id, team_id and status
     * @param tournamentId Required only if no other parameters are provided
     * @param teamId Required only if no other paramenters are provided
     * @param status Required only if no other parameters are provided
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2SeasonsGet (tournamentId?: string, teamId?: string, status?: 'ACTIVE', languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2SeasonList;  }> {
        const localVarPath = this.basePath + '/v2/seasons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (tournamentId !== undefined) {
            localVarQueryParameters['tournament_id'] = ObjectSerializer.serialize(tournamentId, "string");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'ACTIVE'");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2SeasonList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2SeasonList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing season
     * @param id Unique identifier of the resource.
     * @param name Season name
     * @param {*} [options] Override http request options.
     */
    public v2SeasonsIdPut (id: string, name: V2TournamentSeasonUpdateInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Season;  }> {
        const localVarPath = this.basePath + '/v2/seasons/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2SeasonsIdPut.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling v2SeasonsIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(name, "V2TournamentSeasonUpdateInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Season;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Season");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all stages for specific season
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2SeasonsIdStagesGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2SeasonStageCollection;  }> {
        const localVarPath = this.basePath + '/v2/seasons/{id}/stages'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2SeasonsIdStagesGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2SeasonStageCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2SeasonStageCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update multiple stages
     * @param stages List of stages to be updated or created
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2SeasonsIdStagesPost (stages: Array<V2SeasonStage>, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2SeasonStageCollection;  }> {
        const localVarPath = this.basePath + '/v2/seasons/{id}/stages'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stages' is not null or undefined
        if (stages === null || stages === undefined) {
            throw new Error('Required parameter stages was null or undefined when calling v2SeasonsIdStagesPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2SeasonsIdStagesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(stages, "Array<V2SeasonStage>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2SeasonStageCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2SeasonStageCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new season
     * @param season Season information
     * @param {*} [options] Override http request options.
     */
    public v2SeasonsPost (season: V2TournamentSeasonInsertInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Season;  }> {
        const localVarPath = this.basePath + '/v2/seasons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'season' is not null or undefined
        if (season === null || season === undefined) {
            throw new Error('Required parameter season was null or undefined when calling v2SeasonsPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(season, "V2TournamentSeasonInsertInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Season;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Season");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Permanently delete stage
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2StagesIdDelete (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/stages/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StagesIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the current season as active and change all other seasons in the tournament to inactive
     * @param id Unique identifier of the resource.
     * @param seasonId Season unique identifier
     * @param {*} [options] Override http request options.
     */
    public v2TournamentsIdSeasonsCurrentPatch (id: string, seasonId: V2TournamentSeasonStatusInput, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Season;  }> {
        const localVarPath = this.basePath + '/v2/tournaments/{id}/seasons/current'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2TournamentsIdSeasonsCurrentPatch.');
        }

        // verify required parameter 'seasonId' is not null or undefined
        if (seasonId === null || seasonId === undefined) {
            throw new Error('Required parameter seasonId was null or undefined when calling v2TournamentsIdSeasonsCurrentPatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(seasonId, "V2TournamentSeasonStatusInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Season;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Season");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StagesApiApiKeys {
}

export class StagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StagesApiApiKeys, value: string) {
        (this.authentications as any)[StagesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Listing for Stages resources
     * @param teamId Filter stages by a team which is participating in the stage
     * @param tournamentIds CSV list of tournament.id values to filter stages
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public stagesGet (teamId?: number, tournamentIds?: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<StageDto>;  }> {
        const localVarPath = this.basePath + '/stages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "number");
        }

        if (tournamentIds !== undefined) {
            localVarQueryParameters['tournament_ids'] = ObjectSerializer.serialize(tournamentIds, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<StageDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<StageDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Permanently delete group
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2GroupsIdDelete (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2GroupsIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all groups for specific stage
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2StagesIdGroupsGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2StageGroupCollection;  }> {
        const localVarPath = this.basePath + '/v2/stages/{id}/groups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StagesIdGroupsGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2StageGroupCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2StageGroupCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update multiple groups
     * @param groups List of groups to be updated or created
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2StagesIdGroupsPost (groups: Array<V2StageGroup>, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2StageGroupCollection;  }> {
        const localVarPath = this.basePath + '/v2/stages/{id}/groups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groups' is not null or undefined
        if (groups === null || groups === undefined) {
            throw new Error('Required parameter groups was null or undefined when calling v2StagesIdGroupsPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StagesIdGroupsPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(groups, "Array<V2StageGroup>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2StageGroupCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2StageGroupCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace teams in stage
     * @param id Unique identifier of the resource.
     * @param teamId List of team ids
     * @param {*} [options] Override http request options.
     */
    public v2StagesIdTeamsPut (id: string, teamId: Array<V2StageTeamInput>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/stages/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StagesIdTeamsPut.');
        }

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling v2StagesIdTeamsPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teamId, "Array<V2StageTeamInput>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StandingRuleApiApiKeys {
}

export class StandingRuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StandingRuleApiApiKeys, value: string) {
        (this.authentications as any)[StandingRuleApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of available StandingRule objects in the system
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public standingRulesGet (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StandingRule;  }> {
        const localVarPath = this.basePath + '/standing_rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StandingRule;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StandingRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StandingsApiApiKeys {
}

export class StandingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StandingsApiApiKeys, value: string) {
        (this.authentications as any)[StandingsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Update a league standing table
     * @param standingEntries List of all entries for the standing
     * @param entity type of entity to attach standing to
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2StandingsLeagueEntityIdPut (standingEntries: V2LeagueStandingInput, entity: 'season' | 'stage' | 'group', id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/standings/league/{entity}/{id}'
            .replace('{' + 'entity' + '}', encodeURIComponent(String(entity)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'standingEntries' is not null or undefined
        if (standingEntries === null || standingEntries === undefined) {
            throw new Error('Required parameter standingEntries was null or undefined when calling v2StandingsLeagueEntityIdPut.');
        }

        // verify required parameter 'entity' is not null or undefined
        if (entity === null || entity === undefined) {
            throw new Error('Required parameter entity was null or undefined when calling v2StandingsLeagueEntityIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StandingsLeagueEntityIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(standingEntries, "V2LeagueStandingInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Attach standing rules to a league standing
     * @param standingRules list of rules for every rank
     * @param entity type of entity to attach standing to
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2StandingsLeagueEntityIdRulesPut (standingRules: V2StandingEntryRuleWrapper, entity: 'season' | 'stage' | 'group', id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/standings/league/{entity}/{id}/rules'
            .replace('{' + 'entity' + '}', encodeURIComponent(String(entity)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'standingRules' is not null or undefined
        if (standingRules === null || standingRules === undefined) {
            throw new Error('Required parameter standingRules was null or undefined when calling v2StandingsLeagueEntityIdRulesPut.');
        }

        // verify required parameter 'entity' is not null or undefined
        if (entity === null || entity === undefined) {
            throw new Error('Required parameter entity was null or undefined when calling v2StandingsLeagueEntityIdRulesPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StandingsLeagueEntityIdRulesPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(standingRules, "V2StandingEntryRuleWrapper")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a topscorer standing table
     * @param standingEntries List of all entries for the standing
     * @param entity type of entity to attach standing to
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2StandingsTopscorerEntityIdPut (standingEntries: V2TopScorerStandingInput, entity: 'season' | 'stage' | 'group', id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/standings/topscorer/{entity}/{id}'
            .replace('{' + 'entity' + '}', encodeURIComponent(String(entity)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'standingEntries' is not null or undefined
        if (standingEntries === null || standingEntries === undefined) {
            throw new Error('Required parameter standingEntries was null or undefined when calling v2StandingsTopscorerEntityIdPut.');
        }

        // verify required parameter 'entity' is not null or undefined
        if (entity === null || entity === undefined) {
            throw new Error('Required parameter entity was null or undefined when calling v2StandingsTopscorerEntityIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2StandingsTopscorerEntityIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(standingEntries, "V2TopScorerStandingInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamSquadApiApiKeys {
}

export class TeamSquadApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamSquadApiApiKeys, value: string) {
        (this.authentications as any)[TeamSquadApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get teams squad
     * @param id Unique identifier of the resource.
     * @param memberStatus 
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2TeamsIdSquadGet (id: string, memberStatus?: 'ALL' | 'ACTIVE' | 'INACTIVE', languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TeamSquad;  }> {
        const localVarPath = this.basePath + '/v2/teams/{id}/squad'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2TeamsIdSquadGet.');
        }

        if (memberStatus !== undefined) {
            localVarQueryParameters['memberStatus'] = ObjectSerializer.serialize(memberStatus, "'ALL' | 'ACTIVE' | 'INACTIVE'");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TeamSquad;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TeamSquad");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update TeamSquad members
     * @param squadMembers TeamSquad members to update. Null value for a property means no update
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2TeamsIdSquadPatch (squadMembers: V2TeamSquadInput, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TeamSquad;  }> {
        const localVarPath = this.basePath + '/v2/teams/{id}/squad'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'squadMembers' is not null or undefined
        if (squadMembers === null || squadMembers === undefined) {
            throw new Error('Required parameter squadMembers was null or undefined when calling v2TeamsIdSquadPatch.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2TeamsIdSquadPatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(squadMembers, "V2TeamSquadInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TeamSquad;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TeamSquad");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamStatsApiApiKeys {
}

export class TeamStatsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamStatsApiApiKeys, value: string) {
        (this.authentications as any)[TeamStatsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get statistics for the performance of each team involved in the event
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param lastUpdate Filter events, have been updated after the specified date-time. By default will return updates modified in the last 24 hours
     * @param {*} [options] Override http request options.
     */
    public eventTeamstatsGet (acceptLanguage?: string, lastUpdate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventTeamStats>;  }> {
        const localVarPath = this.basePath + '/event_teamstats';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lastUpdate !== undefined) {
            localVarQueryParameters['last_update'] = ObjectSerializer.serialize(lastUpdate, "Date");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventTeamStats>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventTeamStats>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get statistics for the performance of each team involved in the event
     * @param id Event.id for which team stats are requested
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public eventsIdTeamstatsGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventTeamStats>;  }> {
        const localVarPath = this.basePath + '/events/{id}/teamstats'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventsIdTeamstatsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventTeamStats>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventTeamStats>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TeamsApiApiKeys {
}

export class TeamsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TeamsApiApiKeys, value: string) {
        (this.authentications as any)[TeamsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get Teams for a specific Country.id
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param national Filter teams for different types of national and non national
     * @param {*} [options] Override http request options.
     */
    public countriesIdTeamsGet (id: string, acceptLanguage?: string, national?: '1' | '0' | 'true' | 'false', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Team>;  }> {
        const localVarPath = this.basePath + '/countries/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countriesIdTeamsGet.');
        }

        if (national !== undefined) {
            localVarQueryParameters['national'] = ObjectSerializer.serialize(national, "'1' | '0' | 'true' | 'false'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Team>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Team>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search all teams by parameters
     * @param name Filter by team. Length must be &gt;&#x3D; 4. The filter matches on a per word basis. If you query for &#39;United&#39; it will match both &#39;West Ham United&#39; and &#39;Newcastle United&#39;
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param maxResults Limit the number of results returned
     * @param countryId Filter teams just from the specified country
     * @param {*} [options] Override http request options.
     */
    public teamsGet (name: string, acceptLanguage?: string, maxResults?: number, countryId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Team>;  }> {
        const localVarPath = this.basePath + '/teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling teamsGet.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (maxResults !== undefined) {
            localVarQueryParameters['max_results'] = ObjectSerializer.serialize(maxResults, "number");
        }

        if (countryId !== undefined) {
            localVarQueryParameters['country_id'] = ObjectSerializer.serialize(countryId, "number");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Team>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Team>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of events in which a team with a specified id has participated
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param fromTime Filter events, which have a start_time after the specified date, format is RFC 3339
     * @param toTime Filter events, which have a start_time before the specified date, format is RFC 3339
     * @param direction Whether to sort the results by ascending or descending order
     * @param tournamentSeasonStageId Filter events for a specific tournament_season_stage.id
     * @param {*} [options] Override http request options.
     */
    public teamsIdEventsGet (id: string, acceptLanguage?: string, fromTime?: Date, toTime?: Date, direction?: 'asc' | 'desc', tournamentSeasonStageId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Event>;  }> {
        const localVarPath = this.basePath + '/teams/{id}/events'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdEventsGet.');
        }

        if (fromTime !== undefined) {
            localVarQueryParameters['from_time'] = ObjectSerializer.serialize(fromTime, "Date");
        }

        if (toTime !== undefined) {
            localVarQueryParameters['to_time'] = ObjectSerializer.serialize(toTime, "Date");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (tournamentSeasonStageId !== undefined) {
            localVarQueryParameters['tournament_season_stage_id'] = ObjectSerializer.serialize(tournamentSeasonStageId, "number");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Event>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Event>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Team form information accross all tournaments
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param expand Whether to include information about every event in the TeamForm response
     * @param {*} [options] Override http request options.
     */
    public teamsIdFormGet (id: string, acceptLanguage?: string, expand?: 'events', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TeamForm>;  }> {
        const localVarPath = this.basePath + '/teams/{id}/form'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdFormGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'events'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TeamForm>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TeamForm>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information about a specific Team
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param expand Specifies additional information to include with the Team response
     * @param {*} [options] Override http request options.
     */
    public teamsIdGet (id: string, acceptLanguage?: string, expand?: 'form' | 'form.events' | 'form.events,next_event', options: any = {}) : Promise<{ response: http.ClientResponse; body: Team;  }> {
        const localVarPath = this.basePath + '/teams/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'form' | 'form.events' | 'form.events,next_event'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the current squad for a Team
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Group players by a specific property
     * @param {*} [options] Override http request options.
     */
    public teamsIdPlayersGet (id: string, acceptLanguage?: string, groupBy?: 'position', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TeamPlayer>;  }> {
        const localVarPath = this.basePath + '/teams/{id}/players'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdPlayersGet.');
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'position'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TeamPlayer>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TeamPlayer>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get player statistics for the current season in the Team's League
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Group the response by a specific property
     * @param {*} [options] Override http request options.
     */
    public teamsIdPlayersStatisticsGet (id: string, acceptLanguage?: string, groupBy?: 'player.position', options: any = {}) : Promise<{ response: http.ClientResponse; body: TeamPlayerSeasonStatistics;  }> {
        const localVarPath = this.basePath + '/teams/{id}/players/statistics'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdPlayersStatisticsGet.');
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'player.position'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TeamPlayerSeasonStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamPlayerSeasonStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of TournamentSeasons for which Player Statistics are available
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public teamsIdPlayersStatisticsSeasonsGet (id: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TournamentSeasonWithTournament>;  }> {
        const localVarPath = this.basePath + '/teams/{id}/players/statistics/seasons'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdPlayersStatisticsSeasonsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TournamentSeasonWithTournament>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TournamentSeasonWithTournament>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get player statistics for the current season in the Team's League
     * @param seasonId Unique identifier of the TournamentSeason resource
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Group the response by a specific property
     * @param {*} [options] Override http request options.
     */
    public teamsIdPlayersStatisticsSeasonsSeasonIdGet (seasonId: number, id: string, acceptLanguage?: string, groupBy?: 'player.position', options: any = {}) : Promise<{ response: http.ClientResponse; body: TeamPlayerSeasonStatistics;  }> {
        const localVarPath = this.basePath + '/teams/{id}/players/statistics/seasons/{seasonId}'
            .replace('{' + 'seasonId' + '}', encodeURIComponent(String(seasonId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seasonId' is not null or undefined
        if (seasonId === null || seasonId === undefined) {
            throw new Error('Required parameter seasonId was null or undefined when calling teamsIdPlayersStatisticsSeasonsSeasonIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdPlayersStatisticsSeasonsSeasonIdGet.');
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'player.position'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TeamPlayerSeasonStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamPlayerSeasonStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the statistics for the latest League the team participates in
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param standing Select whether to include a full league standing or just the team&#39;s position
     * @param {*} [options] Override http request options.
     */
    public teamsIdStatisticsLeagueGet (id: string, acceptLanguage?: string, standing?: 'team' | 'full', options: any = {}) : Promise<{ response: http.ClientResponse; body: TeamSeasonStatistics;  }> {
        const localVarPath = this.basePath + '/teams/{id}/statistics/league'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling teamsIdStatisticsLeagueGet.');
        }

        if (standing !== undefined) {
            localVarQueryParameters['standing'] = ObjectSerializer.serialize(standing, "'team' | 'full'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TeamSeasonStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamSeasonStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Teams, which are participating in a given TournamentSeason
     * @param id Unique identifier of the TournamentSeason resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsIdTeamsGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsIdTeamsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PartialTeam>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Teams, which are participating in a given TournamentSeasonStage
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdTeamsGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdTeamsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PartialTeam>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Manually insert team colors by team or event.
     * @param teamColorsDto Team shirt colors data
     * @param {*} [options] Override http request options.
     */
    public v2TeamsColorsPost (teamColorsDto?: V2TeamColors, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TeamColors;  }> {
        const localVarPath = this.basePath + '/v2/teams/colors';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teamColorsDto, "V2TeamColors")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TeamColors;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TeamColors");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get teams list
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit Limit the number of results returned
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2TeamsGet (offset: number, limit: number, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TeamPageDto;  }> {
        const localVarPath = this.basePath + '/v2/teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling v2TeamsGet.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling v2TeamsGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TeamPageDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamPageDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get team by id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2TeamsIdGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TeamProfile;  }> {
        const localVarPath = this.basePath + '/v2/teams/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2TeamsIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TeamProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TeamProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Team information
     * @param team Team information to save in persistance
     * @param id Unique identifier of the resource.
     * @param {*} [options] Override http request options.
     */
    public v2TeamsIdPut (team: TeamEditDto, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TeamProfile;  }> {
        const localVarPath = this.basePath + '/v2/teams/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'team' is not null or undefined
        if (team === null || team === undefined) {
            throw new Error('Required parameter team was null or undefined when calling v2TeamsIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2TeamsIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(team, "TeamEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TeamProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TeamProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Manually insert team.
     * @param teamEditDto TeamEditDto object
     * @param {*} [options] Override http request options.
     */
    public v2TeamsPost (teamEditDto?: TeamEditDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TeamProfile;  }> {
        const localVarPath = this.basePath + '/v2/teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(teamEditDto, "TeamEditDto")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TeamProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TeamProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TournamentGroupsApiApiKeys {
}

export class TournamentGroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TournamentGroupsApiApiKeys, value: string) {
        (this.authentications as any)[TournamentGroupsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * List all tournaments for a given group name and their order
     * @param code Tournament group code
     * @param {*} [options] Override http request options.
     */
    public v2TournamentsGroupsCodeGet (code: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TournamentGroupGetOutput;  }> {
        const localVarPath = this.basePath + '/v2/tournaments/groups/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling v2TournamentsGroupsCodeGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TournamentGroupGetOutput;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TournamentGroupGetOutput");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing tournament group
     * @param code Tournament group unique code
     * @param group Tournament group information
     * @param {*} [options] Override http request options.
     */
    public v2TournamentsGroupsCodePut (code: string, group: V2TournamentGroupUpdateInput, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/tournaments/groups/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling v2TournamentsGroupsCodePut.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling v2TournamentsGroupsCodePut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "V2TournamentGroupUpdateInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param code Client code
     * @param date Date in ISO 8601 format (Y-m-d)
     * @param matchIds Array of match ids
     * @param {*} [options] Override http request options.
     */
    public v2TournamentsGroupsCodeSelectionDatePost (code: string, date: string, matchIds?: Array<V2TournamentGroupSelection>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/tournaments/groups/{code}/selection/{date}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)))
            .replace('{' + 'date' + '}', encodeURIComponent(String(date)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling v2TournamentsGroupsCodeSelectionDatePost.');
        }

        // verify required parameter 'date' is not null or undefined
        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling v2TournamentsGroupsCodeSelectionDatePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(matchIds, "Array<V2TournamentGroupSelection>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all tournament groups
     * @param {*} [options] Override http request options.
     */
    public v2TournamentsGroupsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: V2TournamentGroupCollection;  }> {
        const localVarPath = this.basePath + '/v2/tournaments/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2TournamentGroupCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2TournamentGroupCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new tournament group
     * @param group Tournament group information
     * @param {*} [options] Override http request options.
     */
    public v2TournamentsGroupsPost (group: V2TournamentGroupInsertInput, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/v2/tournaments/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling v2TournamentsGroupsPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "V2TournamentGroupInsertInput")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TournamentsApiApiKeys {
}

export class TournamentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TournamentsApiApiKeys, value: string) {
        (this.authentications as any)[TournamentsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get a list of available Tournament resources
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param countryId Get Tournaments from a specific Country.id
     * @param clientOrder Get Tournaments ordered for a specific client
     * @param expandClientSortorder Include extra information with Tournament response
     * @param {*} [options] Override http request options.
     */
    public tournamentsGet (acceptLanguage?: string, countryId?: number, clientOrder?: 'sportalios', expandClientSortorder?: 'sportalios', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Tournament>;  }> {
        const localVarPath = this.basePath + '/tournaments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (countryId !== undefined) {
            localVarQueryParameters['country_id'] = ObjectSerializer.serialize(countryId, "number");
        }

        if (clientOrder !== undefined) {
            localVarQueryParameters['client_order'] = ObjectSerializer.serialize(clientOrder, "'sportalios'");
        }

        if (expandClientSortorder !== undefined) {
            localVarQueryParameters['expand_client_sortorder'] = ObjectSerializer.serialize(expandClientSortorder, "'sportalios'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Tournament>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Tournament>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsIdGet (id: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TournamentWithSeasons;  }> {
        const localVarPath = this.basePath + '/tournaments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsIdGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TournamentWithSeasons;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TournamentWithSeasons");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of seasons for a given Tournament id
     * @param id Unique identifier of the resource.
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsIdSeasonsGet (id: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TournamentSeason>;  }> {
        const localVarPath = this.basePath + '/tournaments/{id}/seasons'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsIdSeasonsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TournamentSeason>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TournamentSeason>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information for the latest season for a given Tournament. This is an alias to whatever resource is first in /tournaments/{id}/seasons
     * @param id Unique identifier of the Tournament resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsIdSeasonsLatestGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TournamentSeasonWithStages;  }> {
        const localVarPath = this.basePath + '/tournaments/{id}/seasons/latest'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsIdSeasonsLatestGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TournamentSeasonWithStages;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TournamentSeasonWithStages");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a standing by red,yellow cards for a specific TournamentSeason resource.
     * @param id Unique identifier of the TournamentSeason resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsIdCardlistGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<CardlistStandingData>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/{id}/cardlist'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsIdCardlistGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CardlistStandingData>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CardlistStandingData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Events, for a given TournamentSeason
     * @param id Unique identifier of the TournamentSeason resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param groupBy Whether to group events by date
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsIdEventsGet (id: number, acceptLanguage?: string, groupBy?: 'date', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Event>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/{id}/events'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsIdEventsGet.');
        }

        if (groupBy !== undefined) {
            localVarQueryParameters['group_by'] = ObjectSerializer.serialize(groupBy, "'date'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Event>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Event>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information for a given TournamentSeason resource id.
     * @param id Unique identifier of the TournamentSeason resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsIdGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TournamentSeasonWithStages;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsIdGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TournamentSeasonWithStages;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TournamentSeasonWithStages");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Teams, which are participating in a given TournamentSeason
     * @param id Unique identifier of the TournamentSeason resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsIdTeamsGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsIdTeamsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PartialTeam>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of topscorers for a specific TournamentSeason resource.
     * @param id Unique identifier of the TournamentSeason resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsIdTopscorerGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TopscorerStandingData>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/{id}/topscorer'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsIdTopscorerGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TopscorerStandingData>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TopscorerStandingData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all currently active tournament season stages
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesActiveGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TournamentSeasonStage>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/active';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TournamentSeasonStage>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TournamentSeasonStage>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information for a StageGroup Resource
     * @param id Unique identifier of the StageGroup resource
     * @param expand Specify additional information to include with the response
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesGroupsIdGet (id: number, expand?: 'standing' | 'standing.rules' | 'standing.rules,standing.form' | 'standing.rules,standing.form.events' | 'standing.form' | 'standing.form.events', acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: StageGroupWithStandingTournamentSeasonStage;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesGroupsIdGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'standing' | 'standing.rules' | 'standing.rules,standing.form' | 'standing.rules,standing.form.events' | 'standing.form' | 'standing.form.events'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StageGroupWithStandingTournamentSeasonStage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StageGroupWithStandingTournamentSeasonStage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Standing for a StageGroup Resource
     * @param id Unique identifier of the StageGroup resource
     * @param expand Specify additional information to include with the response
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesGroupsIdStandingGet (id: number, expand?: 'rules' | 'rules,form' | 'rules,form.events' | 'form' | 'form.events', acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<LeagueStandingData>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/groups/{id}/standing'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesGroupsIdStandingGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'rules' | 'rules,form' | 'rules,form.events' | 'form' | 'form.events'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LeagueStandingData>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LeagueStandingData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of events which are fixtures in a given TournamentSeasonStage resource
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param round Filter the event list by a specific round
     * @param sortDirection Sort results by date in ascending or descending order
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdEventsGet (id: number, round?: string, sortDirection?: 'asc' | 'desc', acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<EventsByDate>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}/events'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdEventsGet.');
        }

        if (round !== undefined) {
            localVarQueryParameters['round'] = ObjectSerializer.serialize(round, "string");
        }

        if (sortDirection !== undefined) {
            localVarQueryParameters['sort_direction'] = ObjectSerializer.serialize(sortDirection, "'asc' | 'desc'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<EventsByDate>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventsByDate>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information for a TournamentSeasonStage Resource
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param expand Specify additional information to include with the response
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdGet (id: number, expand?: 'standing' | 'standing.rules' | 'standing.rules,standing.form' | 'standing.rules,standing.form.events' | 'standing.form' | 'standing.form.events', acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TournamentSeasonStageWithStandingGroups;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'standing' | 'standing.rules' | 'standing.rules,standing.form' | 'standing.rules,standing.form.events' | 'standing.form' | 'standing.form.events'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TournamentSeasonStageWithStandingGroups;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TournamentSeasonStageWithStandingGroups");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of rounds for a specific TournamentSeasonStage
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param expand Specify what additional information to include with the response
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdRoundsGet (id: number, expand?: 'events', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Round>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}/rounds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdRoundsGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'events'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Round>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Round>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Standing for a TournamentSeasonStage Resource
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param expand Specify additional information to include with the response
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdStandingGet (id: number, expand?: 'rules' | 'rules,form' | 'rules,form.events' | 'form' | 'form.events', acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<LeagueStandingData>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}/standing'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdStandingGet.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "'rules' | 'rules,form' | 'rules,form.events' | 'form' | 'form.events'");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LeagueStandingData>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LeagueStandingData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of Teams, which are participating in a given TournamentSeasonStage
     * @param id Unique identifier of the TournamentSeasonStage resource
     * @param acceptLanguage List of acceptable human languages for response. https://en.wikipedia.org/wiki/Content_negotiation
     * @param {*} [options] Override http request options.
     */
    public tournamentsSeasonsStagesIdTeamsGet (id: number, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }> {
        const localVarPath = this.basePath + '/tournaments/seasons/stages/{id}/teams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tournamentsSeasonsStagesIdTeamsGet.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PartialTeam>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PartialTeam>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TranslationsApiApiKeys {
}

export class TranslationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TranslationsApiApiKeys, value: string) {
        (this.authentications as any)[TranslationsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get all possible translation entities.
     * @param {*} [options] Override http request options.
     */
    public v2TranslationsEntitiesGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TranslationEntityDto>;  }> {
        const localVarPath = this.basePath + '/v2/translations/entities';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TranslationEntityDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TranslationEntityDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk Upsert translations by primary key
     * @param translations Array of translations
     * @param {*} [options] Override http request options.
     */
    public v2TranslationsPost (translations?: Array<TranslationDto>, options: any = {}) : Promise<{ response: http.ClientResponse; body: TranslationDto;  }> {
        const localVarPath = this.basePath + '/v2/translations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(translations, "Array<TranslationDto>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TranslationDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TranslationDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Bulk find in translations table and return matching entries by the unique translation key.
     * @param translationKeys Array of translationKeys
     * @param {*} [options] Override http request options.
     */
    public v2TranslationsSearchPost (translationKeys?: Array<TranslationKeyDto>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<TranslationDto>;  }> {
        const localVarPath = this.basePath + '/v2/translations/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(translationKeys, "Array<TranslationKeyDto>")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TranslationDto>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TranslationDto>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VenuesApiApiKeys {
}

export class VenuesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VenuesApiApiKeys, value: string) {
        (this.authentications as any)[VenuesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * List venues with offset and limit parameters
     * @param offset The number of items to skip before starting to collect the result set
     * @param limit Limit the number of results returned
     * @param seasonIds Filter venues which have hosted matches in the specified CSV season_ids
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2VenuesGet (offset: number, limit: number, seasonIds?: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2VenuesList;  }> {
        const localVarPath = this.basePath + '/v2/venues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling v2VenuesGet.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling v2VenuesGet.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (seasonIds !== undefined) {
            localVarQueryParameters['season_ids'] = ObjectSerializer.serialize(seasonIds, "string");
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2VenuesList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2VenuesList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get venue by id
     * @param id Unique identifier of the resource.
     * @param languageCode Returns translated response based on the language code
     * @param {*} [options] Override http request options.
     */
    public v2VenuesIdGet (id: string, languageCode?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2VenuesGetId;  }> {
        const localVarPath = this.basePath + '/v2/venues/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2VenuesIdGet.');
        }

        if (languageCode !== undefined) {
            localVarQueryParameters['language_code'] = ObjectSerializer.serialize(languageCode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2VenuesGetId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2VenuesGetId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update venue information
     * @param id Unique identifier of the resource.
     * @param venue Venue information to save in persistance
     * @param {*} [options] Override http request options.
     */
    public v2VenuesIdPut (id: string, venue?: V2PutVenues, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2VenuesPut;  }> {
        const localVarPath = this.basePath + '/v2/venues/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling v2VenuesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(venue, "V2PutVenues")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2VenuesPut;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2VenuesPut");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store a newly created venue in storage
     * @param venue 
     * @param {*} [options] Override http request options.
     */
    public v2VenuesPost (venue?: V2PostVenues, options: any = {}) : Promise<{ response: http.ClientResponse; body: V2Venues;  }> {
        const localVarPath = this.basePath + '/v2/venues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(venue, "V2PostVenues")
        };

        this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V2Venues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V2Venues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
