/* tslint:disable */
/* eslint-disable */
/**
 * Football API
 * API for accessing various kinds of football data, updated in real time.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    LiveCommentaryOutputDto,
    LiveCommentaryOutputDtoFromJSON,
    LiveCommentaryOutputDtoToJSON,
    NotFoundError,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    V2Match,
    V2MatchFromJSON,
    V2MatchToJSON,
    V2MatchInput,
    V2MatchInputFromJSON,
    V2MatchInputToJSON,
} from '../models';

export interface MatchesIdCommentaryGetRequest {
    id: string;
    languageCode: string;
}

export interface V2MatchesGetRequest {
    limit: number;
    offset: number;
    tournamentIds?: Array<number>;
    seasonIds?: Array<number>;
    stageIds?: Array<number>;
    groupIds?: Array<number>;
    roundIds?: Array<string>;
    roundFilter?: Array<string>;
    fromKickoffTime?: Date;
    toKickoffTime?: Date;
    teamIds?: Array<number>;
    statusTypes?: Array<string>;
    statusCodes?: Array<string>;
    refereeId?: number;
    venueId?: string;
    sortDirection?: string;
}

export interface V2MatchesIdGetRequest {
    id: string;
    languageCode?: string;
}

export interface V2MatchesIdPutRequest {
    id: string;
    match: V2MatchInput;
}

export interface V2MatchesLivescoreGetRequest {
    matchIds?: Array<number>;
    date?: Date;
    utcOffset?: number;
    tournamentGroup?: string;
    statusTypes?: Array<V2MatchesLivescoreGetStatusTypesEnum>;
    selectionFilter?: V2MatchesLivescoreGetSelectionFilterEnum;
}

export interface V2MatchesPostRequest {
    match: V2MatchInput;
}

/**
 * 
 */
export class MatchesApi extends runtime.BaseAPI {

    /**
     * Get a list of live commentaries with specified match id and language
     */
    async matchesIdCommentaryGetRaw(requestParameters: MatchesIdCommentaryGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<LiveCommentaryOutputDto>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling matchesIdCommentaryGet.');
        }

        if (requestParameters.languageCode === null || requestParameters.languageCode === undefined) {
            throw new runtime.RequiredError('languageCode','Required parameter requestParameters.languageCode was null or undefined when calling matchesIdCommentaryGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.languageCode !== undefined) {
            queryParameters['language_code'] = requestParameters.languageCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/matches/{id}/commentary`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LiveCommentaryOutputDtoFromJSON));
    }

    /**
     * Get a list of live commentaries with specified match id and language
     */
    async matchesIdCommentaryGet(requestParameters: MatchesIdCommentaryGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<LiveCommentaryOutputDto>> {
        const response = await this.matchesIdCommentaryGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of matches
     */
    async v2MatchesGetRaw(requestParameters: V2MatchesGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<V2Match>>> {
        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling v2MatchesGet.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling v2MatchesGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.tournamentIds) {
            queryParameters['tournament_ids'] = requestParameters.tournamentIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.seasonIds) {
            queryParameters['season_ids'] = requestParameters.seasonIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.stageIds) {
            queryParameters['stage_ids'] = requestParameters.stageIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.groupIds) {
            queryParameters['group_ids'] = requestParameters.groupIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.roundIds) {
            queryParameters['round_ids'] = requestParameters.roundIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.roundFilter) {
            queryParameters['round_filter'] = requestParameters.roundFilter.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.fromKickoffTime !== undefined) {
            queryParameters['from_kickoff_time'] = (requestParameters.fromKickoffTime as any).toISOString();
        }

        if (requestParameters.toKickoffTime !== undefined) {
            queryParameters['to_kickoff_time'] = (requestParameters.toKickoffTime as any).toISOString();
        }

        if (requestParameters.teamIds) {
            queryParameters['team_ids'] = requestParameters.teamIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.statusTypes) {
            queryParameters['status_types'] = requestParameters.statusTypes.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.statusCodes) {
            queryParameters['status_codes'] = requestParameters.statusCodes.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.refereeId !== undefined) {
            queryParameters['referee_id'] = requestParameters.refereeId;
        }

        if (requestParameters.venueId !== undefined) {
            queryParameters['venue_id'] = requestParameters.venueId;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/matches`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(V2MatchFromJSON));
    }

    /**
     * Get a list of matches
     */
    async v2MatchesGet(requestParameters: V2MatchesGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<V2Match>> {
        const response = await this.v2MatchesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async v2MatchesIdGetRaw(requestParameters: V2MatchesIdGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<V2Match>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling v2MatchesIdGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.languageCode !== undefined) {
            queryParameters['language_code'] = requestParameters.languageCode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/matches/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2MatchFromJSON(jsonValue));
    }

    /**
     */
    async v2MatchesIdGet(requestParameters: V2MatchesIdGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<V2Match> {
        const response = await this.v2MatchesIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async v2MatchesIdPutRaw(requestParameters: V2MatchesIdPutRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<V2Match>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling v2MatchesIdPut.');
        }

        if (requestParameters.match === null || requestParameters.match === undefined) {
            throw new runtime.RequiredError('match','Required parameter requestParameters.match was null or undefined when calling v2MatchesIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/matches/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: V2MatchInputToJSON(requestParameters.match),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2MatchFromJSON(jsonValue));
    }

    /**
     */
    async v2MatchesIdPut(requestParameters: V2MatchesIdPutRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<V2Match> {
        const response = await this.v2MatchesIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of matches
     */
    async v2MatchesLivescoreGetRaw(requestParameters: V2MatchesLivescoreGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<V2Match>>> {
        const queryParameters: any = {};

        if (requestParameters.matchIds) {
            queryParameters['match_ids'] = requestParameters.matchIds.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.date !== undefined) {
            queryParameters['date'] = (requestParameters.date as any).toISOString().substr(0,10);
        }

        if (requestParameters.utcOffset !== undefined) {
            queryParameters['utc_offset'] = requestParameters.utcOffset;
        }

        if (requestParameters.tournamentGroup !== undefined) {
            queryParameters['tournament_group'] = requestParameters.tournamentGroup;
        }

        if (requestParameters.statusTypes) {
            queryParameters['status_types'] = requestParameters.statusTypes.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.selectionFilter !== undefined) {
            queryParameters['selection_filter'] = requestParameters.selectionFilter;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/matches/livescore`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(V2MatchFromJSON));
    }

    /**
     * Get a list of matches
     */
    async v2MatchesLivescoreGet(requestParameters: V2MatchesLivescoreGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<V2Match>> {
        const response = await this.v2MatchesLivescoreGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async v2MatchesPostRaw(requestParameters: V2MatchesPostRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<V2Match>> {
        if (requestParameters.match === null || requestParameters.match === undefined) {
            throw new runtime.RequiredError('match','Required parameter requestParameters.match was null or undefined when calling v2MatchesPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/matches`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: V2MatchInputToJSON(requestParameters.match),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => V2MatchFromJSON(jsonValue));
    }

    /**
     */
    async v2MatchesPost(requestParameters: V2MatchesPostRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<V2Match> {
        const response = await this.v2MatchesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const V2MatchesLivescoreGetStatusTypesEnum = {
    Finished: 'FINISHED',
    NotStarted: 'NOT_STARTED',
    Live: 'LIVE',
    Interrupted: 'INTERRUPTED',
    Cancelled: 'CANCELLED',
    Unknown: 'UNKNOWN'
} as const;
export type V2MatchesLivescoreGetStatusTypesEnum = typeof V2MatchesLivescoreGetStatusTypesEnum[keyof typeof V2MatchesLivescoreGetStatusTypesEnum];
/**
 * @export
 */
export const V2MatchesLivescoreGetSelectionFilterEnum = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED'
} as const;
export type V2MatchesLivescoreGetSelectionFilterEnum = typeof V2MatchesLivescoreGetSelectionFilterEnum[keyof typeof V2MatchesLivescoreGetSelectionFilterEnum];
