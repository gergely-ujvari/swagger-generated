/* tslint:disable */
/* eslint-disable */
/**
 * Football API
 * API for accessing various kinds of football data, updated in real time.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Event,
    EventFromJSON,
    EventToJSON,
    EventIncident,
    EventIncidentFromJSON,
    EventIncidentToJSON,
    EventPlayer,
    EventPlayerFromJSON,
    EventPlayerToJSON,
    EventsByDate,
    EventsByDateFromJSON,
    EventsByDateToJSON,
    Lineup,
    LineupFromJSON,
    LineupToJSON,
    NotFoundError,
    NotFoundErrorFromJSON,
    NotFoundErrorToJSON,
    Odd,
    OddFromJSON,
    OddToJSON,
} from '../models';

export interface EventsByTeamsGetRequest {
    homeId: number;
    awayId: number;
    acceptLanguage?: string;
}

export interface EventsGetRequest {
    acceptLanguage?: string;
    fromTime?: Date;
    toTime?: Date;
    groupBy?: EventsGetGroupByEnum;
    clientOrder?: EventsGetClientOrderEnum;
}

export interface EventsIdGetRequest {
    id: string;
    acceptLanguage?: string;
    expand?: EventsIdGetExpandEnum;
}

export interface EventsIdIncidentsGetRequest {
    id: string;
    acceptLanguage?: string;
    groupBy?: EventsIdIncidentsGetGroupByEnum;
    direction?: EventsIdIncidentsGetDirectionEnum;
}

export interface EventsIdLineupsGetRequest {
    id: number;
    acceptLanguage?: string;
}

export interface EventsIdPlayersGetRequest {
    id: string;
    acceptLanguage?: string;
    groupBy?: EventsIdPlayersGetGroupByEnum;
}

export interface EventsIdPregameoddsGetRequest {
    id: string;
    xOddClient: string;
}

export interface EventsLiveGetRequest {
    acceptLanguage?: string;
    groupBy?: EventsLiveGetGroupByEnum;
}

export interface EventsSinceGetRequest {
    acceptLanguage?: string;
    lastUpdate?: Date;
}

export interface MatchesGetRequest {
    acceptLanguage?: string;
    fromStartTime?: Date;
    toStartTime?: Date;
    teamIds?: string;
    matchIds?: string;
    tournamentIds?: string;
    stageIds?: string;
    rounds?: string;
    seasonIds?: string;
    statusTypes?: MatchesGetStatusTypesEnum;
    offset?: number;
    limit?: number;
    tournamentOrder?: string;
    refereeId?: string;
    venueId?: string;
    statusCode?: string;
    sortDirection?: MatchesGetSortDirectionEnum;
}

export interface TournamentsSeasonsStagesIdEventsGetRequest {
    id: number;
    round?: string;
    sortDirection?: TournamentsSeasonsStagesIdEventsGetSortDirectionEnum;
    acceptLanguage?: string;
}

/**
 * 
 */
export class EventsApi extends runtime.BaseAPI {

    /**
     * Get a list of events by home and away team id
     */
    async eventsByTeamsGetRaw(requestParameters: EventsByTeamsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Event>> {
        if (requestParameters.homeId === null || requestParameters.homeId === undefined) {
            throw new runtime.RequiredError('homeId','Required parameter requestParameters.homeId was null or undefined when calling eventsByTeamsGet.');
        }

        if (requestParameters.awayId === null || requestParameters.awayId === undefined) {
            throw new runtime.RequiredError('awayId','Required parameter requestParameters.awayId was null or undefined when calling eventsByTeamsGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.homeId !== undefined) {
            queryParameters['home_id'] = requestParameters.homeId;
        }

        if (requestParameters.awayId !== undefined) {
            queryParameters['away_id'] = requestParameters.awayId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/by_teams`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventFromJSON(jsonValue));
    }

    /**
     * Get a list of events by home and away team id
     */
    async eventsByTeamsGet(requestParameters: EventsByTeamsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Event> {
        const response = await this.eventsByTeamsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of Events
     */
    async eventsGetRaw(requestParameters: EventsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        const queryParameters: any = {};

        if (requestParameters.fromTime !== undefined) {
            queryParameters['from_time'] = (requestParameters.fromTime as any).toISOString();
        }

        if (requestParameters.toTime !== undefined) {
            queryParameters['to_time'] = (requestParameters.toTime as any).toISOString();
        }

        if (requestParameters.groupBy !== undefined) {
            queryParameters['group_by'] = requestParameters.groupBy;
        }

        if (requestParameters.clientOrder !== undefined) {
            queryParameters['client_order'] = requestParameters.clientOrder;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Get a list of Events
     */
    async eventsGet(requestParameters: EventsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Event>> {
        const response = await this.eventsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async eventsIdGetRaw(requestParameters: EventsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Event>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling eventsIdGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EventFromJSON(jsonValue));
    }

    /**
     */
    async eventsIdGet(requestParameters: EventsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Event> {
        const response = await this.eventsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
     */
    async eventsIdIncidentsGetRaw(requestParameters: EventsIdIncidentsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<EventIncident>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling eventsIdIncidentsGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.groupBy !== undefined) {
            queryParameters['group_by'] = requestParameters.groupBy;
        }

        if (requestParameters.direction !== undefined) {
            queryParameters['direction'] = requestParameters.direction;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/{id}/incidents`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventIncidentFromJSON));
    }

    /**
     * Get a list of EventIncident for a specified Event (goal, subs, red cards, penalties, etc).
     */
    async eventsIdIncidentsGet(requestParameters: EventsIdIncidentsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<EventIncident>> {
        const response = await this.eventsIdIncidentsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get lineup information for an event. Includes players, formation and coach
     */
    async eventsIdLineupsGetRaw(requestParameters: EventsIdLineupsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Lineup>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling eventsIdLineupsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/{id}/lineups`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LineupFromJSON(jsonValue));
    }

    /**
     * Get lineup information for an event. Includes players, formation and coach
     */
    async eventsIdLineupsGet(requestParameters: EventsIdLineupsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Lineup> {
        const response = await this.eventsIdLineupsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
     */
    async eventsIdPlayersGetRaw(requestParameters: EventsIdPlayersGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<EventPlayer>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling eventsIdPlayersGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.groupBy !== undefined) {
            queryParameters['group_by'] = requestParameters.groupBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/{id}/players`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventPlayerFromJSON));
    }

    /**
     * Get a list of players which are involved in an Event. The list can be used to build lineups for the teams
     */
    async eventsIdPlayersGet(requestParameters: EventsIdPlayersGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<EventPlayer>> {
        const response = await this.eventsIdPlayersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get available pre-game odds for an Event
     */
    async eventsIdPregameoddsGetRaw(requestParameters: EventsIdPregameoddsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<Odd>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling eventsIdPregameoddsGet.');
        }

        if (requestParameters.xOddClient === null || requestParameters.xOddClient === undefined) {
            throw new runtime.RequiredError('xOddClient','Required parameter requestParameters.xOddClient was null or undefined when calling eventsIdPregameoddsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xOddClient !== undefined && requestParameters.xOddClient !== null) {
            headerParameters['X-Odd-Client'] = String(requestParameters.xOddClient);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/{id}/pregameodds`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OddFromJSON));
    }

    /**
     * Get available pre-game odds for an Event
     */
    async eventsIdPregameoddsGet(requestParameters: EventsIdPregameoddsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Odd>> {
        const response = await this.eventsIdPregameoddsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of events which are currently live
     */
    async eventsLiveGetRaw(requestParameters: EventsLiveGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        const queryParameters: any = {};

        if (requestParameters.groupBy !== undefined) {
            queryParameters['group_by'] = requestParameters.groupBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/live`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Get a list of events which are currently live
     */
    async eventsLiveGet(requestParameters: EventsLiveGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Event>> {
        const response = await this.eventsLiveGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of events which have been updated since the specified timestamp
     */
    async eventsSinceGetRaw(requestParameters: EventsSinceGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        const queryParameters: any = {};

        if (requestParameters.lastUpdate !== undefined) {
            queryParameters['last_update'] = (requestParameters.lastUpdate as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/events/since`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Get a list of events which have been updated since the specified timestamp
     */
    async eventsSinceGet(requestParameters: EventsSinceGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Event>> {
        const response = await this.eventsSinceGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of matches for team/between teams
     */
    async matchesGetRaw(requestParameters: MatchesGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<Event>>> {
        const queryParameters: any = {};

        if (requestParameters.fromStartTime !== undefined) {
            queryParameters['from_start_time'] = (requestParameters.fromStartTime as any).toISOString();
        }

        if (requestParameters.toStartTime !== undefined) {
            queryParameters['to_start_time'] = (requestParameters.toStartTime as any).toISOString();
        }

        if (requestParameters.teamIds !== undefined) {
            queryParameters['team_ids'] = requestParameters.teamIds;
        }

        if (requestParameters.matchIds !== undefined) {
            queryParameters['match_ids'] = requestParameters.matchIds;
        }

        if (requestParameters.tournamentIds !== undefined) {
            queryParameters['tournament_ids'] = requestParameters.tournamentIds;
        }

        if (requestParameters.stageIds !== undefined) {
            queryParameters['stage_ids'] = requestParameters.stageIds;
        }

        if (requestParameters.rounds !== undefined) {
            queryParameters['rounds'] = requestParameters.rounds;
        }

        if (requestParameters.seasonIds !== undefined) {
            queryParameters['season_ids'] = requestParameters.seasonIds;
        }

        if (requestParameters.statusTypes !== undefined) {
            queryParameters['status_types'] = requestParameters.statusTypes;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.tournamentOrder !== undefined) {
            queryParameters['tournament_order'] = requestParameters.tournamentOrder;
        }

        if (requestParameters.refereeId !== undefined) {
            queryParameters['referee_id'] = requestParameters.refereeId;
        }

        if (requestParameters.venueId !== undefined) {
            queryParameters['venue_id'] = requestParameters.venueId;
        }

        if (requestParameters.statusCode !== undefined) {
            queryParameters['status_code'] = requestParameters.statusCode;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/matches`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventFromJSON));
    }

    /**
     * Get a list of matches for team/between teams
     */
    async matchesGet(requestParameters: MatchesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<Event>> {
        const response = await this.matchesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of events which are fixtures in a given TournamentSeasonStage resource
     */
    async tournamentsSeasonsStagesIdEventsGetRaw(requestParameters: TournamentsSeasonsStagesIdEventsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<EventsByDate>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling tournamentsSeasonsStagesIdEventsGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.round !== undefined) {
            queryParameters['round'] = requestParameters.round;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/tournaments/seasons/stages/{id}/events`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventsByDateFromJSON));
    }

    /**
     * Get a list of events which are fixtures in a given TournamentSeasonStage resource
     */
    async tournamentsSeasonsStagesIdEventsGet(requestParameters: TournamentsSeasonsStagesIdEventsGetRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<EventsByDate>> {
        const response = await this.tournamentsSeasonsStagesIdEventsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const EventsGetGroupByEnum = {
    Empty: '',
    TournamentSeasonStage: 'tournament_season_stage'
} as const;
export type EventsGetGroupByEnum = typeof EventsGetGroupByEnum[keyof typeof EventsGetGroupByEnum];
/**
 * @export
 */
export const EventsGetClientOrderEnum = {
    Sportalios: 'sportalios'
} as const;
export type EventsGetClientOrderEnum = typeof EventsGetClientOrderEnum[keyof typeof EventsGetClientOrderEnum];
/**
 * @export
 */
export const EventsIdGetExpandEnum = {
    Form: 'form',
    FormEvents: 'form.events'
} as const;
export type EventsIdGetExpandEnum = typeof EventsIdGetExpandEnum[keyof typeof EventsIdGetExpandEnum];
/**
 * @export
 */
export const EventsIdIncidentsGetGroupByEnum = {
    Team: 'team'
} as const;
export type EventsIdIncidentsGetGroupByEnum = typeof EventsIdIncidentsGetGroupByEnum[keyof typeof EventsIdIncidentsGetGroupByEnum];
/**
 * @export
 */
export const EventsIdIncidentsGetDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EventsIdIncidentsGetDirectionEnum = typeof EventsIdIncidentsGetDirectionEnum[keyof typeof EventsIdIncidentsGetDirectionEnum];
/**
 * @export
 */
export const EventsIdPlayersGetGroupByEnum = {
    Team: 'team'
} as const;
export type EventsIdPlayersGetGroupByEnum = typeof EventsIdPlayersGetGroupByEnum[keyof typeof EventsIdPlayersGetGroupByEnum];
/**
 * @export
 */
export const EventsLiveGetGroupByEnum = {
    TournamentSeasonStage: 'tournament_season_stage'
} as const;
export type EventsLiveGetGroupByEnum = typeof EventsLiveGetGroupByEnum[keyof typeof EventsLiveGetGroupByEnum];
/**
 * @export
 */
export const MatchesGetStatusTypesEnum = {
    Finished: 'finished',
    Notstarted: 'notstarted',
    Inprogress: 'inprogress',
    Interrupted: 'interrupted',
    Cancelled: 'cancelled'
} as const;
export type MatchesGetStatusTypesEnum = typeof MatchesGetStatusTypesEnum[keyof typeof MatchesGetStatusTypesEnum];
/**
 * @export
 */
export const MatchesGetSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MatchesGetSortDirectionEnum = typeof MatchesGetSortDirectionEnum[keyof typeof MatchesGetSortDirectionEnum];
/**
 * @export
 */
export const TournamentsSeasonsStagesIdEventsGetSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type TournamentsSeasonsStagesIdEventsGetSortDirectionEnum = typeof TournamentsSeasonsStagesIdEventsGetSortDirectionEnum[keyof typeof TournamentsSeasonsStagesIdEventsGetSortDirectionEnum];
